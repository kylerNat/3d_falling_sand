
GLuint circle_program;
GLuint fullscreen_texture_program;
GLuint pad_lightprobes_program;
GLuint render_chunk_program;
GLuint render_depth_prepass_program;
GLuint simulate_body_program;
GLuint simulate_body_physics_program;
GLuint simulate_chunk_program;
GLuint simulate_particles_program;
GLuint update_lightmap_program;void gl_init_programs(memory_manager* manager){int error; size_t available_memory = current_block_unused(manager); byte* free_memory = reserve_block(manager, available_memory);circle_program = glCreateProgram(); assert(circle_program, "could not create circle_program, GL error", glGetError());
 GLuint circle_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(circle_program_GL_VERTEX_SHADER, "could not create circle_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\nlayout(location = 1) in vec3 X;\nlayout(location = 2) in float r;\nlayout(location = 3) in vec4 c;\n\nsmooth out vec4 color;\nsmooth out vec2 uv;\nsmooth out float radius;\n\nlayout(location = 0) uniform mat4 t;\n\nvoid main()\n{\n    gl_Position.xyz = (x*r+X);\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    uv = x.xy*r;\n    radius = r;\n    color = c;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_VERTEX_SHADER); glGetShaderiv(circle_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_VERTEX_SHADER); 

 GLuint circle_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(circle_program_GL_FRAGMENT_SHADER, "could not create circle_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform float smoothness;\n\nsmooth in vec4 color;\nsmooth in vec2 uv;\nsmooth in float radius;\n\nvoid main()\n{\n    frag_color = color;\n    float alpha = smoothstep(-radius, -radius+smoothness, -length(uv));\n    frag_color.a *= alpha;\n    gl_FragDepth = gl_FragCoord.z*alpha;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_FRAGMENT_SHADER); glGetShaderiv(circle_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); 
glLinkProgram(circle_program);glDetachShader(circle_program, circle_program_GL_VERTEX_SHADER); glDeleteShader(circle_program_GL_VERTEX_SHADER); 
glDetachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); glDeleteShader(circle_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(circle_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(circle_program, available_memory, 0, info_log); log_error(info_log); }fullscreen_texture_program = glCreateProgram(); assert(fullscreen_texture_program, "could not create fullscreen_texture_program, GL error", glGetError());
 GLuint fullscreen_texture_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(fullscreen_texture_program_GL_VERTEX_SHADER, "could not create fullscreen_texture_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5f*x.xy+0.5f;\n}\n\n"; glShaderSource(fullscreen_texture_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_VERTEX_SHADER); glGetShaderiv(fullscreen_texture_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); 

 GLuint fullscreen_texture_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(fullscreen_texture_program_GL_FRAGMENT_SHADER, "could not create fullscreen_texture_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n////////////////<2d circle fragment shader>////////////////\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform sampler2D color;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    frag_color = texture(color, uv);\n}\n"; glShaderSource(fullscreen_texture_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); glGetShaderiv(fullscreen_texture_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glLinkProgram(fullscreen_texture_program);glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); glDeleteShader(fullscreen_texture_program_GL_VERTEX_SHADER); 
glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); glDeleteShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(fullscreen_texture_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(fullscreen_texture_program, available_memory, 0, info_log); log_error(info_log); }pad_lightprobes_program = glCreateProgram(); assert(pad_lightprobes_program, "could not create pad_lightprobes_program, GL error", glGetError());
 GLuint pad_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(pad_lightprobes_program_GL_VERTEX_SHADER, "could not create pad_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 x;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\nsmooth out vec2 sample_oct;\n\nvoid main()\n{\n    gl_Position.xy = x;\n    gl_Position.z = 0.0f;\n    gl_Position.w = 1.0f;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(pad_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(pad_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint pad_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(pad_lightprobes_program_GL_FRAGMENT_SHADER, "could not create pad_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec4 depth;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 4\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvoid main()\n{\n    vec2 probe_pos = floor(gl_FragCoord.xy*(1.0f/lightprobe_padded_resolution));\n    vec2 oct = (gl_FragCoord.xy-probe_pos*lightprobe_padded_resolution-1.0f)/lightprobe_resolution-0.5f;\n    if(abs(oct.x) > abs(oct.y))\n        oct.y = -oct.y;\n    else\n        oct.x = -oct.x;\n    ivec2 sample_coord = ivec2(probe_pos*lightprobe_padded_resolution+1.0f\n                               +clamp((oct+0.5f)*lightprobe_resolution, 0, lightprobe_resolution-1));\n    color = texelFetch(lightprobe_color, sample_coord, 0);\n    depth = texelFetch(lightprobe_depth, sample_coord, 0);\n\n    color.a = 1;\n    depth.a = 1;\n}\n"; glShaderSource(pad_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(pad_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(pad_lightprobes_program);glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(pad_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(pad_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(pad_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }render_chunk_program = glCreateProgram(); assert(render_chunk_program, "could not create render_chunk_program, GL error", glGetError());
 GLuint render_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_chunk_program_GL_VERTEX_SHADER, "could not create render_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(render_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_chunk_program, render_chunk_program_GL_VERTEX_SHADER); 

 GLuint render_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_chunk_program_GL_FRAGMENT_SHADER, "could not create render_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 0) uniform mat3 camera_axes;\nlayout(location = 1) uniform vec3 camera_pos;\nlayout(location = 2) uniform isampler3D materials;\nlayout(location = 3) uniform usampler3D occupied_regions;\nlayout(location = 4) uniform ivec3 size;\nlayout(location = 5) uniform ivec3 origin;\nlayout(location = 6) uniform sampler2D lightprobe_color;\nlayout(location = 7) uniform sampler2D lightprobe_depth;\nlayout(location = 8) uniform sampler2D lightprobe_x;\nlayout(location = 9) uniform sampler2D blue_noise_texture;\nlayout(location = 10) uniform int frame_number;\n\n// #define DEBUG_DOTS\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nbool coarse_cast_ray(vec3 ray_dir, vec3 ray_origin, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal)\n{\n    float step_size = 1.0;\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    const int max_iterations = 8;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n        while(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return false;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return false;\n            }\n        }\n\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            normal = normalize(gradient);\n\n            hit_cell = ipos;\n            return true;\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            hit_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        pos += ray_dir*step_size;\n        hit_dist += step_size;\n        step_size += 0.25f*step_size;\n        ipos = ivec3(floor(pos));\n\n        // vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        // vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        // float min_dist = dot(dist, min_dir);\n        // pos += min_dist*ray_dir;\n        // ipos += ivec3(min_dir*ray_sign);\n        // hit_dist += min_dist;\n        // hit_dir = min_dir;\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\nint n_texture_reads = 0;\n\nbool cast_ray(vec3 ray_dir, vec3 ray_origin, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int max_iterations = 200;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n        while(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return false;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return false;\n            }\n        }\n\n        n_texture_reads++;\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            normal = normalize(gradient);\n\n            hit_cell = ipos;\n            return true;\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            hit_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        float min_dist = dot(dist, min_dir);\n        pos += min_dist*ray_dir;\n        ipos += ivec3(min_dir*ray_sign);\n        hit_dist += min_dist;\n        hit_dir = min_dir;\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 4\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    frag_color = vec4(0,0,0,1);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 0;\n\n    // // float prepass_jump_dist = max(texture(prepass_depth, 0.5f*screen_pos.xy+0.5f, 0).a-2.0f, 0.0f);\n    // float prepass_jump_dist = 10*max_iterations;\n    // for(int x = -1; x < 1; x++)\n    // for(int y = -1; y < 1; y++)\n    // {\n    //     prepass_jump_dist = clamp(\n    //         texture(prepass_depth, 0.5f*screen_pos.xy+0.5f+0.5f*vec2((x)/360.0f,(y)/180.0f), 0).a-4.0f,\n    //         0.0f, prepass_jump_dist);\n    // }\n    // // {\n    // //     frag_color.rgb = vec3(1.0f-prepass_jump_dist/200.0f);\n    // //     return;\n    // // }\n    // pos += prepass_jump_dist*ray_dir;\n    // total_dist += prepass_jump_dist;\n\n    float bounding_jump_dist = 0.0;\n    if(pos.x < 0 && ray_dir.x > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += bounding_jump_dist*ray_dir;\n    total_dist += bounding_jump_dist;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    bool hit = cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n\n    total_dist += hit_dist;\n    if(hit)\n    {\n        vec4 voxel = texelFetch(materials, hit_cell, 0);\n\n        float roughness = 0.0f;\n        vec3 emission = vec3(0.001f);\n        if(voxel.r == 2)\n        {\n            // emission = vec3(0.4,0.4,0.8);\n            emission = vec3(0.8,0.2,0.2)*100;\n        }\n        if(voxel.r == 1)\n        {\n            emission = vec3(0.54,0.44,0.21);\n        }\n        // if(voxel.r == 3)\n        // {\n        //     emission = vec3(0.5,0.125,0.5);\n        // }\n\n        // emission *= 1.0f-total_dist/(512.0f*sqrt(3));\n\n        if(voxel.r == 1)\n        {\n            reflectivity *= vec3(0.54,0.44,0.21);\n            roughness = 0.9;\n        }\n        else if(voxel.r == 3)\n        {\n            reflectivity *= vec3(0.5,0.5,1.0);\n            roughness = 0.5;\n        }\n        else\n        {\n            reflectivity *= vec3(0.1,0.1,0.2);\n            roughness = 0.1;\n        }\n\n        ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n        normal = normalize(normal);\n\n        // frag_color.rgb += reflectivity*emission*(0.9f+0.1f*normal)*dot(normal, gradient);\n        // frag_color.rgb += reflectivity*emission*(0.9f+0.1f*normal);\n        frag_color.rgb += emission;\n\n        gl_FragDepth = 1.0f-total_dist/(512.0f*sqrt(3));\n\n        reflectivity *= -dot(ray_dir, normal);\n\n        float n_samples = 1;\n        for(int samp = 0; samp < n_samples; samp++)\n        {\n            vec3 reflection_dir = ray_dir - 2*dot(ray_dir, normal)*normal;\n            reflection_dir += roughness*(blue_noise(gl_FragCoord.xy/256.0+samp*vec2(0.82,0.34)).xyz-0.5f);\n            reflection_dir = normalize(reflection_dir);\n            // vec3 reflection_dir = normal;\n            vec2 sample_depth;\n            frag_color.rgb += (1.0f/n_samples)*reflectivity*sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        }\n    }\n    // else\n    // {\n    //     vec2 sample_depth;\n    //     vec3 sample_color = sample_lightprobe_color(hit_pos, ray_dir, vec_to_oct(ray_dir), sample_depth);\n    //     gl_FragDepth = 1.0f-sample_depth.r/(512.0f*sqrt(3));\n    //     gl_FragDepth = clamp(gl_FragDepth, -1, 1);\n    //     frag_color.rgb = sample_color;\n    //     frag_color.a = 1.0f;\n    // }\n\n    // frag_color.rgb = mix(frag_color.rgb, sample_lightprobe_color(camera_pos, ray_dir, vec_to_oct(ray_dir)), 0.2);\n\n    // frag_color.rgb = mix(vec3(1,0,0), vec3(0,0,1), n_texture_reads*1.0/20);\n    // frag_color.rgb = mix(vec3(1,0,0), vec3(0,0,1), i*1.0/20);\n    // frag_color.rgb *= clamp(1.0-1.0*total_dist/chunk_size, 0, 1);\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n}\n"; glShaderSource(render_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_chunk_program, render_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_chunk_program);glDetachShader(render_chunk_program, render_chunk_program_GL_VERTEX_SHADER); glDeleteShader(render_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(render_chunk_program, render_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(render_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_chunk_program, available_memory, 0, info_log); log_error(info_log); }render_depth_prepass_program = glCreateProgram(); assert(render_depth_prepass_program, "could not create render_depth_prepass_program, GL error", glGetError());
 GLuint render_depth_prepass_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_depth_prepass_program_GL_VERTEX_SHADER, "could not create render_depth_prepass_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_depth_prepass_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_VERTEX_SHADER); glGetShaderiv(render_depth_prepass_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); 

 GLuint render_depth_prepass_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_depth_prepass_program_GL_FRAGMENT_SHADER, "could not create render_depth_prepass_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 depth;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform vec3 camera_pos;\nlayout(location = 3) uniform isampler3D materials;\nlayout(location = 4) uniform usampler3D occupied_regions;\nlayout(location = 5) uniform ivec3 size;\nlayout(location = 6) uniform ivec3 origin;\nlayout(location = 7) uniform sampler2D blue_noise_texture;\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+PHI*frame_number);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec2 sample_pos = screen_pos.xy;\n    sample_pos += (blue_noise(gl_FragCoord.xy/256.0f+vec2(0.319f, 0.712f)).xy-0.5f)/vec2(360, 180);\n    vec3 ray_dir = (16.0/9.0*sample_pos.x*camera_axes[0]\n                    +        sample_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    vec3 hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int max_iterations = 200;\n    int i = 0;\n    float total_dist = 0;\n\n    if(pos.x < 0 && ray_dir.x > 0)      total_dist = max(total_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) total_dist = max(total_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      total_dist = max(total_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) total_dist = max(total_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      total_dist = max(total_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) total_dist = max(total_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += total_dist*ray_dir;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    int bounces_remaining = 5;\n    bool first_hit = true;\n    vec3 color_multiplier = vec3(1,1,1);\n\n    depth = vec4(0.0);\n\n    // {\n    //     vec3 dist = ((0.5*ray_sign+0.5)*size-ray_sign*pos)*invabs_ray_dir;\n    //     float min_dist = dist.x;\n    //     int min_dir = 0;\n    //     if(dist.y < min_dist) {\n    //         min_dist = dist.y;\n    //         min_dir = 1;\n    //     }\n    //     if(dist.z < min_dist) {\n    //         min_dist = dist.z;\n    //         min_dir = 2;\n    //     }\n    //     ivec3 max_displacement = ivec3(ceil(abs(min_dist*ray_dir)));\n    //     max_iterations = max_displacement.x+max_displacement.y+max_displacement.z;\n    // }\n    // max_iterations = min(max_iterations, 100);\n    // max_iterations = max(max_iterations, 100);\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return;\n        }\n        while(texelFetch(occupied_regions, ipos/16, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos/16.0f)-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            total_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return;\n            }\n        }\n\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            float roughness = 0.0f;\n            vec3 emission = vec3(0.0f);\n            if(voxel.r == 2)\n            {\n                emission = vec3(0.05,0.05,0.1);\n            }\n            if(voxel.r == 4)\n            {\n                emission = vec3(1.0,1.0,1.0);\n            }\n\n            if(voxel.r > 1)\n            {\n                roughness = 0.8;\n            }\n            else\n            {\n                roughness = 0.9;\n            }\n\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            vec3 normal = gradient;\n            normal += roughness*(blue_noise(gl_FragCoord.xy/256.0).rgb-0.5f);\n            normal = normalize(normal);\n            gradient = normalize(gradient);\n\n            depth.rgb += color_multiplier*emission;\n\n            if(voxel.r == 1)\n            {\n                color_multiplier *= vec3(0.54,0.44,0.21);\n                roughness = 0.9;\n            }\n            else if(voxel.r == 3)\n            {\n                color_multiplier *= vec3(0.5,0.5,1.0);\n                roughness = 0.1;\n            }\n            else\n            {\n                color_multiplier *= vec3(0.1,0.1,0.2);\n                roughness = 0.1;\n            }\n\n            color_multiplier *= -dot(ray_dir, normal);\n\n            if(first_hit)\n            {\n                color_multiplier = vec3(1,1,1);\n                depth.rgb = vec3(0,0,0);\n                depth.a = total_dist;\n                first_hit = false;\n            }\n            if(bounces_remaining-- <= 0)\n            {\n                return;\n            }\n            else\n            {\n                ray_dir -= 2*dot(ray_dir, normal)*normal;\n                ray_sign = sign(ray_dir);\n\n                invabs_ray_dir = ray_sign/ray_dir;\n            }\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            total_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        float min_dist = dot(dist, min_dir);\n        pos += min_dist*ray_dir;\n        ipos += ivec3(min_dir*ray_sign);\n        total_dist += min_dist;\n        hit_dir = min_dir;\n\n        // if(first_hit)\n        // {^all that stuff}\n        // else\n        // {\n        //     pos += ray_dir*coarse_step;\n        //     total_dist += coarse_step;\n        //     ipos = ivec3(floor(pos));\n        //     coarse_step += 1.0f*coarse_step*(float_noise(pos.xy+pos.zz));\n        // }\n\n        if(++i >= max_iterations)\n        {\n            return;\n        }\n    }\n}\n"; glShaderSource(render_depth_prepass_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_depth_prepass_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_depth_prepass_program);glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); glDeleteShader(render_depth_prepass_program_GL_VERTEX_SHADER); 
glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); glDeleteShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_depth_prepass_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_depth_prepass_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_program = glCreateProgram(); assert(simulate_body_program, "could not create simulate_body_program, GL error", glGetError());
 GLuint simulate_body_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_body_program_GL_VERTEX_SHADER, "could not create simulate_body_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 4) uniform int n_bodies;\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nlayout(std430, binding = 0) buffer body_data\n{\n    body bodies[];\n};\n\nflat out int b;\n\nvoid main()\n{\n    b = gl_InstanceID;\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    float scale = 2.0/128.0;\n\n    gl_Position = vec4(0/0,0/0,0,1);\n\n    if(body_materials_origin.z <= layer && layer < body_materials_origin.z+body_size.z)\n    {\n        gl_Position.xy = scale*(body_materials_origin.xy+body_size.xy*x.xy)-1.0;\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_body_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_body_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_body_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_body_program, simulate_body_program_GL_VERTEX_SHADER); 

 GLuint simulate_body_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_body_program_GL_FRAGMENT_SHADER, "could not create simulate_body_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec4 frag_color;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int frame_number;\nlayout(location = 2) uniform isampler3D materials;\nlayout(location = 3) uniform isampler3D body_materials;\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nlayout(std430, binding = 0) buffer body_data\n{\n    body bodies[];\n};\n\nflat in int b;\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\nvoid main()\n{\n    ivec3 pos;\n    pos.xy = ivec2(gl_FragCoord.xy);\n    pos.z = layer;\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    uint rot = rand(rand(rand(frame_number)))%4;\n    int i = 0;\n    ivec2 dir = ivec2(((rot&1)*(2-rot)), (1-(rot&1))*(1-rot));\n\n    ivec4 c  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z), 0);\n    ivec4 u  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z+1), 0);\n    ivec4 d  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z-1), 0);\n    ivec4 r  = texelFetch(body_materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z), 0);\n    ivec4 l  = texelFetch(body_materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z), 0);\n    ivec4 f  = texelFetch(body_materials, ivec3(pos.x-dir.y, pos.y+dir.x, pos.z), 0);\n    ivec4 ba  = texelFetch(body_materials, ivec3(pos.x+dir.y, pos.y-dir.x, pos.z), 0);\n\n    // c.r = 1;\n    frag_color = c;\n\n    const int max_depth = 16;\n    if(c.r > 0)\n    {\n        if(l.r == 0 ||\n           r.r == 0 ||\n           u.r == 0 ||\n           d.r == 0 ||\n           f.r == 0 ||\n           ba.r == 0) frag_color.g = 0;\n        else\n        {\n            frag_color.g = -max_depth;\n            frag_color.g = max(frag_color.g, l.g-1);\n            frag_color.g = max(frag_color.g, r.g-1);\n            frag_color.g = max(frag_color.g, u.g-1);\n            frag_color.g = max(frag_color.g, d.g-1);\n            frag_color.g = max(frag_color.g, f.g-1);\n            frag_color.g = max(frag_color.g, ba.g-1);\n        }\n\n        frag_color.b = c.b/2;\n        if(frag_color.r == 3) frag_color.b = 1000;\n        // frag_color.b = 0;\n    }\n    else\n    {\n        frag_color.g = max_depth;\n        frag_color.g = min(frag_color.g, l.g+1);\n        frag_color.g = min(frag_color.g, r.g+1);\n        frag_color.g = min(frag_color.g, u.g+1);\n        frag_color.g = min(frag_color.g, d.g+1);\n        frag_color.g = min(frag_color.g, f.g+1);\n        frag_color.g = min(frag_color.g, ba.g+1);\n    }\n    frag_color.g = clamp(frag_color.g,-max_depth,max_depth);\n\n    frag_color.b = 1000;\n}\n"; glShaderSource(simulate_body_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_body_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_body_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_body_program, simulate_body_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_body_program);glDetachShader(simulate_body_program, simulate_body_program_GL_VERTEX_SHADER); glDeleteShader(simulate_body_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_body_program, simulate_body_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_body_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_body_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_physics_program = glCreateProgram(); assert(simulate_body_physics_program, "could not create simulate_body_physics_program, GL error", glGetError());
 GLuint simulate_body_physics_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_body_physics_program_GL_VERTEX_SHADER, "could not create simulate_body_physics_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5*x.xy+0.5;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_body_physics_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_body_physics_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_body_physics_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_physics_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_physics_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_body_physics_program, simulate_body_physics_program_GL_VERTEX_SHADER); 

 GLuint simulate_body_physics_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_body_physics_program_GL_FRAGMENT_SHADER, "could not create simulate_body_physics_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec3 deltax_dot;\nlayout(location = 1) out vec3 deltaomega;\nlayout(location = 2) out vec3 pseudo_x_dot;\nlayout(location = 3) out vec3 pseudo_omega;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform isampler3D materials;\nlayout(location = 2) uniform isampler3D body_materials;\nlayout(location = 3) uniform sampler3D body_forces;\nlayout(location = 4) uniform sampler3D body_shifts;\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    // ivec3 materials_origin;\n    // ivec3 size;\n    // vec3 x_cm;\n    // vec3 x;\n    // vec3 x_dot;\n    // vec4 orientation;\n    // vec3 omega;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nlayout(std430, binding = 0) buffer body_data\n{\n    body bodies[];\n};\n\nsmooth in vec2 uv;\n\nconst int chunk_size = 256;\n\nivec4 voxelFetch(isampler3D tex, ivec3 coord)\n{\n    return texelFetch(materials, coord, 0);\n}\n\nivec4 bodyVoxelFetch(int body_index, ivec3 coord)\n{\n    return texelFetch(body_materials, body_materials_origin+coord, 0);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\n#define N_MAX_COLLISION_POINTS 256\nvoid find_collision_points(out vec3 world_collision_points[N_MAX_COLLISION_POINTS], out ivec3 world_collision_coord[N_MAX_COLLISION_POINTS], out int n_collision_points)\n{\n    n_collision_points = 0;\n\n    //TODO: maybe use space filling curves\n    for(int test_z = 0; test_z < body_size.z; test_z+=1)\n        for(int test_y = 0; test_y < body_size.y; test_y+=1)\n            for(int test_x = 0; test_x < body_size.x; test_x+=1)\n            {\n\n                ivec3 body_coord = ivec3(test_x, test_y, test_z);\n                vec3 world_coord = apply_rotation(body_orientation, vec3(body_coord)+0.5-body_x_cm)+body_x;\n\n                vec4 body_voxel = texelFetch(body_materials, body_materials_origin+body_coord, 0);\n\n                // if(body_voxel.g == 0 && body_voxel.r > 0)\n                if(body_voxel.g == 0)\n                {\n                    ivec3 wvc = ivec3(world_coord); //world_voxel_coord\n                    ivec4 world_voxel = voxelFetch(materials, wvc);\n                    vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n                    // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n                    if(world_voxel.g <= 1)\n                    {\n                        world_collision_points[n_collision_points] = world_coord;\n                        world_collision_coord[n_collision_points] = wvc;\n                        n_collision_points++;\n                        if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                    }\n\n                    // for(int wz = 0; wz <= 1; wz++)\n                    //     for(int wy = 0; wy <= 1; wy++)\n                    //         for(int wx = 0; wx <= 1; wx++)\n                    //         {\n                    //             ivec3 wvc = ivec3(world_coord-0.5)+ivec3(wx,wy,wz); //world_voxel_coord\n                    //             ivec4 world_voxel = voxelFetch(materials, wvc);\n                    //             vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n                    //             // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n                    //             if(world_voxel.g <= 2)\n                    //             {\n                    //                 world_collision_points[n_collision_points] = world_coord;\n                    //                 world_collision_coord[n_collision_points] = wvc;\n                    //                 n_collision_points++;\n                    //                 if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                    //             }\n                    //         }\n                }\n\n                test_x += int(max(abs(body_voxel.g)-1, 0));\n            }\n}\n\nvoid main()\n{\n    int b = int(gl_FragCoord.y);\n    // int b = 0;\n\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    float m = bodies[b].m;\n    mat3 I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    mat3 invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n\n    deltax_dot = vec3(0,0,0);\n    deltaomega = vec3(0,0,0);\n\n    pseudo_x_dot = vec3(0,0,0);\n    pseudo_omega = vec3(0,0,0);\n\n    //gravity\n    deltax_dot.z += -0.1;\n\n    vec3 world_collision_points[N_MAX_COLLISION_POINTS];\n    ivec3 world_collision_coord[N_MAX_COLLISION_POINTS];\n    int n_collision_points = 0;\n\n    find_collision_points(world_collision_points, world_collision_coord, n_collision_points);\n\n    // if(n_collision_points > 0 && length(body_omega) < 0.01 && n_collision_points > 0 && length(body_x_dot) < 0.01)\n    // {\n    //     deltaomega = -0.05f*body_omega;\n    //     deltax_dot = -0.05f*body_x_dot;\n    //     // return;\n    // }\n\n    vec3 impulses[N_MAX_COLLISION_POINTS] = vec3[N_MAX_COLLISION_POINTS](0);\n\n    for(int i = 0; i < 6; i++)\n    {\n        vec3 x_dot = body_x_dot+deltax_dot;\n        vec3 omega = body_omega+deltaomega;\n\n        const int n_test_points = 5;\n        const int max_steps = 20;\n\n        int deepest_x;\n        int deepest_y;\n        int deepest_z;\n        int deepest_depth = 0;\n        bool point_found = false;\n\n        // float old_E = m*dot(x_dot, x_dot)+I*dot(omega, omega);\n\n        vec3 best_deltax_dot = vec3(0,0,0);\n        vec3 best_deltax = vec3(0,0,0);\n        vec3 best_r = vec3(0,0,0);\n        int best_cp = -1;\n        int n_collisions = 0;\n        float best_E = 2*(m*dot(x_dot, x_dot)+dot(I*omega, omega));\n\n        //TODO: build list of points to test that are non-empty and on the surface instead of checking all of them\n        //      maybe make it a linked list to minimize texture lookups\n        for(int cp = 0; cp < n_collision_points; cp++)\n        {\n            vec3 world_coord = world_collision_points[cp];\n            ivec3 wvc = world_collision_coord[cp]; //world_voxel_coord\n            ivec4 world_voxel = voxelFetch(materials, wvc);\n            vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n\n            const float COR = 0.2;\n            const float COF = 0.1;\n\n            vec3 world_gradient = vec3(\n                voxelFetch(materials, wvc+ivec3(1,0,0)).g-voxelFetch(materials, wvc+ivec3(-1,0,0)).g,\n                voxelFetch(materials, wvc+ivec3(0,1,0)).g-voxelFetch(materials, wvc+ivec3(0,-1,0)).g,\n                voxelFetch(materials, wvc+ivec3(0,0,1)).g-voxelFetch(materials, wvc+ivec3(0,0,-1)).g+0.001\n                );\n\n            //TODO: can probably reduce jitter by using more accurate collision_points, maybe add noise\n            vec3 normal = normalize(world_gradient);\n            // vec3 a = wvc-body_x;\n            vec3 a = world_coord-body_x;\n\n            float u = dot(x_dot+cross(omega, a), normal);\n            float K = 1.0+m*dot(cross(invI*cross(a, normal), a), normal);\n            vec3 test_deltax_dot = vec3(0,0,0);\n            // if(u < 0)\n            {\n                //normal force\n                test_deltax_dot = (-(1.0+COR)*u/K)*normal;\n                //friction\n                test_deltax_dot += -COF*(-(1.0+COR)*u/K)*(x_dot+cross(omega, a)-u*normal);\n            }\n            if(dot(test_deltax_dot+impulses[cp], normal) < 0) test_deltax_dot = vec3(0);\n\n            vec3 v = x_dot+cross(omega, a);\n\n            vec3 test_deltaomega = m*invI*cross(a, test_deltax_dot);\n            float E = (m*dot(x_dot+test_deltax_dot, x_dot+test_deltax_dot)\n                       +dot(I*(omega+test_deltaomega), omega+test_deltaomega)); //TODO: need to adjust I as rotation changes\n            if(E < best_E)\n            {\n                best_deltax_dot = test_deltax_dot;\n                // best_deltax = deltax;\n                best_r = a;\n                best_E = E;\n                best_cp = cp;\n            }\n\n            if(i == 0)\n            {\n                vec3 deltax = 0.01*max(-world_voxel.g-1, 0)*normal;\n                pseudo_x_dot += deltax;\n                pseudo_omega += m*invI*cross(best_r, deltax);\n            }\n        }\n\n        best_deltax_dot *= 0.9;\n\n        deltax_dot += best_deltax_dot;\n        deltaomega += m*invI*cross(best_r, best_deltax_dot);\n\n        impulses[best_cp] += deltax_dot;\n\n        // pseudo_x_dot = best_deltax;\n        // pseudo_omega = (m/I)*cross(best_r, best_deltax);\n    }\n\n    // if(dot(body_x_dot, body_x_dot+deltax_dot) < 0)\n    // {\n    //     deltax_dot *= -length(body_x_dot)/dot(body_x_dot, normalize(deltax_dot));\n    // }\n\n    // if(dot(body_omega, body_omega+deltaomega) < 0)\n    // {\n    //     deltaomega *= -length(body_omega)/dot(body_omega, normalize(deltaomega));\n    // }\n}\n"; glShaderSource(simulate_body_physics_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_body_physics_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_body_physics_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_physics_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_physics_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_body_physics_program, simulate_body_physics_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_body_physics_program);glDetachShader(simulate_body_physics_program, simulate_body_physics_program_GL_VERTEX_SHADER); glDeleteShader(simulate_body_physics_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_body_physics_program, simulate_body_physics_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_body_physics_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_body_physics_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_physics_program, available_memory, 0, info_log); log_error(info_log); }simulate_chunk_program = glCreateProgram(); assert(simulate_chunk_program, "could not create simulate_chunk_program, GL error", glGetError());
 GLuint simulate_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_chunk_program_GL_VERTEX_SHADER, "could not create simulate_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 r;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 3) uniform usampler3D active_regions_in;\nlayout(location = 5) uniform writeonly uimage3D occupied_regions_out;\n\nout vec3 p;\n\nvoid main()\n{\n    int z = layer/16;\n    int y = int(X.y);\n    int x = int(X.x);\n\n    p=vec3(16*x,16*y,layer);\n\n    gl_Position = vec4(-2,-2,0,1);\n\n    float scale = 2.0f/32.0f;\n\n    uint region_active = texelFetch(active_regions_in, ivec3(x, y, z), 0).r;\n    if(region_active != 0)\n    {\n        if(gl_VertexID == 0 && layer%16 == 0) imageStore(occupied_regions_out, ivec3(x,y,z), uvec4(0,0,0,0));\n        gl_Position.xy = -1.0f+scale*(r+X);\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_chunk_program, simulate_chunk_program_GL_VERTEX_SHADER); 

 GLuint simulate_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_chunk_program_GL_FRAGMENT_SHADER, "could not create simulate_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec4 frag_color;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int frame_number;\nlayout(location = 2) uniform isampler3D materials;\nlayout(location = 4) uniform writeonly uimage3D active_regions_out;\nlayout(location = 5) uniform writeonly uimage3D occupied_regions_out;\nlayout(location = 6) uniform int update_cells;\n\nin vec3 p;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    float scale = 1.0/chunk_size;\n    // ivec2 pos = ivec2(chunk_size*uv);\n    // ivec2 pos = ivec2(gl_FragCoord.xy);\n    ivec3 pos = ivec3(p);\n    ivec3 cell_p;\n    cell_p.xy = ivec2(gl_FragCoord.xy)%16;\n    cell_p.z = pos.z%16;\n    pos.xy += cell_p.xy;\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    uint rot = rand(rand(rand(frame_number)))%4;\n    int i = 0;\n    ivec2 dir = ivec2(((rot&1)*(2-rot)), (1-(rot&1))*(1-rot));\n\n    ivec4 c  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z),0);\n    ivec4 u  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z+1),0);\n    ivec4 d  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z-1),0);\n    ivec4 r  = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z),0);\n    ivec4 l  = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z),0);\n    ivec4 dr = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z-1),0);\n    ivec4 ur = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z+1),0);\n\n    ivec4 f  = texelFetch(materials, ivec3(pos.x-dir.y, pos.y+dir.x, pos.z),0);\n    ivec4 b  = texelFetch(materials, ivec3(pos.x+dir.y, pos.y-dir.x, pos.z),0);\n\n    ivec4 ul = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z+1),0);\n    ivec4 ll = texelFetch(materials, ivec3(pos.x-2*dir.x, pos.y-2*dir.y, pos.z),0);\n    ivec4 dl = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z-1),0);\n\n    frag_color = c;\n    if(update_cells == 1)\n    {\n        if(c.r == 0)\n        {\n            if(u.r > 0 && u.r != 3) frag_color = u;\n            else if(l.r > 0 && ul.r > 0 && u.r != 3 && ul.r != 3) frag_color = ul;\n            else if(dl.r > 0 && d.r > 0 && l.r > 1 && ll.r > 0 && u.r != 3 && ul.r != 3 && l.r != 3) frag_color = l;\n\n            // if(u.r == 0 && ul.r == 0 && dl.r > 0 && d.r > 0 && l.r > 0) frag_color = l;\n            // else if(u.r == 0 && l.r > 0) frag_color = ul;\n            // else if(u.r > 0) frag_color = u;\n        }\n        else if(c.r != 3)\n        {\n            bool fall_allowed = (pos.z > 0 && (d.r == 0 || (dr.r == 0 && r.r == 0)));\n            bool flow_allowed = (pos.z > 0 && r.r == 0 && ur.r == 0 && u.r == 0 && c.r > 1 && l.r > 0);\n            if(fall_allowed || flow_allowed) frag_color.r = 0;\n        }\n    }\n\n    const int max_depth = 16;\n    if(c.r > 0)\n    {\n        if(l.r == 0 ||\n           r.r == 0 ||\n           u.r == 0 ||\n           d.r == 0 ||\n           f.r == 0 ||\n           b.r == 0) frag_color.g = 0;\n        else\n        {\n            frag_color.g = -max_depth;\n            frag_color.g = max(frag_color.g, l.g-1);\n            frag_color.g = max(frag_color.g, r.g-1);\n            frag_color.g = max(frag_color.g, u.g-1);\n            frag_color.g = max(frag_color.g, d.g-1);\n            frag_color.g = max(frag_color.g, f.g-1);\n            frag_color.g = max(frag_color.g, b.g-1);\n        }\n\n        frag_color.b = c.b/2;\n        if(frag_color.r == 3) frag_color.b = 1000;\n        // if(frag_color.r == 1) frag_color.b = 100;\n        // frag_color.b = 0;\n    }\n    else\n    {\n        frag_color.g = max_depth;\n        frag_color.g = min(frag_color.g, l.g+1);\n        frag_color.g = min(frag_color.g, r.g+1);\n        frag_color.g = min(frag_color.g, u.g+1);\n        frag_color.g = min(frag_color.g, d.g+1);\n        frag_color.g = min(frag_color.g, f.g+1);\n        frag_color.g = min(frag_color.g, b.g+1);\n\n        // // frag_color.b = 1+texelFetch(materials, ivec3(pos.x, pos.y, layer), 0).b;\n        // float brightness = 100.0;\n        // brightness += brightness_curve(l.b);\n        // brightness += brightness_curve(r.b);\n        // brightness += brightness_curve(u.b);\n        // brightness += brightness_curve(d.b);\n        // brightness += brightness_curve(f.b);\n        // brightness += brightness_curve(b.b);\n        // brightness *= 1.0/6.0;\n        // frag_color.b = int(inverse_brightness_curve(brightness));\n    }\n    frag_color.g = clamp(frag_color.g,-max_depth,max_depth);\n\n    // bool changed = c.r != frag_color.r || c.g != frag_color.g || c.b != frag_color.b;\n    bool changed = c.r != frag_color.r || c.g != frag_color.g;\n    if(changed)\n    {\n        imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.x==15) imageStore(active_regions_out, ivec3(pos.x/16+1, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.x== 0) imageStore(active_regions_out, ivec3(pos.x/16-1, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.y==15) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16+1, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.y== 0) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16-1, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.z==15) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16+1), uvec4(1,0,0,0));\n        if(cell_p.z== 0) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16-1), uvec4(1,0,0,0));\n    }\n\n    if(c.r > 0) imageStore(occupied_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n}\n"; glShaderSource(simulate_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_chunk_program, simulate_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_chunk_program);glDetachShader(simulate_chunk_program, simulate_chunk_program_GL_VERTEX_SHADER); glDeleteShader(simulate_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_chunk_program, simulate_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_chunk_program, available_memory, 0, info_log); log_error(info_log); }simulate_particles_program = glCreateProgram(); assert(simulate_particles_program, "could not create simulate_particles_program, GL error", glGetError());
 GLuint simulate_particles_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_particles_program_GL_VERTEX_SHADER, "could not create simulate_particles_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5*x.xy+0.5;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_particles_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_particles_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_particles_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_particles_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_particles_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_particles_program, simulate_particles_program_GL_VERTEX_SHADER); 

 GLuint simulate_particles_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_particles_program_GL_FRAGMENT_SHADER, "could not create simulate_particles_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec3 new_x;\nlayout(location = 1) out vec3 new_x_dot;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform isampler3D materials;\nlayout(location = 2) uniform sampler2D old_x;\nlayout(location = 3) uniform sampler2D old_x_dot;\n\nsmooth in vec2 uv;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\nconst int chunk_size = 256;\n\nivec4 voxelFetch(isampler3D tex, ivec3 coord)\n{\n    return texelFetch(materials, coord, 0);\n}\n\nvoid main()\n{\n    float scale = 1.0/chunk_size;\n    vec3 x = texture(old_x, vec2(0, 0)).rgb;\n    vec3 x_dot = texture(old_x_dot, vec2(0, 0)).rgb;\n    float epsilon = 0.001;\n    // float epsilon = 0.02;\n\n    vec3 x_ddot = vec3(0,0,-0.08);\n    x_dot += x_ddot;\n\n    float remaining_dist = length(x_dot);\n    if(remaining_dist > epsilon)\n    {\n        x += x_dot;\n        if(x.z < epsilon && x_dot.z < 0)\n        {\n            x.z = epsilon;\n            x_dot.z = 0;\n            // x_dot *= 0.99;\n        }\n        int max_iterations = 50;\n        int i = 0;\n        // while(voxelFetch(materials, ivec3(x)).r == 1 || voxelFetch(materials, ivec3(x)).r == 3)\n        while(voxelFetch(materials, ivec3(x)).r != 0)\n        {\n            vec3 gradient = vec3(\n                voxelFetch(materials, ivec3(x+vec3(1,0,0))).g-voxelFetch(materials, ivec3(x+vec3(-1,0,0))).g,\n                voxelFetch(materials, ivec3(x+vec3(0,1,0))).g-voxelFetch(materials, ivec3(x+vec3(0,-1,0))).g,\n                voxelFetch(materials, ivec3(x+vec3(0,0,1))).g-voxelFetch(materials, ivec3(x+vec3(0,0,-1))).g+0.001f\n                );\n            gradient = normalize(gradient);\n            x += 0.05*gradient;\n            float rej = dot(x_dot, gradient);\n            x_dot -= gradient*rej;\n            // x_dot *= 0.99;\n            // x_dot += 1.0*gradient;\n            if(++i > max_iterations) break;\n\n            // x.z += 0.01;\n            // x.z = ceil(x.z);\n        }\n        if(voxelFetch(materials, ivec3(x)).r == 2)\n        {\n            x_dot *= 0.95;\n        }\n\n        // if(hit_dir == 0) x.x -= epsilon*sign.x;\n        // if(hit_dir == 1) x.y -= epsilon*sign.y;\n        // if(hit_dir == 2) x.z -= epsilon*sign.z;\n    }\n\n    new_x = x;\n    new_x_dot = x_dot;\n}\n"; glShaderSource(simulate_particles_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_particles_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_particles_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_particles_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_particles_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_particles_program, simulate_particles_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_particles_program);glDetachShader(simulate_particles_program, simulate_particles_program_GL_VERTEX_SHADER); glDeleteShader(simulate_particles_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_particles_program, simulate_particles_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_particles_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_particles_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_particles_program, available_memory, 0, info_log); log_error(info_log); }update_lightmap_program = glCreateProgram(); assert(update_lightmap_program, "could not create update_lightmap_program, GL error", glGetError());
 GLuint update_lightmap_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(update_lightmap_program_GL_VERTEX_SHADER, "could not create update_lightmap_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 x;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 3) uniform sampler2D lightprobe_color;\nlayout(location = 4) uniform sampler2D lightprobe_depth;\nlayout(location = 5) uniform sampler2D lightprobe_x;\nlayout(location = 6) uniform sampler2D blue_noise_texture;\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 4\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth out vec2 sample_oct;\n\nvoid main()\n{\n    // vec2 sample_coord = blue_noise(vec2(gl_InstanceID*PHI/256.0f, 0)).xy;\n    // gl_Position.xy = 2.0f*sample_coord-1.0f;\n    // gl_Position.z = 0.0f;\n\n    // sample_oct = 2.0f*fract(gl_Position.xy*vec2(256, 128))-1.0f;\n\n    vec2 scale = 2.0f/vec2(lightprobes_w, lightprobes_h);\n    vec2 scale2 = (0.5f*scale*lightprobe_resolution)/lightprobe_padded_resolution;\n\n    gl_Position.xy = scale*(X+0.5)-1+scale2*x;\n    gl_Position.z = 0.0f;\n    gl_Position.w = 1.0f;\n    sample_oct = x;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(update_lightmap_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(update_lightmap_program_GL_VERTEX_SHADER); glGetShaderiv(update_lightmap_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_lightmap_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_lightmap_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(update_lightmap_program, update_lightmap_program_GL_VERTEX_SHADER); 

 GLuint update_lightmap_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(update_lightmap_program_GL_FRAGMENT_SHADER, "could not create update_lightmap_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec4 depth;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform isampler3D materials;\nlayout(location = 2) uniform usampler3D occupied_regions;\nlayout(location = 3) uniform sampler2D lightprobe_color;\nlayout(location = 4) uniform sampler2D lightprobe_depth;\nlayout(location = 5) uniform sampler2D lightprobe_x;\nlayout(location = 6) uniform sampler2D blue_noise_texture;\n\nivec3 size = ivec3(512);\nivec3 origin = ivec3(0);\n\nbool coarse_cast_ray(vec3 ray_dir, vec3 ray_origin, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal)\n{\n    float step_size = 1.0;\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    const int max_iterations = 8;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n        while(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return false;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return false;\n            }\n        }\n\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            normal = normalize(gradient);\n\n            hit_cell = ipos;\n            return true;\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            hit_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        pos += ray_dir*step_size;\n        hit_dist += step_size;\n        step_size += 0.25f*step_size;\n        ipos = ivec3(floor(pos));\n\n        // vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        // vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        // float min_dist = dot(dist, min_dir);\n        // pos += min_dist*ray_dir;\n        // ipos += ivec3(min_dir*ray_sign);\n        // hit_dist += min_dist;\n        // hit_dir = min_dir;\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\nint n_texture_reads = 0;\n\nbool cast_ray(vec3 ray_dir, vec3 ray_origin, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int max_iterations = 200;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n        while(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return false;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return false;\n            }\n        }\n\n        n_texture_reads++;\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            normal = normalize(gradient);\n\n            hit_cell = ipos;\n            return true;\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            hit_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        float min_dist = dot(dist, min_dir);\n        pos += min_dist*ray_dir;\n        ipos += ivec3(min_dir*ray_sign);\n        hit_dist += min_dist;\n        hit_dir = min_dir;\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 4\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 sample_oct;\n\nlayout(pixel_center_integer) in vec4 gl_FragCoord;\n\nvoid main()\n{\n    // vec2 sample_oct = 2*fract((gl_FragCoord.xy-1)*(1.0f/lightprobe_padded_resolution)\n    //                           +(blue_noise(gl_FragCoord.xy/256.0).xy)*(1.0f/lightprobe_resolution))-1;\n    // vec2 sample_oct = 2*fract((gl_FragCoord.xy+0.5f)*(1.0f/lightprobe_resolution))-1;\n\n    //really all this ray casting could happen in the vertex shader, not sure if there's an advantage either way\n    ivec2 probe_coord = ivec2(gl_FragCoord.xy/lightprobe_padded_resolution);\n    int probe_index = probe_coord.x+probe_coord.y*lightprobes_w;\n    ivec3 probe_pos = ivec3(probe_index%lightprobes_per_axis, (probe_index/lightprobes_per_axis)%lightprobes_per_axis, probe_index/(lightprobes_per_axis*lightprobes_per_axis));\n\n    vec3 ray_dir = oct_to_vec(sample_oct+(blue_noise(gl_FragCoord.xy/256.0).xy-0.5f)*(1.0/lightprobe_resolution));\n    vec3 pos = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n    // vec3 pos = (vec3(probe_pos)+blue_noise(gl_FragCoord.xy/256.0f+vec2(0.8f,0.2f)).xyz)*lightprobe_spacing;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    bool hit = coarse_cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n    // bool hit = cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n\n    const float decay_fraction = 0.01;\n\n    if(hit)\n    {\n        ivec4 voxel = texelFetch(materials, hit_cell, 0);\n\n        vec3 emission = vec3(0.001f);\n        if(voxel.r == 2)\n        {\n            // emission = vec3(0.4,0.4,0.8);\n            emission = vec3(0.8,0.2,0.2)*100;\n        }\n        if(voxel.r == 1)\n        {\n            emission = vec3(0.54,0.44,0.21);\n        }\n        // if(voxel.r == 3)\n        // {\n        //     emission = vec3(0.5,0.125,0.5);\n        // }\n\n\n        vec3 reflectivity = vec3(0.5, 0.5, 0.5);\n        float roughness = 0.0;\n        if(voxel.r == 1)\n        {\n            reflectivity = vec3(0.54,0.44,0.21);\n            roughness = 0.9;\n        }\n        else if(voxel.r == 3)\n        {\n            reflectivity = vec3(0.5,0.5,1.0);\n            roughness = 0.5;\n        }\n        else\n        {\n            reflectivity = vec3(0.1,0.1,0.2);\n            roughness = 0.1;\n        }\n\n        color.rgb = vec3(0);\n        // color.rgb = pos/512.0;\n        color.rgb += emission;\n\n        // float total_weight = 0.0;\n\n        vec3 reflection_dir = ray_dir-(2*dot(ray_dir, normal))*normal;\n        reflection_dir += roughness*blue_noise(gl_FragCoord.xy/256.0f+vec2(0.4f,0.6f)).xyz;\n        reflection_dir = normalize(reflection_dir);\n\n        vec2 sample_depth;\n        color.rgb += reflectivity*sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n    }\n    else\n    {\n        vec2 sample_depth;\n        vec3 sample_color = sample_lightprobe_color(hit_pos, ray_dir, vec_to_oct(ray_dir), sample_depth);\n        // hit_dist += sample_depth.r;\n        color.rgb = sample_color;\n    }\n\n    depth.r = clamp(hit_dist, 0, 1*lightprobe_spacing);\n    depth.g = sq(depth.r);\n\n    color.a = decay_fraction;\n    depth.a = decay_fraction;\n    //TODO: this arbitrarily gives later samples in the same frame more weight\n\n    // depth.rg = vec2(512.0,sq(512.0));\n    // color.rgb = 0.5+0.5*ray_dir;\n    // color.rgb = clamp(color.rgb, 0.0f, 1.0f);\n    color.rgb = max(color.rgb, 0);\n}\n"; glShaderSource(update_lightmap_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(update_lightmap_program_GL_FRAGMENT_SHADER); glGetShaderiv(update_lightmap_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_lightmap_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_lightmap_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(update_lightmap_program, update_lightmap_program_GL_FRAGMENT_SHADER); 
glLinkProgram(update_lightmap_program);glDetachShader(update_lightmap_program, update_lightmap_program_GL_VERTEX_SHADER); glDeleteShader(update_lightmap_program_GL_VERTEX_SHADER); 
glDetachShader(update_lightmap_program, update_lightmap_program_GL_FRAGMENT_SHADER); glDeleteShader(update_lightmap_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(update_lightmap_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(update_lightmap_program, available_memory, 0, info_log); log_error(info_log); }unreserve_block(manager);}