
GLuint cast_probes_program;
GLuint circle_program;
GLuint debug_text_program;
GLuint denoise_program;
GLuint draw_beams_program;
GLuint draw_lightprobes_program;
GLuint draw_particles_program;
GLuint draw_text_program;
GLuint fullscreen_texture_program;
GLuint get_voxel_data_program;
GLuint mipmap_chunk_program;
GLuint move_lightprobes_program;
GLuint pad_lightprobes_program;
GLuint render_depth_prepass_program;
GLuint render_editor_voxels_program;
GLuint render_prepass_program;
GLuint render_world_program;
GLuint simulate_body_program;
GLuint simulate_body_physics_program;
GLuint simulate_chunk_atomic_program;
GLuint simulate_particles_program;
GLuint sync_joint_voxels_program;
GLuint update_beams_program;
GLuint update_joint_fragments_program;
GLuint update_lightprobe_color_program;
GLuint update_lightprobe_depth_program;void gl_init_programs(memory_manager* manager){int error; size_t available_memory = current_block_unused(manager); byte* free_memory = reserve_block(manager, available_memory);cast_probes_program = glCreateProgram(); assert(cast_probes_program, "could not create cast_probes_program, GL error", glGetError());
 GLuint cast_probes_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(cast_probes_program_GL_COMPUTE_SHADER, "could not create cast_probes_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_visual_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform usampler3D occupied_regions;\nlayout(location = 4) uniform usampler3D active_regions;\nlayout(location = 5) uniform sampler2D lightprobe_color;\nlayout(location = 6) uniform sampler2D lightprobe_depth;\nlayout(location = 7) uniform sampler2D lightprobe_x;\nlayout(location = 8) uniform sampler2D blue_noise_texture;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\n// vec3 quasinoise_3(int i)\n// {\n//     float g = 1.0/PHI3;\n//     return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n//     // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n// }\n\nvec2 quasinoise_2(int i)\n{\n    float g = 1.0/PHI2;\n    return fract(0.5+(i%1000)*vec2(g, sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\nvec2 halton(int i)\n{\n    vec2 s = vec2(i);\n    vec2 base = vec2(2,3);\n    vec4 a = vec4(1,1,0,0);\n    while(all(greaterThan(s, vec2(0))))\n    {\n        a.xy = a.xy/base;\n        a.zw += a.xy*mod(vec2(s), base);\n        s = floor(s/base);\n    }\n    return a.zw;\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    // return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n    float b = 1-lh;\n    return F0-(vec3(1)-F0)*sq(sq(b))*b;\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    // return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, uint medium, bool use_depth, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < 0 || ipos.y < 0 || ipos.z < 0\n           || ipos.x >= size.x || ipos.y >= size.y || ipos.z >= size.z)\n        {\n            return false;\n        }\n\n        #ifdef occupied_regions\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(pos);\n        }\n        else\n        #endif\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != medium)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                if(hit_dir == vec3(0,0,0))\n                {\n                    hit_dir = abs(pos-ipos+0.5);\n                    hit_dir = step(hit_dir.zxy, hit_dir.xyz)*step(hit_dir.yzx, hit_dir.xyz);\n                }\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            #ifndef RAY_CAST_IGNORE_DEPTH\n            if(use_depth)\n            {\n                int depth = depth(voxel);\n                if(depth >= 3\n                   // #ifdef ACTIVE_REGIONS\n                   // && texelFetch(active_regions, ipos>>4, 0).r == 0\n                   // #endif //ACTIVE_REGIONS\n                    )\n                {\n                    float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                    pos += ray_dir*skip_dist;\n                    hit_dist += skip_dist;\n                    ipos = ivec3(pos);\n                }\n            }\n            #endif\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    // pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    ivec3 base_probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing);\n\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = base_probe_pos+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                probe_color.a = 1;\n\n                float normal_bias = 4.0;\n                vec3 dist = pos+(normal)*normal_bias-probe_x; //NOTE: Majercjk adds 3*view dir to the normal here\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 dir_oct = vec_to_oct(dir);\n                vec2 depth_sample_coord = vec2(lightprobe_depth_padded_resolution*probe_coord+1.0)+lightprobe_depth_resolution*clamp(0.5f*dir_oct+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_depth_resolution_x, 1.0f/lightprobe_depth_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                float weight = 1.0;\n\n                vec3 true_dir = normalize(probe_x-pos); //direction without bias\n                weight *= sq(max(0.0001, 0.5*dot(normal, true_dir)+0.5))+0.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                //Chebychev's inequality, upper bound for an arbitrary distribution\n                if(r > probe_depth.r)\n                {\n                    float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                    float cheb_weight = variance/max(variance+sq(r-probe_depth.r), 0.001);\n                    cheb_weight = max(sq(cheb_weight)*cheb_weight, 0);\n                    weight *= cheb_weight;\n                }\n\n                // //This assumes Gaussian distribution\n                // float variance = abs(probe_depth.g-sq(probe_depth.r));\n                // float x = (probe_depth.r-r)*inversesqrt(variance);\n                // weight *= cdf(x);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n#ifndef PROBE_RAY_DATA_BINDING\n#define PROBE_RAY_DATA_BINDING 0\n#endif\n\nstruct probe_ray\n{\n    vec3 rel_hit_pos;\n    vec3 hit_color;\n};\n\nlayout(std430, binding = PROBE_RAY_DATA_BINDING) buffer probe_ray_data\n{\n    probe_ray probe_rays[];\n};\n\n\nlayout(local_size_x = rays_per_lightprobe, local_size_y = 1, local_size_z = 1) in;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nvoid main()\n{\n    ivec2 probe_coord = ivec2(gl_WorkGroupID.xy);\n    int probe_i = probe_coord.x+lightprobes_w*probe_coord.y;\n    int sample_i = int(gl_LocalInvocationID.x);\n    int ray_i = probe_i*rays_per_lightprobe+sample_i;\n\n    ivec2 texel_coord = lightprobe_padded_resolution*probe_coord+1;\n    ivec2 depth_texel_coord = lightprobe_depth_padded_resolution*probe_coord+1;\n\n    // vec3 ray_dir = quasinoise_3(probe_id+lightprobes_w*lightprobes_h*(frame_number%100))-0.5;\n    // vec3 ray_dir = blue_noise_3(vec2(probe_coord)/256.0)-0.5;\n    // vec2 Omega = blue_noise_2(vec2(probe_coord)/256.0+sample_i*vec2(0.86, 0.24));\n    // vec2 Omega = halton(frame_number*n_samples+sample_i);\n    vec2 Omega = quasinoise_2(frame_number*rays_per_lightprobe+sample_i);\n    float cosphi = cos((2*pi)*Omega.x);\n    float sinphi = sin((2*pi)*Omega.x);\n    float costheta = 2*Omega.y-1;\n    float sintheta = sqrt(max(0, 1.0-sq(costheta)));\n    vec3 ray_dir = vec3(sintheta*cosphi, sintheta*sinphi, costheta);\n    ray_dir = normalize(ray_dir);\n    vec3 original_ray_dir = ray_dir;\n\n    vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    ivec3 origin = ivec3(0);\n    ivec3 size = ivec3(512);\n    uvec4 voxel;\n    uint medium = texelFetch(materials, ivec3(probe_x), 0).r;\n    if(opacity(medium) == 1) medium = 0;\n    bool hit = cast_ray(materials, ray_dir, probe_x, size, origin, medium, true, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 200);\n\n    vec3 color = vec3(0);\n\n    float first_hit_dist = hit_dist;\n\n    if(hit)\n    {\n        uvec4 voxel = texelFetch(materials, hit_cell, 0);\n        uint material_id = voxel.r;\n\n        vec4 transmission = vec4(1);\n        vec4 transparent_color = vec4(0);\n        // for(int i = 0; i < 5; i++)\n        // {\n        //     if(opacity(mat(voxel)) >= 1) break;\n        //     vec3 ray_pos = hit_pos;\n        //     if(ivec3(ray_pos) != hit_cell) ray_pos += 0.001*ray_dir;\n        //     float c = dot(ray_dir, normal);\n        //     float r = refractive_index(medium)/refractive_index(mat(voxel));\n        //     float square = 1.0-sq(r)*(1.0-sq(c));\n        //     if(square > 0) ray_dir = r*ray_dir+(-r*c+sign(c)*sqrt(square))*normal;\n        //     else ray_dir = ray_dir - 2*c*normal; //total internal reflection\n        //     // ray_dir = normalize(ray_dir);\n        //     medium = mat(voxel);\n        //     bool hit = cast_ray(materials, ray_dir, ray_pos, size, origin, medium, true, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 24);\n\n        //     if(hit)\n        //     {\n        //         transmission *= exp(-opacity(mat(medium))*hit_dist);\n        //     }\n        //     else\n        //     {\n        //         break;\n        //     }\n\n        //     if(dot(transmission, transmission) < 0.001) break;\n\n        //     uint material_id = voxel.r;\n        //     float roughness = get_roughness(material_id);\n        //     vec3 emission = get_emission(material_id);\n\n        //     // transparent_color.rgb += -(emission)*dot(normal, ray_dir);\n        //     transparent_color.rgb += emission;\n\n        //     //TODO: actual blackbody color\n        //     transparent_color.rgb += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n        //     transparent_color.rgb += vec3(0.7,0.3,1.0)*clamp((1.0/15.0)*(float(volt(voxel))), 0.0, 1.0);\n\n        //     vec3 reflection_dir = normal;\n        //     vec2 sample_depth;\n        //     transparent_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)\n        //         *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        //     transparent_color *= transmission;\n        // }\n\n        color += transparent_color.rgb;\n\n        float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        emission += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n        // color += -(emission)*dot(normal, ray_dir);\n        color += emission;\n\n        // float total_weight = 0.0;\n\n        // vec3 reflection_normal = normal+0.5*roughness*(blue_noise(gl_FragCoord.xy/256.0+vec2(0.82,0.34)).xyz-0.5f);\n        vec3 reflection_normal = normal;\n        reflection_normal = normalize(reflection_normal);\n        // vec3 reflection_dir = ray_dir-(2*dot(ray_dir, reflection_normal))*reflection_normal;\n        vec3 reflection_dir = normal;\n        // reflection_dir += roughness*blue_noise(gl_FragCoord.xy/256.0f+vec2(0.4f,0.6f)).xyz;\n\n        vec2 sample_depth;\n        color += fr(material_id, reflection_dir, -ray_dir, normal)*sample_lightprobe_color(hit_pos, normal, vec_to_oct(normal), sample_depth);\n    }\n    else\n    {\n        vec2 sample_depth;\n        vec3 sample_color = sample_lightprobe_color(hit_pos, ray_dir, vec_to_oct(ray_dir), sample_depth);\n        first_hit_dist += sample_depth.r;\n        color.rgb = sample_color;\n    }\n\n    // color = clamp(color, 0, 1);\n    color = max(color, 0);\n\n    probe_rays[ray_i].rel_hit_pos = first_hit_dist*original_ray_dir;\n    probe_rays[ray_i].hit_color = color;\n}\n"; glShaderSource(cast_probes_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(cast_probes_program_GL_COMPUTE_SHADER); glGetShaderiv(cast_probes_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(cast_probes_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile cast_probes_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(cast_probes_program, cast_probes_program_GL_COMPUTE_SHADER); 
glLinkProgram(cast_probes_program);glDetachShader(cast_probes_program, cast_probes_program_GL_COMPUTE_SHADER); glDeleteShader(cast_probes_program_GL_COMPUTE_SHADER); 
glGetProgramiv(cast_probes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(cast_probes_program, available_memory, 0, info_log); log_error(info_log); }circle_program = glCreateProgram(); assert(circle_program, "could not create circle_program, GL error", glGetError());
 GLuint circle_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(circle_program_GL_VERTEX_SHADER, "could not create circle_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\nlayout(location = 1) in vec3 X;\nlayout(location = 2) in float r;\nlayout(location = 3) in vec4 c;\n\nsmooth out vec4 color;\nsmooth out vec2 uv;\nsmooth out float radius;\n\nlayout(location = 0) uniform mat4 t;\n\nvoid main()\n{\n    gl_Position.xyz = (x*r+X);\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    uv = x.xy*r;\n    radius = r;\n    color = c;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_VERTEX_SHADER); glGetShaderiv(circle_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_VERTEX_SHADER); 

 GLuint circle_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(circle_program_GL_FRAGMENT_SHADER, "could not create circle_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform float smoothness;\n\nsmooth in vec4 color;\nsmooth in vec2 uv;\nsmooth in float radius;\n\nvoid main()\n{\n    frag_color = color;\n    float alpha = smoothstep(-radius, -radius+smoothness, -length(uv));\n    frag_color.a *= alpha;\n    gl_FragDepth = gl_FragCoord.z*alpha;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_FRAGMENT_SHADER); glGetShaderiv(circle_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); 
glLinkProgram(circle_program);glDetachShader(circle_program, circle_program_GL_VERTEX_SHADER); glDeleteShader(circle_program_GL_VERTEX_SHADER); 
glDetachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); glDeleteShader(circle_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(circle_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(circle_program, available_memory, 0, info_log); log_error(info_log); }debug_text_program = glCreateProgram(); assert(debug_text_program, "could not create debug_text_program, GL error", glGetError());
 GLuint debug_text_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(debug_text_program_GL_VERTEX_SHADER, "could not create debug_text_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\nlayout(location = 1) in vec4 c;\n\nsmooth out vec4 color;\n\nvoid main()\n{\n    gl_Position.xyz = 5*x/vec3(1080, 720, 1);\n    gl_Position.y = -gl_Position.y;\n    gl_Position.w = 1.0;\n    color = vec4(1);\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(debug_text_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(debug_text_program_GL_VERTEX_SHADER); glGetShaderiv(debug_text_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(debug_text_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile debug_text_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(debug_text_program, debug_text_program_GL_VERTEX_SHADER); 

 GLuint debug_text_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(debug_text_program_GL_FRAGMENT_SHADER, "could not create debug_text_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nsmooth in vec4 color;\n\nvoid main()\n{\n    frag_color = color;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(debug_text_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(debug_text_program_GL_FRAGMENT_SHADER); glGetShaderiv(debug_text_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(debug_text_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile debug_text_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(debug_text_program, debug_text_program_GL_FRAGMENT_SHADER); 
glLinkProgram(debug_text_program);glDetachShader(debug_text_program, debug_text_program_GL_VERTEX_SHADER); glDeleteShader(debug_text_program_GL_VERTEX_SHADER); 
glDetachShader(debug_text_program, debug_text_program_GL_FRAGMENT_SHADER); glDeleteShader(debug_text_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(debug_text_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(debug_text_program, available_memory, 0, info_log); log_error(info_log); }denoise_program = glCreateProgram(); assert(denoise_program, "could not create denoise_program, GL error", glGetError());
 GLuint denoise_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(denoise_program_GL_VERTEX_SHADER, "could not create denoise_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(denoise_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(denoise_program_GL_VERTEX_SHADER); glGetShaderiv(denoise_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(denoise_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile denoise_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(denoise_program, denoise_program_GL_VERTEX_SHADER); 

 GLuint denoise_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(denoise_program_GL_FRAGMENT_SHADER, "could not create denoise_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 0) uniform sampler2D color;\nlayout(location = 1) uniform sampler2D depth;\nlayout(location = 2) uniform sampler2D normal;\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n\n    ivec2 d = ivec2(1,0);\n    vec2 p = 0.5f*screen_pos+0.5f;\n    int lod = 0;\n    ivec2 ip = ivec2(pow(0.5f, lod)*gl_FragCoord.xy);\n    // float laplacian =\n    //     texelFetch(depth, ip-d.yx, lod).r+texelFetch(depth, ip+d.yx, lod).r\n    //     +texelFetch(depth, ip-d.xy, lod).r+texelFetch(depth, ip+d.xy, lod).r\n    //     -4.0f*texelFetch(depth, ip, lod).r;\n    // frag_color.rgb = vec3(100*laplacian.r);\n    // frag_color.rgb = textureLod(color, p, clamp(4.0f-1000.0f*laplacian, 0, 8)).rgb;\n\n    float center_depth = texelFetch(depth, ip, 0).r;\n    vec3 center_normal = texelFetch(normal, ip, 0).rgb;\n    float weight = 0.0f;\n    frag_color.rgb = vec3(0);\n    int radius = 3;\n    for(int dx = -radius; dx <= radius; dx++)\n        for(int dy = -radius; dy <= radius; dy++)\n            // if(abs(1.0-texelFetch(depth, ip+ivec2(dx,dy), 0).r/center_depth) < 0.01)\n            if(length(texelFetch(normal, ip+ivec2(dx,dy), 0).rgb-center_normal) < 0.01)\n            {\n                // float w = exp(-0.5*(sq(dx)+sq(dy)));\n                float w = 1.0;\n                frag_color.rgb += w*texelFetch(color, ip+ivec2(dx,dy), 0).rgb;\n                weight += w;\n            }\n\n    frag_color.rgb *= 1.0f/weight;\n    frag_color.a = 1.0f;\n}\n"; glShaderSource(denoise_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(denoise_program_GL_FRAGMENT_SHADER); glGetShaderiv(denoise_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(denoise_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile denoise_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(denoise_program, denoise_program_GL_FRAGMENT_SHADER); 
glLinkProgram(denoise_program);glDetachShader(denoise_program, denoise_program_GL_VERTEX_SHADER); glDeleteShader(denoise_program_GL_VERTEX_SHADER); 
glDetachShader(denoise_program, denoise_program_GL_FRAGMENT_SHADER); glDeleteShader(denoise_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(denoise_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(denoise_program, available_memory, 0, info_log); log_error(info_log); }draw_beams_program = glCreateProgram(); assert(draw_beams_program, "could not create draw_beams_program, GL error", glGetError());
 GLuint draw_beams_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_beams_program_GL_VERTEX_SHADER, "could not create draw_beams_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec2 x;\n\nlayout(location = 0) uniform mat4 t;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform int n_beams;\n\n#ifndef BEAM_DATA_BINDING\n#define BEAM_DATA_BINDING 0\n#endif\n\nstruct beam\n{\n    float x; float y; float z;\n    float dx; float dy; float dz;\n    float r;\n    float max_length;\n    float strength;\n};\n\nlayout(std430, binding = BEAM_DATA_BINDING) buffer beam_data\n{\n    beam beams[];\n};\n\nvec3 beam_x(int e)\n{\n    return vec3(beams[e].x, beams[e].y, beams[e].z);\n}\n\nvec3 beam_d(int e)\n{\n    return vec3(beams[e].dx, beams[e].dy, beams[e].dz);\n}\n\n\nvoid main()\n{\n    int b = gl_InstanceID;\n\n    vec3 i = beam_d(b);\n    vec3 j = normalize(cross(i, camera_axes[2]+vec3(0,0,0.01)));\n    j *= beams[b].r;\n\n    vec3 p0 = beam_x(b);\n\n    gl_Position.xyz = p0 + x.x*i + x.y*j;\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(draw_beams_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_beams_program_GL_VERTEX_SHADER); glGetShaderiv(draw_beams_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_beams_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_beams_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_beams_program, draw_beams_program_GL_VERTEX_SHADER); 

 GLuint draw_beams_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_beams_program_GL_FRAGMENT_SHADER, "could not create draw_beams_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nsmooth in vec3 r;\n\nvoid main()\n{\n    frag_color = vec4(1,0.5,0.5,0.5);\n    // gl_FragDepth = ;\n}\n"; glShaderSource(draw_beams_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_beams_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_beams_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_beams_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_beams_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_beams_program, draw_beams_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_beams_program);glDetachShader(draw_beams_program, draw_beams_program_GL_VERTEX_SHADER); glDeleteShader(draw_beams_program_GL_VERTEX_SHADER); 
glDetachShader(draw_beams_program, draw_beams_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_beams_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_beams_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_beams_program, available_memory, 0, info_log); log_error(info_log); }draw_lightprobes_program = glCreateProgram(); assert(draw_lightprobes_program, "could not create draw_lightprobes_program, GL error", glGetError());
 GLuint draw_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_lightprobes_program_GL_VERTEX_SHADER, "could not create draw_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\nlayout(location = 2) uniform sampler2D lightprobe_depth;\nlayout(location = 3) uniform sampler2D lightprobe_x;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nsmooth out vec3 r;\nflat out ivec2 probe_coord;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nvoid main()\n{\n    r = x;\n    probe_coord = ivec2(gl_InstanceID%lightprobes_w, gl_InstanceID/lightprobes_w);\n\n    vec2 sample_oct = vec_to_oct(normalize(x));\n    vec2 depth_sample_coord = vec2(lightprobe_depth_padded_resolution*probe_coord+1.0)+(lightprobe_depth_resolution)*clamp(0.5f*sample_oct+0.5f,0,1);\n    depth_sample_coord *= vec2(1.0f/lightprobe_depth_resolution_x, 1.0f/lightprobe_depth_resolution_y);\n    vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n    float variance = abs(probe_depth.g-sq(probe_depth.r));\n    vec3 new_x = x;\n    // if(gl_InstanceID%19 == 0) new_x = clamp(probe_depth.r, 1, lightprobe_spacing)*normalize(x);\n\n    gl_Position.xyz = new_x+texelFetch(lightprobe_x, probe_coord, 0).xyz;\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(draw_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(draw_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_lightprobes_program, draw_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint draw_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_lightprobes_program_GL_FRAGMENT_SHADER, "could not create draw_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform sampler2D lightprobe_color;\nlayout(location = 2) uniform sampler2D lightprobe_depth;\nlayout(location = 3) uniform sampler2D lightprobe_x;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nsmooth in vec3 r;\nflat in ivec2 probe_coord;\n\nvoid main()\n{\n    vec2 sample_oct = vec_to_oct(normalize(r));\n\n    vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1.5)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n    vec2 t = trunc(sample_coord);\n    vec2 f = fract(sample_coord);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    // f = f*f*(-2*f+3);\n    float l = 1-sq(f.x-0.5)*sq(f.y-0.5);\n    sample_coord = t+f-0.5;\n    sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n    vec2 depth_sample_coord = vec2(lightprobe_depth_padded_resolution*probe_coord+1.0)+(lightprobe_depth_resolution)*clamp(0.5f*sample_oct+0.5f,0,1);\n    depth_sample_coord *= vec2(1.0f/lightprobe_depth_resolution_x, 1.0f/lightprobe_depth_resolution_y);\n\n    //show depths\n    // vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n    // float variance = abs(probe_depth.g-sq(probe_depth.r));\n    // frag_color.rgb = vec3(probe_depth.r/lightprobe_spacing, sqrt(variance)/lightprobe_spacing, 0);\n\n    //show color\n    frag_color = textureLod(lightprobe_color, sample_coord, l);\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n    frag_color.a = 1.0;\n}\n"; glShaderSource(draw_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_lightprobes_program, draw_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_lightprobes_program);glDetachShader(draw_lightprobes_program, draw_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(draw_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(draw_lightprobes_program, draw_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }draw_particles_program = glCreateProgram(); assert(draw_particles_program, "could not create draw_particles_program, GL error", glGetError());
 GLuint draw_particles_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_particles_program_GL_VERTEX_SHADER, "could not create draw_particles_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\n\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool is_visual;\n    bool die_on_collision;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    int n_alive_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nsmooth out vec3 r;\n\nvoid main()\n{\n    int p = gl_InstanceID;\n    if(!particles[p].alive)\n    {\n        gl_Position = vec4(0.0/0.0);\n        return;\n    }\n    gl_Position.xyz = x+vec3(particles[p].x, particles[p].y, particles[p].z);\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    r = x;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(draw_particles_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_particles_program_GL_VERTEX_SHADER); glGetShaderiv(draw_particles_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_particles_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_particles_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_particles_program, draw_particles_program_GL_VERTEX_SHADER); 

 GLuint draw_particles_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_particles_program_GL_FRAGMENT_SHADER, "could not create draw_particles_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nsmooth in vec3 r;\n\nvoid main()\n{\n    frag_color = vec4(0,1,0,1);\n}\n"; glShaderSource(draw_particles_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_particles_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_particles_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_particles_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_particles_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_particles_program, draw_particles_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_particles_program);glDetachShader(draw_particles_program, draw_particles_program_GL_VERTEX_SHADER); glDeleteShader(draw_particles_program_GL_VERTEX_SHADER); 
glDetachShader(draw_particles_program, draw_particles_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_particles_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_particles_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_particles_program, available_memory, 0, info_log); log_error(info_log); }draw_text_program = glCreateProgram(); assert(draw_text_program, "could not create draw_text_program, GL error", glGetError());
 GLuint draw_text_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_text_program_GL_VERTEX_SHADER, "could not create draw_text_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 xy;\nlayout(location = 1) in vec2 st;\n\nlayout(location = 0) uniform vec2 resolution;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xy = 2*xy/resolution;\n    gl_Position.y = -gl_Position.y;\n    gl_Position.z = 0.0;\n    gl_Position.w = 1.0;\n    uv = st;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(draw_text_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_text_program_GL_VERTEX_SHADER); glGetShaderiv(draw_text_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_text_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_text_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_text_program, draw_text_program_GL_VERTEX_SHADER); 

 GLuint draw_text_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_text_program_GL_FRAGMENT_SHADER, "could not create draw_text_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform vec4 color;\nlayout(location = 2) uniform sampler2D packed_font;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    frag_color = color*texture(packed_font, uv).r;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(draw_text_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_text_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_text_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_text_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_text_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_text_program, draw_text_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_text_program);glDetachShader(draw_text_program, draw_text_program_GL_VERTEX_SHADER); glDeleteShader(draw_text_program_GL_VERTEX_SHADER); 
glDetachShader(draw_text_program, draw_text_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_text_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_text_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_text_program, available_memory, 0, info_log); log_error(info_log); }fullscreen_texture_program = glCreateProgram(); assert(fullscreen_texture_program, "could not create fullscreen_texture_program, GL error", glGetError());
 GLuint fullscreen_texture_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(fullscreen_texture_program_GL_VERTEX_SHADER, "could not create fullscreen_texture_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5f*x.xy+0.5f;\n}\n\n"; glShaderSource(fullscreen_texture_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_VERTEX_SHADER); glGetShaderiv(fullscreen_texture_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); 

 GLuint fullscreen_texture_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(fullscreen_texture_program_GL_FRAGMENT_SHADER, "could not create fullscreen_texture_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n////////////////<2d circle fragment shader>////////////////\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform sampler2D color;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    frag_color = texture(color, uv);\n}\n"; glShaderSource(fullscreen_texture_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); glGetShaderiv(fullscreen_texture_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glLinkProgram(fullscreen_texture_program);glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); glDeleteShader(fullscreen_texture_program_GL_VERTEX_SHADER); 
glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); glDeleteShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(fullscreen_texture_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(fullscreen_texture_program, available_memory, 0, info_log); log_error(info_log); }get_voxel_data_program = glCreateProgram(); assert(get_voxel_data_program, "could not create get_voxel_data_program, GL error", glGetError());
 GLuint get_voxel_data_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(get_voxel_data_program_GL_VERTEX_SHADER, "could not create get_voxel_data_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5*x.xy+0.5;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(get_voxel_data_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(get_voxel_data_program_GL_VERTEX_SHADER); glGetShaderiv(get_voxel_data_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(get_voxel_data_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile get_voxel_data_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(get_voxel_data_program, get_voxel_data_program_GL_VERTEX_SHADER); 

 GLuint get_voxel_data_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(get_voxel_data_program_GL_FRAGMENT_SHADER, "could not create get_voxel_data_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec2 material;\nlayout(location = 1) out vec3 normal;\n\nlayout(location = 0) uniform isampler3D materials;\nlayout(location = 1) uniform ivec3 pos;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    ivec3 x = pos;\n\n    vec3 gradient = vec3(\n        texelFetch(materials, ivec3(x+vec3(1,0,0)), 0).g-texelFetch(materials, ivec3(x+vec3(-1,0,0)), 0).g,\n        texelFetch(materials, ivec3(x+vec3(0,1,0)), 0).g-texelFetch(materials, ivec3(x+vec3(0,-1,0)), 0).g,\n        texelFetch(materials, ivec3(x+vec3(0,0,1)), 0).g-texelFetch(materials, ivec3(x+vec3(0,0,-1)), 0).g+0.001f\n        );\n    gradient = normalize(gradient);\n\n    material = texelFetch(materials, x, 0).rg;\n    normal = gradient;\n}\n"; glShaderSource(get_voxel_data_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(get_voxel_data_program_GL_FRAGMENT_SHADER); glGetShaderiv(get_voxel_data_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(get_voxel_data_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile get_voxel_data_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(get_voxel_data_program, get_voxel_data_program_GL_FRAGMENT_SHADER); 
glLinkProgram(get_voxel_data_program);glDetachShader(get_voxel_data_program, get_voxel_data_program_GL_VERTEX_SHADER); glDeleteShader(get_voxel_data_program_GL_VERTEX_SHADER); 
glDetachShader(get_voxel_data_program, get_voxel_data_program_GL_FRAGMENT_SHADER); glDeleteShader(get_voxel_data_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(get_voxel_data_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(get_voxel_data_program, available_memory, 0, info_log); log_error(info_log); }mipmap_chunk_program = glCreateProgram(); assert(mipmap_chunk_program, "could not create mipmap_chunk_program, GL error", glGetError());
 GLuint mipmap_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(mipmap_chunk_program_GL_VERTEX_SHADER, "could not create mipmap_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 r;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int mip_level;\nlayout(location = 3) uniform usampler3D active_regions_in;\n\nout vec3 p;\n\nvoid main()\n{\n    float mip_scale = pow(0.5, mip_level-1);\n    int z = layer/(16>>mip_level);\n    int y = int(X.y);\n    int x = int(X.x);\n\n    p=vec3(16*mip_scale*x,16*mip_scale*y,layer*pow(2, mip_level));\n\n    gl_Position = vec4(0.0/0.0, 0.0/0.0, 0, 1);\n\n    float scale = 2.0f/32.0f;\n\n    uint region_active = texelFetch(active_regions_in, ivec3(x, y, z), 0).r;\n    if(region_active != 0)\n    {\n        gl_Position.xy = -1.0f+scale*(r+X);\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(mipmap_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(mipmap_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(mipmap_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(mipmap_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile mipmap_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(mipmap_chunk_program, mipmap_chunk_program_GL_VERTEX_SHADER); 

 GLuint mipmap_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(mipmap_chunk_program_GL_FRAGMENT_SHADER, "could not create mipmap_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec4 frag_color;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int mip_level;\nlayout(location = 2) uniform isampler3D materials;\n\nin vec3 p;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    float mip_scale = pow(2.0, mip_level);\n    ivec3 pos = ivec3(p);\n    ivec3 cell_p;\n    cell_p.xy = ivec2(gl_FragCoord.xy*mip_scale)%int(32/mip_scale);\n    pos.xy += cell_p.xy;\n\n    frag_color.rg = ivec2(0, 16);\n    for(int z = 0; z <= 1; z++)\n        for(int y = 0; y <= 1; y++)\n            for(int x = 0; x <= 1; x++)\n            {\n                ivec4 voxel  = texelFetch(materials, ivec3(pos.x+x, pos.y+y, pos.z+z), mip_level-1);\n                frag_color.r = max(frag_color.r, voxel.r);\n                // if(voxel.g > 1)\n                // {\n                //     frag_color.g = voxel.g-1;\n                //     break;\n                // }\n                frag_color.g = min(frag_color.g, voxel.g);\n            }\n    frag_color.r = pos.z;\n    frag_color.a = 1;\n}\n"; glShaderSource(mipmap_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(mipmap_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(mipmap_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(mipmap_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile mipmap_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(mipmap_chunk_program, mipmap_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(mipmap_chunk_program);glDetachShader(mipmap_chunk_program, mipmap_chunk_program_GL_VERTEX_SHADER); glDeleteShader(mipmap_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(mipmap_chunk_program, mipmap_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(mipmap_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(mipmap_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(mipmap_chunk_program, available_memory, 0, info_log); log_error(info_log); }move_lightprobes_program = glCreateProgram(); assert(move_lightprobes_program, "could not create move_lightprobes_program, GL error", glGetError());
 GLuint move_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(move_lightprobes_program_GL_VERTEX_SHADER, "could not create move_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(move_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(move_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(move_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(move_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile move_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(move_lightprobes_program, move_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint move_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(move_lightprobes_program_GL_FRAGMENT_SHADER, "could not create move_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nlayout(location = 0) out vec3 new_x;\n\nlayout(location = 0) uniform sampler2D material_visual_properties;\nlayout(location = 1) uniform isampler3D materials;\nlayout(location = 2) uniform sampler2D old_x;\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    // return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n    float b = 1-lh;\n    return F0-(vec3(1)-F0)*sq(sq(b))*b;\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    // return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\nvoid main()\n{\n    ivec2 probe_coord = ivec2(gl_FragCoord.xy);\n    vec3 x = texelFetch(old_x, probe_coord, 0).rgb;\n\n    ivec3 ix = ivec3(x);\n\n    //the center of the current cell\n    int j = probe_coord.x+lightprobes_w*probe_coord.y;\n    vec3 center_x = vec3((lightprobe_spacing/2)+lightprobe_spacing*(j%lightprobes_per_axis),\n                         (lightprobe_spacing/2)+lightprobe_spacing*((j/lightprobes_per_axis)%lightprobes_per_axis),\n                         (lightprobe_spacing/2)+lightprobe_spacing*(j/sq(lightprobes_per_axis)));\n\n    ivec4 voxel = texelFetch(materials, ix, 0);\n    #define target_dist 8\n    if(signed_depth(voxel) < target_dist)\n    {\n        vec3 gradient = unnormalized_gradient(materials, ix);\n        gradient = normalize(gradient);\n\n        x += 0.1*gradient*(target_dist-signed_depth(voxel));\n    }\n    else if(signed_depth(voxel) > target_dist+1)\n    {\n        x = mix(x, center_x, 0.1);\n    }\n    x = clamp(x, center_x-0.5*lightprobe_spacing, center_x+0.5*lightprobe_spacing);\n\n    new_x = x;\n}\n"; glShaderSource(move_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(move_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(move_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(move_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile move_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(move_lightprobes_program, move_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(move_lightprobes_program);glDetachShader(move_lightprobes_program, move_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(move_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(move_lightprobes_program, move_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(move_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(move_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(move_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }pad_lightprobes_program = glCreateProgram(); assert(pad_lightprobes_program, "could not create pad_lightprobes_program, GL error", glGetError());
 GLuint pad_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(pad_lightprobes_program_GL_VERTEX_SHADER, "could not create pad_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 x;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\nsmooth out vec2 sample_oct;\n\nvoid main()\n{\n    gl_Position.xy = x;\n    gl_Position.z = 0.0f;\n    gl_Position.w = 1.0f;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(pad_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(pad_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint pad_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(pad_lightprobes_program_GL_FRAGMENT_SHADER, "could not create pad_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec4 depth;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nvoid main()\n{\n    vec2 probe_pos = floor(gl_FragCoord.xy*(1.0f/lightprobe_padded_resolution));\n    vec2 oct = (gl_FragCoord.xy-probe_pos*lightprobe_padded_resolution-1.0f)/lightprobe_resolution-0.5f;\n    if(abs(oct.x) > 0.5)\n        oct.y = -oct.y;\n    if(abs(oct.y) > 0.5)\n        oct.x = -oct.x;\n    ivec2 sample_coord = ivec2(probe_pos*lightprobe_padded_resolution+1.0f\n                               +clamp((oct+0.5f)*lightprobe_resolution, 0, lightprobe_resolution-1));\n    color = texelFetch(lightprobe_color, sample_coord, 0);\n    depth = texelFetch(lightprobe_depth, sample_coord, 0);\n\n    color.a = 1;\n    depth.a = 1;\n}\n"; glShaderSource(pad_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(pad_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(pad_lightprobes_program);glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(pad_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(pad_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(pad_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }render_depth_prepass_program = glCreateProgram(); assert(render_depth_prepass_program, "could not create render_depth_prepass_program, GL error", glGetError());
 GLuint render_depth_prepass_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_depth_prepass_program_GL_VERTEX_SHADER, "could not create render_depth_prepass_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_depth_prepass_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_VERTEX_SHADER); glGetShaderiv(render_depth_prepass_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); 

 GLuint render_depth_prepass_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_depth_prepass_program_GL_FRAGMENT_SHADER, "could not create render_depth_prepass_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 depth;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform vec3 camera_pos;\nlayout(location = 3) uniform isampler3D materials;\nlayout(location = 4) uniform usampler3D occupied_regions;\nlayout(location = 5) uniform ivec3 size;\nlayout(location = 6) uniform ivec3 origin;\nlayout(location = 7) uniform sampler2D blue_noise_texture;\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+PHI*frame_number);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec2 sample_pos = screen_pos.xy;\n    sample_pos += (blue_noise(gl_FragCoord.xy/256.0f+vec2(0.319f, 0.712f)).xy-0.5f)/vec2(360, 180);\n    vec3 ray_dir = (16.0/9.0*sample_pos.x*camera_axes[0]\n                    +        sample_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    vec3 hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int max_iterations = 200;\n    int i = 0;\n    float total_dist = 0;\n\n    if(pos.x < 0 && ray_dir.x > 0)      total_dist = max(total_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) total_dist = max(total_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      total_dist = max(total_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) total_dist = max(total_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      total_dist = max(total_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) total_dist = max(total_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += total_dist*ray_dir;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    int bounces_remaining = 5;\n    bool first_hit = true;\n    vec3 color_multiplier = vec3(1,1,1);\n\n    depth = vec4(0.0);\n\n    // {\n    //     vec3 dist = ((0.5*ray_sign+0.5)*size-ray_sign*pos)*invabs_ray_dir;\n    //     float min_dist = dist.x;\n    //     int min_dir = 0;\n    //     if(dist.y < min_dist) {\n    //         min_dist = dist.y;\n    //         min_dir = 1;\n    //     }\n    //     if(dist.z < min_dist) {\n    //         min_dist = dist.z;\n    //         min_dir = 2;\n    //     }\n    //     ivec3 max_displacement = ivec3(ceil(abs(min_dist*ray_dir)));\n    //     max_iterations = max_displacement.x+max_displacement.y+max_displacement.z;\n    // }\n    // max_iterations = min(max_iterations, 100);\n    // max_iterations = max(max_iterations, 100);\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return;\n        }\n        while(texelFetch(occupied_regions, ipos/16, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos/16.0f)-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            total_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return;\n            }\n        }\n\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            float roughness = 0.0f;\n            vec3 emission = vec3(0.0f);\n            if(voxel.r == 2)\n            {\n                emission = vec3(0.05,0.05,0.1);\n            }\n            if(voxel.r == 4)\n            {\n                emission = vec3(1.0,1.0,1.0);\n            }\n\n            if(voxel.r > 1)\n            {\n                roughness = 0.8;\n            }\n            else\n            {\n                roughness = 0.9;\n            }\n\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            vec3 normal = gradient;\n            normal += roughness*(blue_noise(gl_FragCoord.xy/256.0).rgb-0.5f);\n            normal = normalize(normal);\n            gradient = normalize(gradient);\n\n            depth.rgb += color_multiplier*emission;\n\n            if(voxel.r == 1)\n            {\n                color_multiplier *= vec3(0.54,0.44,0.21);\n                roughness = 0.9;\n            }\n            else if(voxel.r == 3)\n            {\n                color_multiplier *= vec3(0.5,0.5,1.0);\n                roughness = 0.1;\n            }\n            else\n            {\n                color_multiplier *= vec3(0.1,0.1,0.2);\n                roughness = 0.1;\n            }\n\n            color_multiplier *= -dot(ray_dir, normal);\n\n            if(first_hit)\n            {\n                color_multiplier = vec3(1,1,1);\n                depth.rgb = vec3(0,0,0);\n                depth.a = total_dist;\n                first_hit = false;\n            }\n            if(bounces_remaining-- <= 0)\n            {\n                return;\n            }\n            else\n            {\n                ray_dir -= 2*dot(ray_dir, normal)*normal;\n                ray_sign = sign(ray_dir);\n\n                invabs_ray_dir = ray_sign/ray_dir;\n            }\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            total_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        float min_dist = dot(dist, min_dir);\n        pos += min_dist*ray_dir;\n        ipos += ivec3(min_dir*ray_sign);\n        total_dist += min_dist;\n        hit_dir = min_dir;\n\n        // if(first_hit)\n        // {^all that stuff}\n        // else\n        // {\n        //     pos += ray_dir*coarse_step;\n        //     total_dist += coarse_step;\n        //     ipos = ivec3(floor(pos));\n        //     coarse_step += 1.0f*coarse_step*(float_noise(pos.xy+pos.zz));\n        // }\n\n        if(++i >= max_iterations)\n        {\n            return;\n        }\n    }\n}\n"; glShaderSource(render_depth_prepass_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_depth_prepass_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_depth_prepass_program);glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); glDeleteShader(render_depth_prepass_program_GL_VERTEX_SHADER); 
glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); glDeleteShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_depth_prepass_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_depth_prepass_program, available_memory, 0, info_log); log_error(info_log); }render_editor_voxels_program = glCreateProgram(); assert(render_editor_voxels_program, "could not create render_editor_voxels_program, GL error", glGetError());
 GLuint render_editor_voxels_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_editor_voxels_program_GL_VERTEX_SHADER, "could not create render_editor_voxels_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_editor_voxels_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_editor_voxels_program_GL_VERTEX_SHADER); glGetShaderiv(render_editor_voxels_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_editor_voxels_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_editor_voxels_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_editor_voxels_program, render_editor_voxels_program_GL_VERTEX_SHADER); 

 GLuint render_editor_voxels_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_editor_voxels_program_GL_FRAGMENT_SHADER, "could not create render_editor_voxels_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 0) uniform mat3 camera_axes;\nlayout(location = 1) uniform vec3 camera_pos;\nlayout(location = 2) uniform sampler2D material_visual_properties;\nlayout(location = 3) uniform isampler3D form_materials;\nlayout(location = 4) uniform sampler2D blue_noise_texture;\nlayout(location = 5) uniform int frame_number;\nlayout(location = 6) uniform int n_forms;\nlayout(location = 7) uniform int highlight_form;\nlayout(location = 8) uniform ivec3 highlight_cell;\n\n// #define DEBUG_DOTS\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\n// vec3 quasinoise_3(int i)\n// {\n//     float g = 1.0/PHI3;\n//     return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n//     // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n// }\n\nvec2 quasinoise_2(int i)\n{\n    float g = 1.0/PHI2;\n    return fract(0.5+(i%1000)*vec2(g, sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\nvec2 halton(int i)\n{\n    vec2 s = vec2(i);\n    vec2 base = vec2(2,3);\n    vec4 a = vec4(1,1,0,0);\n    while(all(greaterThan(s, vec2(0))))\n    {\n        a.xy = a.xy/base;\n        a.zw += a.xy*mod(vec2(s), base);\n        s = floor(s/base);\n    }\n    return a.zw;\n}\n\n#ifndef FORM_DATA_BINDING\n#define FORM_DATA_BINDING 0\n#endif\n\nstruct form\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n    int x_origin_x; int x_origin_y; int x_origin_z;\n    float x_x; float x_y; float x_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n\n    int cell_material_id;\n    int is_mutating;\n};\n\nivec3 form_materials_origin;\nivec3 form_lower;\nivec3 form_upper;\nivec3 form_size;\nivec3 form_x_origin;\nvec3  form_x;\nvec4  form_orientation;\n\nint form_cell_material_id;\nint form_is_mutating;\n\nlayout(std430, binding = FORM_DATA_BINDING) buffer form_data\n{\n    form forms[];\n};\n\nvoid get_form_data(int f)\n{\n    form_materials_origin = ivec3(forms[f].materials_origin_x,\n                                  forms[f].materials_origin_y,\n                                  forms[f].materials_origin_z);\n    ivec3 form_lower = ivec3(forms[f].lower_x,\n                             forms[f].lower_y,\n                             forms[f].lower_z);\n    ivec3 form_upper = ivec3(forms[f].upper_x,\n                             forms[f].upper_y,\n                             forms[f].upper_z);\n    ivec3 form_size = form_upper-form_lower;\n\n    form_x = vec3(forms[f].x_x, forms[f].x_y, forms[f].x_z);\n    form_orientation = vec4(forms[f].orientation_r, forms[f].orientation_x, forms[f].orientation_y, forms[f].orientation_z);\n\n    form_x_origin = ivec3(forms[f].x_origin_x, forms[f].x_origin_y, forms[f].x_origin_z);\n\n    form_cell_material_id = forms[f].cell_material_id;\n    form_is_mutating = forms[f].is_mutating;\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    // return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n    float b = 1-lh;\n    return F0-(vec3(1)-F0)*sq(sq(b))*b;\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    // return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\n#define RAY_CAST_IGNORE_DEPTH\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, uint medium, bool use_depth, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < 0 || ipos.y < 0 || ipos.z < 0\n           || ipos.x >= size.x || ipos.y >= size.y || ipos.z >= size.z)\n        {\n            return false;\n        }\n\n        #ifdef occupied_regions\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(pos);\n        }\n        else\n        #endif\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != medium)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                if(hit_dir == vec3(0,0,0))\n                {\n                    hit_dir = abs(pos-ipos+0.5);\n                    hit_dir = step(hit_dir.zxy, hit_dir.xyz)*step(hit_dir.yzx, hit_dir.xyz);\n                }\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            #ifndef RAY_CAST_IGNORE_DEPTH\n            if(use_depth)\n            {\n                int depth = depth(voxel);\n                if(depth >= 3\n                   // #ifdef ACTIVE_REGIONS\n                   // && texelFetch(active_regions, ipos>>4, 0).r == 0\n                   // #endif //ACTIVE_REGIONS\n                    )\n                {\n                    float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                    pos += ray_dir*skip_dist;\n                    hit_dist += skip_dist;\n                    ipos = ivec3(pos);\n                }\n            }\n            #endif\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    frag_color = vec4(0,0,0,1);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 0;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    uvec4 voxel;\n    int hit_form = -2;\n    bool hit = false;\n\n    for(int f = 0; f < n_forms; f++)\n    {\n        ivec3 form_x_origin = ivec3(forms[f].x_origin_x, forms[f].x_origin_y, forms[f].x_origin_z);\n        vec3 form_x = vec3(forms[f].x_x, forms[f].x_y, forms[f].x_z);\n        vec4 form_orientation = vec4(forms[f].orientation_r, forms[f].orientation_x, forms[f].orientation_y, forms[f].orientation_z);\n        ivec3 form_lower = ivec3(forms[f].lower_x,\n                                 forms[f].lower_y,\n                                 forms[f].lower_z);\n        ivec3 form_upper = ivec3(forms[f].upper_x,\n                                 forms[f].upper_y,\n                                 forms[f].upper_z);\n        ivec3 form_size = form_upper-form_lower;\n        ivec3 form_origin = ivec3(forms[f].materials_origin_x,\n                                  forms[f].materials_origin_y,\n                                  forms[f].materials_origin_z)+form_lower;\n\n        //ray info in the forms frame\n        vec3 form_pos = apply_rotation(conjugate(form_orientation), pos-form_x) + form_x_origin - form_lower;\n        ivec3 iform_pos = ivec3(floor(form_pos));\n        vec3 form_ray_dir = apply_rotation(conjugate(form_orientation), ray_dir);\n\n        float form_jump_dist = 0.0;\n        //NOTE optimization: could probably reorder this for better superscalaring ie. max(max(),max()) instead of max(max(max()))\n        if(iform_pos.x < 0            && form_ray_dir.x > 0) form_jump_dist = max(form_jump_dist, epsilon+(-form_pos.x)/(form_ray_dir.x));\n        if(iform_pos.x >= form_size.x && form_ray_dir.x < 0) form_jump_dist = max(form_jump_dist, epsilon+(form_size.x-form_pos.x)/(form_ray_dir.x));\n        if(iform_pos.y < 0            && form_ray_dir.y > 0) form_jump_dist = max(form_jump_dist, epsilon+(-form_pos.y)/(form_ray_dir.y));\n        if(iform_pos.y >= form_size.y && form_ray_dir.y < 0) form_jump_dist = max(form_jump_dist, epsilon+(form_size.y-form_pos.y)/(form_ray_dir.y));\n        if(iform_pos.z < 0            && form_ray_dir.z > 0) form_jump_dist = max(form_jump_dist, epsilon+(-form_pos.z)/(form_ray_dir.z));\n        if(iform_pos.z >= form_size.z && form_ray_dir.z < 0) form_jump_dist = max(form_jump_dist, epsilon+(form_size.z-form_pos.z)/(form_ray_dir.z));\n\n        form_pos += form_jump_dist*form_ray_dir;\n\n        vec3 form_hit_pos;\n        float form_hit_dist;\n        ivec3 form_hit_cell;\n        vec3 form_hit_dir;\n        vec3 form_normal;\n        uvec4 form_voxel;\n        bool form_hit = cast_ray(form_materials, form_ray_dir, form_pos, form_size, form_origin, 0, false, form_hit_pos, form_hit_dist, form_hit_cell, form_hit_dir, form_normal, form_voxel, 100);\n        // if(form_hit && (!hit || form_jump_dist+form_hit_dist < hit_dist) && b != 13 && b != 12)\n        if(form_hit && (!hit || form_jump_dist+form_hit_dist < hit_dist))\n        {\n            hit = true;\n            hit_pos = apply_rotation(form_orientation, form_hit_pos-form_x_origin)+form_x;\n            hit_dist = form_jump_dist+form_hit_dist;\n            hit_cell = form_hit_cell;\n            hit_dir = form_hit_dir;\n            hit_form = f;\n            normal = apply_rotation(form_orientation, form_normal);\n            voxel = form_voxel;\n            if(voxel.r >= BASE_CELL_MAT) voxel.r += forms[f].cell_material_id;\n        }\n    }\n\n    total_dist += hit_dist;\n    if(hit)\n    {\n        gl_FragDepth = 1.0f/total_dist;\n\n        uint material_id = mat(voxel);\n        // float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        frag_color.rgb += emission;\n\n        vec3 spotlight_dir = normalize(vec3(-1.4,-0.8,1));\n\n        vec3 reflection_dir = normal;\n\n        float light_value = 0.5*dot(reflection_dir, spotlight_dir)+0.5+0.2;\n        light_value *= 0.5*dot(camera_pos, camera_pos)/sq(total_dist);\n\n        frag_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)*light_value;\n    }\n    else\n    {\n        discard;\n    }\n\n    if(hit_form == highlight_form && hit_cell == highlight_cell)\n    {\n        frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n        frag_color.rgb += vec3(0.5,0.5,0.5);\n    }\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n}\n"; glShaderSource(render_editor_voxels_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_editor_voxels_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_editor_voxels_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_editor_voxels_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_editor_voxels_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_editor_voxels_program, render_editor_voxels_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_editor_voxels_program);glDetachShader(render_editor_voxels_program, render_editor_voxels_program_GL_VERTEX_SHADER); glDeleteShader(render_editor_voxels_program_GL_VERTEX_SHADER); 
glDetachShader(render_editor_voxels_program, render_editor_voxels_program_GL_FRAGMENT_SHADER); glDeleteShader(render_editor_voxels_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_editor_voxels_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_editor_voxels_program, available_memory, 0, info_log); log_error(info_log); }render_prepass_program = glCreateProgram(); assert(render_prepass_program, "could not create render_prepass_program, GL error", glGetError());
 GLuint render_prepass_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_prepass_program_GL_VERTEX_SHADER, "could not create render_prepass_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_prepass_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_prepass_program_GL_VERTEX_SHADER); glGetShaderiv(render_prepass_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_prepass_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_prepass_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_prepass_program, render_prepass_program_GL_VERTEX_SHADER); 

 GLuint render_prepass_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_prepass_program_GL_FRAGMENT_SHADER, "could not create render_prepass_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec3 voxel_x;\nlayout(location = 1) out vec4 voxel_orientation;\nlayout(location = 2) out uvec4 voxel_data;\nlayout(location = 3) out vec4 voxel_color;\n\nlayout(location = 0) uniform mat3 camera_axes;\nlayout(location = 1) uniform vec3 camera_pos;\nlayout(location = 2) uniform sampler2D material_visual_properties;\nlayout(location = 3) uniform usampler3D materials;\nlayout(location = 4) uniform usampler3D active_regions;\nlayout(location = 5) uniform usampler3D occupied_regions;\nlayout(location = 6) uniform isampler3D body_materials;\nlayout(location = 7) uniform ivec3 size;\nlayout(location = 8) uniform ivec3 origin;\nlayout(location = 9) uniform sampler2D lightprobe_color;\nlayout(location = 10) uniform sampler2D lightprobe_depth;\nlayout(location = 11) uniform sampler2D lightprobe_x;\nlayout(location = 12) uniform sampler2D blue_noise_texture;\nlayout(location = 13) uniform int frame_number;\nlayout(location = 14) uniform int n_bodies;\n\n// #define DEBUG_DOTS\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\n// vec3 quasinoise_3(int i)\n// {\n//     float g = 1.0/PHI3;\n//     return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n//     // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n// }\n\nvec2 quasinoise_2(int i)\n{\n    float g = 1.0/PHI2;\n    return fract(0.5+(i%1000)*vec2(g, sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\nvec2 halton(int i)\n{\n    vec2 s = vec2(i);\n    vec2 base = vec2(2,3);\n    vec4 a = vec4(1,1,0,0);\n    while(all(greaterThan(s, vec2(0))))\n    {\n        a.xy = a.xy/base;\n        a.zw += a.xy*mod(vec2(s), base);\n        s = floor(s/base);\n    }\n    return a.zw;\n}\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int texture_lower_x; int texture_lower_y; int texture_lower_z;\n    int texture_upper_x; int texture_upper_y; int texture_upper_z;\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n    int form_offset_x; int form_offset_y; int form_offset_z;\n    int form_origin_x; int form_origin_y; int form_origin_z;\n    int form_lower_x; int form_lower_y; int form_lower_z;\n    int form_upper_x; int form_upper_y; int form_upper_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float old_x_x; float old_x_y; float old_x_z;\n    float old_orientation_r; float old_orientation_x; float old_orientation_y; float old_orientation_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    int boxl_x; int boxl_y; int boxl_z;\n    int boxu_x; int boxu_y; int boxu_z;\n\n    int cell_material_id;\n    int is_mutating;\n    int substantial;\n    int fragment_id;\n\n    int brain_id;\n};\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nivec3 body_texture_lower(int b)\n{\n    return ivec3(bodies[b].texture_lower_x, bodies[b].texture_lower_y, bodies[b].texture_lower_z);\n}\n\nivec3 body_texture_upper(int b)\n{\n    return ivec3(bodies[b].texture_upper_x, bodies[b].texture_upper_y, bodies[b].texture_upper_z);\n}\n\nivec3 body_lower(int b)\n{\n    return ivec3(bodies[b].lower_x, bodies[b].lower_y, bodies[b].lower_z);\n}\n\nivec3 body_upper(int b)\n{\n    return ivec3(bodies[b].upper_x, bodies[b].upper_y, bodies[b].upper_z);\n}\n\nivec3 body_form_offset(int b)\n{\n    return ivec3(bodies[b].form_offset_x, bodies[b].form_offset_y, bodies[b].form_offset_z);\n}\nvec3 body_x_cm(int b)\n{\n    return vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n}\n\nvec3 body_x(int b)\n{\n    return vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n}\n\nvec3 body_x_dot(int b)\n{\n    return vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n}\n\nvec4 body_orientation(int b)\n{\n    return vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n}\n\nvec3 body_omega(int b)\n{\n    return vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n}\n\nvec3 body_old_x(int b)\n{\n    return vec3(bodies[b].old_x_x, bodies[b].old_x_y, bodies[b].old_x_z);\n}\n\nvec4 body_old_orientation(int b)\n{\n    return vec4(bodies[b].old_orientation_r, bodies[b].old_orientation_x, bodies[b].old_orientation_y, bodies[b].old_orientation_z);\n}\n\nfloat body_m(int b)\n{\n    return bodies[b].m;\n}\n\nmat3 body_I(int b)\n{\n    return mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n}\n\nmat3 body_invI(int b)\n{\n    return mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\nvec3 body_boxl(int b)\n{\n    return vec3(bodies[b].boxl_x, bodies[b].boxl_y, bodies[b].boxl_z);\n}\n\nvec3 body_boxu(int b)\n{\n    return vec3(bodies[b].boxu_x, bodies[b].boxu_y, bodies[b].boxu_z);\n}\n\nivec3 body_form_origin(int b)\n{\n    return ivec3(bodies[b].form_origin_x, bodies[b].form_origin_y, bodies[b].form_origin_z);\n}\n\nivec3 body_form_lower(int b)\n{\n    return ivec3(bodies[b].form_lower_x, bodies[b].form_lower_y, bodies[b].form_lower_z);\n}\n\nivec3 body_form_upper(int b)\n{\n    return ivec3(bodies[b].form_upper_x, bodies[b].form_upper_y, bodies[b].form_upper_z);\n}\n\nint body_cell_material_id(int b)\n{\n    return bodies[b].cell_material_id;\n}\n\nint body_is_mutating(int b)\n{\n    return bodies[b].is_mutating;\n}\n\nint body_is_substantial(int b)\n{\n    return bodies[b].substantial;\n}\n\nint body_fragment_id(int b)\n{\n    return bodies[b].fragment_id;\n}\n\nint body_brain_id(int b)\n{\n    return bodies[b].brain_id;\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    // return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n    float b = 1-lh;\n    return F0-(vec3(1)-F0)*sq(sq(b))*b;\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    // return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, uint medium, bool use_depth, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < 0 || ipos.y < 0 || ipos.z < 0\n           || ipos.x >= size.x || ipos.y >= size.y || ipos.z >= size.z)\n        {\n            return false;\n        }\n\n        #ifdef occupied_regions\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(pos);\n        }\n        else\n        #endif\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != medium)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                if(hit_dir == vec3(0,0,0))\n                {\n                    hit_dir = abs(pos-ipos+0.5);\n                    hit_dir = step(hit_dir.zxy, hit_dir.xyz)*step(hit_dir.yzx, hit_dir.xyz);\n                }\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            #ifndef RAY_CAST_IGNORE_DEPTH\n            if(use_depth)\n            {\n                int depth = depth(voxel);\n                if(depth >= 3\n                   // #ifdef ACTIVE_REGIONS\n                   // && texelFetch(active_regions, ipos>>4, 0).r == 0\n                   // #endif //ACTIVE_REGIONS\n                    )\n                {\n                    float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                    pos += ray_dir*skip_dist;\n                    hit_dist += skip_dist;\n                    ipos = ivec3(pos);\n                }\n            }\n            #endif\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    // pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    ivec3 base_probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing);\n\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = base_probe_pos+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                probe_color.a = 1;\n\n                float normal_bias = 4.0;\n                vec3 dist = pos+(normal)*normal_bias-probe_x; //NOTE: Majercjk adds 3*view dir to the normal here\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 dir_oct = vec_to_oct(dir);\n                vec2 depth_sample_coord = vec2(lightprobe_depth_padded_resolution*probe_coord+1.0)+lightprobe_depth_resolution*clamp(0.5f*dir_oct+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_depth_resolution_x, 1.0f/lightprobe_depth_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                float weight = 1.0;\n\n                vec3 true_dir = normalize(probe_x-pos); //direction without bias\n                weight *= sq(max(0.0001, 0.5*dot(normal, true_dir)+0.5))+0.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                //Chebychev's inequality, upper bound for an arbitrary distribution\n                if(r > probe_depth.r)\n                {\n                    float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                    float cheb_weight = variance/max(variance+sq(r-probe_depth.r), 0.001);\n                    cheb_weight = max(sq(cheb_weight)*cheb_weight, 0);\n                    weight *= cheb_weight;\n                }\n\n                // //This assumes Gaussian distribution\n                // float variance = abs(probe_depth.g-sq(probe_depth.r));\n                // float x = (probe_depth.r-r)*inversesqrt(variance);\n                // weight *= cdf(x);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    vec3 pos = camera_pos;\n\n    uint medium = texelFetch(materials, ivec3(pos), 0).r;\n\n    voxel_data = uvec4(0,0,0,0);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 0;\n\n    voxel_orientation = vec4(1,0,0,0);\n\n    float bounding_jump_dist = 0.0;\n    if(pos.x < 0 && ray_dir.x > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += bounding_jump_dist*ray_dir;\n    total_dist += bounding_jump_dist;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    uvec4 voxel;\n    bool hit = cast_ray(materials, ray_dir, pos, size, origin, medium, medium==0, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 300);\n    // bool hit = coarse_cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n    // voxel = texelFetch(materials, hit_cell, 0);\n\n    if(hit)\n    {\n        // normal = normalize(unnormalized_gradient(materials, hit_cell));\n        voxel_x = vec3(hit_cell)+0.5;\n    }\n\n    for(int b = 0; b < n_bodies; b++)\n    {\n        if(bodies[b].substantial == 0) continue;\n        vec3 body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n        vec3 body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n        vec4 body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n        ivec3 body_texture_lower = ivec3(bodies[b].texture_lower_x, bodies[b].texture_lower_y, bodies[b].texture_lower_z);\n        ivec3 body_texture_upper = ivec3(bodies[b].texture_upper_x, bodies[b].texture_upper_y, bodies[b].texture_upper_z);\n        ivec3 body_lower = ivec3(bodies[b].lower_x, bodies[b].lower_y, bodies[b].lower_z);\n        ivec3 body_upper = ivec3(bodies[b].upper_x, bodies[b].upper_y, bodies[b].upper_z);\n        ivec3 body_size = body_upper-body_lower;\n        ivec3 body_origin = body_lower+body_texture_lower;\n\n        //ray info in the bodies frame\n        vec3 body_pos = apply_rotation(conjugate(body_orientation), pos-body_x) + body_x_cm - body_lower;\n        ivec3 ibody_pos = ivec3(floor(body_pos));\n        vec3 body_ray_dir = apply_rotation(conjugate(body_orientation), ray_dir);\n\n        float body_jump_dist = 0.0;\n        if(ibody_pos.x < 0            && body_ray_dir.x > 0) body_jump_dist = max(body_jump_dist, epsilon+(-body_pos.x)/(body_ray_dir.x));\n        if(ibody_pos.x >= body_size.x && body_ray_dir.x < 0) body_jump_dist = max(body_jump_dist, epsilon+(body_size.x-body_pos.x)/(body_ray_dir.x));\n        if(ibody_pos.y < 0            && body_ray_dir.y > 0) body_jump_dist = max(body_jump_dist, epsilon+(-body_pos.y)/(body_ray_dir.y));\n        if(ibody_pos.y >= body_size.y && body_ray_dir.y < 0) body_jump_dist = max(body_jump_dist, epsilon+(body_size.y-body_pos.y)/(body_ray_dir.y));\n        if(ibody_pos.z < 0            && body_ray_dir.z > 0) body_jump_dist = max(body_jump_dist, epsilon+(-body_pos.z)/(body_ray_dir.z));\n        if(ibody_pos.z >= body_size.z && body_ray_dir.z < 0) body_jump_dist = max(body_jump_dist, epsilon+(body_size.z-body_pos.z)/(body_ray_dir.z));\n\n        body_pos += body_jump_dist*body_ray_dir;\n\n        vec3 body_hit_pos;\n        float body_hit_dist;\n        ivec3 body_hit_cell;\n        vec3 body_hit_dir;\n        vec3 body_normal;\n        uvec4 body_voxel;\n        bool body_hit = cast_ray(body_materials, body_ray_dir, body_pos, body_size, body_origin, 0, false, body_hit_pos, body_hit_dist, body_hit_cell, body_hit_dir, body_normal, body_voxel, 100);\n        // if(body_hit && (!hit || body_jump_dist+body_hit_dist < hit_dist) && b != 13 && b != 12)\n        float new_dist = body_jump_dist+body_hit_dist;\n        if(body_hit && (!hit || new_dist < hit_dist))\n        {\n            hit = true;\n            hit_pos = apply_rotation(body_orientation, body_hit_pos+body_lower-body_x_cm)+body_x;\n            hit_dist = new_dist;\n            hit_cell = body_hit_cell;\n            hit_dir = body_hit_dir;\n            normal = apply_rotation(body_orientation, body_normal);\n            voxel = body_voxel;\n            if(voxel.r >= BASE_CELL_MAT) voxel.r += bodies[b].cell_material_id;\n            voxel_orientation = body_orientation;\n            voxel_x = apply_rotation(body_orientation, vec3(body_hit_cell+body_lower)-body_x_cm+0.5)+body_x;\n        }\n    }\n\n    vec4 transmission = vec4(1);\n\n    voxel_color = vec4(0);\n\n    total_dist += hit_dist;\n    if(hit)\n    {\n        float initial_transmission = exp(-opacity(mat(medium))*hit_dist);\n\n        voxel_data = voxel;\n\n        gl_FragDepth = 1.0f/total_dist;\n\n        for(int i = 0; i < 5; i++)\n        {\n            if(opacity(mat(voxel)) >= 1) break;\n            vec3 ray_pos = hit_pos;\n            if(ivec3(ray_pos) != hit_cell) ray_pos += 0.001*ray_dir;\n            float c = dot(ray_dir, normal);\n            float r = refractive_index(medium)/refractive_index(mat(voxel));\n            float square = 1.0-sq(r)*(1.0-sq(c));\n            if(square > 0) ray_dir = r*ray_dir+(-r*c+sign(c)*sqrt(square))*normal;\n            else ray_dir = ray_dir - 2*c*normal; //total internal reflection\n            // ray_dir = normalize(ray_dir);\n            medium = mat(voxel);\n            bool hit = cast_ray(materials, ray_dir, ray_pos, size, origin, medium, medium==0, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 200);\n\n            if(hit)\n            {\n                transmission *= exp(-opacity(mat(medium))*hit_dist);\n            }\n            else\n            {\n                break;\n            }\n\n            if(dot(transmission, transmission) < 0.001) break;\n\n            uint material_id = voxel.r;\n            float roughness = get_roughness(material_id);\n            vec3 emission = get_emission(material_id);\n\n            // voxel_color.rgb += -(emission)*dot(normal, ray_dir);\n            voxel_color.rgb += emission;\n\n            //TODO: actual blackbody color\n            voxel_color.rgb += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n            voxel_color.rgb += vec3(0.7,0.3,1.0)*clamp((1.0/15.0)*(float(volt(voxel))), 0.0, 1.0);\n\n            vec3 reflection_dir = normal;\n            vec2 sample_depth;\n            voxel_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)\n                *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n            voxel_color *= transmission;\n        }\n        voxel_color.a = initial_transmission; //pretty hacky, pretty sure I should restructure rendering stuff later\n    }\n}\n"; glShaderSource(render_prepass_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_prepass_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_prepass_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_prepass_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_prepass_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_prepass_program, render_prepass_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_prepass_program);glDetachShader(render_prepass_program, render_prepass_program_GL_VERTEX_SHADER); glDeleteShader(render_prepass_program_GL_VERTEX_SHADER); 
glDetachShader(render_prepass_program, render_prepass_program_GL_FRAGMENT_SHADER); glDeleteShader(render_prepass_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_prepass_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_prepass_program, available_memory, 0, info_log); log_error(info_log); }render_world_program = glCreateProgram(); assert(render_world_program, "could not create render_world_program, GL error", glGetError());
 GLuint render_world_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_world_program_GL_VERTEX_SHADER, "could not create render_world_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_world_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_world_program_GL_VERTEX_SHADER); glGetShaderiv(render_world_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_world_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_world_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_world_program, render_world_program_GL_VERTEX_SHADER); 

 GLuint render_world_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_world_program_GL_FRAGMENT_SHADER, "could not create render_world_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\nlayout(location = 1) out vec3 normal;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform vec3 camera_pos;\nlayout(location = 3) uniform sampler2D material_visual_properties;\nlayout(location = 4) uniform sampler2D prepass_x;\nlayout(location = 5) uniform sampler2D prepass_orientation;\nlayout(location = 6) uniform usampler2D prepass_voxel;\nlayout(location = 7) uniform sampler2D prepass_color;\nlayout(location = 8) uniform vec2 prepass_resolution;\nlayout(location = 9) uniform sampler2D lightprobe_color;\nlayout(location = 10) uniform sampler2D lightprobe_depth;\nlayout(location = 11) uniform sampler2D lightprobe_x;\nlayout(location = 12) uniform sampler2D blue_noise_texture;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\n// vec3 quasinoise_3(int i)\n// {\n//     float g = 1.0/PHI3;\n//     return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n//     // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n// }\n\nvec2 quasinoise_2(int i)\n{\n    float g = 1.0/PHI2;\n    return fract(0.5+(i%1000)*vec2(g, sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\nvec2 halton(int i)\n{\n    vec2 s = vec2(i);\n    vec2 base = vec2(2,3);\n    vec4 a = vec4(1,1,0,0);\n    while(all(greaterThan(s, vec2(0))))\n    {\n        a.xy = a.xy/base;\n        a.zw += a.xy*mod(vec2(s), base);\n        s = floor(s/base);\n    }\n    return a.zw;\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    // return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n    float b = 1-lh;\n    return F0-(vec3(1)-F0)*sq(sq(b))*b;\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    // return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    // pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    ivec3 base_probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing);\n\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = base_probe_pos+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                probe_color.a = 1;\n\n                float normal_bias = 4.0;\n                vec3 dist = pos+(normal)*normal_bias-probe_x; //NOTE: Majercjk adds 3*view dir to the normal here\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 dir_oct = vec_to_oct(dir);\n                vec2 depth_sample_coord = vec2(lightprobe_depth_padded_resolution*probe_coord+1.0)+lightprobe_depth_resolution*clamp(0.5f*dir_oct+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_depth_resolution_x, 1.0f/lightprobe_depth_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                float weight = 1.0;\n\n                vec3 true_dir = normalize(probe_x-pos); //direction without bias\n                weight *= sq(max(0.0001, 0.5*dot(normal, true_dir)+0.5))+0.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                //Chebychev's inequality, upper bound for an arbitrary distribution\n                if(r > probe_depth.r)\n                {\n                    float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                    float cheb_weight = variance/max(variance+sq(r-probe_depth.r), 0.001);\n                    cheb_weight = max(sq(cheb_weight)*cheb_weight, 0);\n                    weight *= cheb_weight;\n                }\n\n                // //This assumes Gaussian distribution\n                // float variance = abs(probe_depth.g-sq(probe_depth.r));\n                // float x = (probe_depth.r-r)*inversesqrt(variance);\n                // weight *= cdf(x);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    frag_color = vec4(0,0,0,1);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 10000;\n\n    ivec2 prepass_coord = ivec2((0.5*screen_pos+0.5)*prepass_resolution-0.5);\n\n    uvec4 voxel;\n    vec3 hit_pos;\n\n    float transmission = 1;\n\n    ivec2 d = ivec2(0);\n    for(d.y = 0; d.y <= 1; d.y++)\n        for(d.x = 0; d.x <= 1; d.x++)\n        {\n            vec3 x = texelFetch(prepass_x, prepass_coord+d, 0).xyz;\n            vec4 orientation = texelFetch(prepass_orientation, prepass_coord+d, 0);\n            vec4 inv_orientation = conjugate(orientation);\n\n            vec3 cube_ray_dir = apply_rotation(inv_orientation, ray_dir);\n            vec3 cube_ray_pos = apply_rotation(inv_orientation, camera_pos-x);\n\n            vec3 ray_sign = sign_not_zero(cube_ray_dir);\n            cube_ray_dir *= -ray_sign;\n            cube_ray_pos *= -ray_sign;\n            cube_ray_pos -= 0.5; //origin placed at front-most corner\n            vec3 dist = -cube_ray_pos/cube_ray_dir;\n            vec3 max_dir = step(dist.zxy, dist.xyz)*step(dist.yzx, dist.xyz);\n            float face_dist = dot(max_dir, dist);\n            vec3 hit_x = cube_ray_pos+face_dist*cube_ray_dir;\n            vec3 outmost_edge = step(hit_x.zxy, hit_x.xyz)*step(hit_x.yzx, hit_x.xyz);\n\n            if(all(greaterThan(hit_x, vec3(-1.0) +face_dist/((270.0/pi)*dot(cube_ray_dir, max_dir)))) &&\n               face_dist < total_dist && face_dist > 0)\n            // if(all(greaterThan(hit_x, vec3(-1.0))) &&\n            //    face_dist < total_dist && face_dist > 0)\n            {\n                total_dist = face_dist;\n                vec4 transmitted_color = texelFetch(prepass_color, prepass_coord+d, 0);\n                transmission = transmitted_color.a;\n                frag_color.rgb = transmitted_color.rgb;\n                voxel = texelFetch(prepass_voxel, prepass_coord+d, 0);\n                normal = apply_rotation(orientation, -ray_sign*max_dir);\n                hit_pos = camera_pos+face_dist*ray_dir;\n                // frag_color.rgb = max_dir;\n            }\n        }\n\n    // {\n    //     ivec2 prepass_coord = ivec2((0.5*screen_pos+0.5)*prepass_resolution);\n\n    //     vec3 x = texelFetch(prepass_x, prepass_coord, 0).xyz;\n    //     vec4 orientation = texelFetch(prepass_orientation, prepass_coord+d, 0);\n    //     vec4 inv_orientation = conjugate(orientation);\n\n    //     vec3 cube_ray_dir = apply_rotation(inv_orientation, ray_dir);\n    //     vec3 cube_ray_pos = apply_rotation(inv_orientation, camera_pos-x);\n\n    //     vec3 ray_sign = sign_not_zero(cube_ray_dir);\n    //     cube_ray_dir *= -ray_sign;\n    //     cube_ray_pos *= -ray_sign;\n    //     cube_ray_pos -= 0.5; //origin placed at front-most corner\n    //     vec3 dist = -cube_ray_pos/cube_ray_dir;\n    //     vec3 max_dir = step(dist.zxy, dist.xyz)*step(dist.yzx, dist.xyz);\n    //     float face_dist = dot(max_dir, dist);\n    //     vec3 hit_x = cube_ray_pos+face_dist*cube_ray_dir;\n    //     vec3 outmost_edge = step(hit_x.zxy, hit_x.xyz)*step(hit_x.yzx, hit_x.xyz);\n\n    //     total_dist = face_dist;\n    //     vec4 transmitted_color = texelFetch(prepass_color, prepass_coord, 0);\n    //     reflectance = 1-transmitted_color.a;\n    //     frag_color.rgb = transmitted_color.rgb;\n    //     voxel = texelFetch(prepass_voxel, prepass_coord, 0);\n    //     normal = apply_rotation(orientation, -ray_sign*max_dir);\n    //     hit_pos = camera_pos+face_dist*ray_dir;\n    //     // frag_color.rgb = max_dir;\n    // }\n\n    {\n        uint material_id = voxel.r;\n        float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        // frag_color.rgb += -(emission)*dot(normal, ray_dir);\n        frag_color.rgb += emission;\n\n        //TODO: actual blackbody color\n        frag_color.rgb += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n        frag_color.rgb += vec3(0.7,0.3,1.0)*clamp((1.0/15.0)*(float(volt(voxel))), 0.0, 1.0);\n\n        vec3 reflection_dir = normal;\n        vec2 sample_depth;\n        frag_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)\n            *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        // frag_color.rgb += sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth); //no materials\n    }\n    frag_color.rgb *= transmission;\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n    // frag_color.rgb = normal;\n    gl_FragDepth = 1.0f/total_dist;\n}\n"; glShaderSource(render_world_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_world_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_world_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_world_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_world_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_world_program, render_world_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_world_program);glDetachShader(render_world_program, render_world_program_GL_VERTEX_SHADER); glDeleteShader(render_world_program_GL_VERTEX_SHADER); 
glDetachShader(render_world_program, render_world_program_GL_FRAGMENT_SHADER); glDeleteShader(render_world_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_world_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_world_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_program = glCreateProgram(); assert(simulate_body_program, "could not create simulate_body_program, GL error", glGetError());
 GLuint simulate_body_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_body_program_GL_COMPUTE_SHADER, "could not create simulate_body_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n\n#define localgroup_size 4\n#define subgroup_size 1\nlayout(local_size_x = localgroup_size, local_size_y = localgroup_size, local_size_z = localgroup_size) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform usampler3D body_materials;\nlayout(location = 4, rgba8ui) uniform uimage3D body_materials_out;\nlayout(location = 5) uniform usampler3D form_materials;\nlayout(location = 6) uniform int n_bodies;\nlayout(location = 7) uniform int n_beams;\nlayout(location = 8) uniform int n_body_chunks;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int texture_lower_x; int texture_lower_y; int texture_lower_z;\n    int texture_upper_x; int texture_upper_y; int texture_upper_z;\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n    int form_offset_x; int form_offset_y; int form_offset_z;\n    int form_origin_x; int form_origin_y; int form_origin_z;\n    int form_lower_x; int form_lower_y; int form_lower_z;\n    int form_upper_x; int form_upper_y; int form_upper_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float old_x_x; float old_x_y; float old_x_z;\n    float old_orientation_r; float old_orientation_x; float old_orientation_y; float old_orientation_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    int boxl_x; int boxl_y; int boxl_z;\n    int boxu_x; int boxu_y; int boxu_z;\n\n    int cell_material_id;\n    int is_mutating;\n    int substantial;\n    int fragment_id;\n\n    int brain_id;\n};\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nivec3 body_texture_lower(int b)\n{\n    return ivec3(bodies[b].texture_lower_x, bodies[b].texture_lower_y, bodies[b].texture_lower_z);\n}\n\nivec3 body_texture_upper(int b)\n{\n    return ivec3(bodies[b].texture_upper_x, bodies[b].texture_upper_y, bodies[b].texture_upper_z);\n}\n\nivec3 body_lower(int b)\n{\n    return ivec3(bodies[b].lower_x, bodies[b].lower_y, bodies[b].lower_z);\n}\n\nivec3 body_upper(int b)\n{\n    return ivec3(bodies[b].upper_x, bodies[b].upper_y, bodies[b].upper_z);\n}\n\nivec3 body_form_offset(int b)\n{\n    return ivec3(bodies[b].form_offset_x, bodies[b].form_offset_y, bodies[b].form_offset_z);\n}\nvec3 body_x_cm(int b)\n{\n    return vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n}\n\nvec3 body_x(int b)\n{\n    return vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n}\n\nvec3 body_x_dot(int b)\n{\n    return vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n}\n\nvec4 body_orientation(int b)\n{\n    return vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n}\n\nvec3 body_omega(int b)\n{\n    return vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n}\n\nvec3 body_old_x(int b)\n{\n    return vec3(bodies[b].old_x_x, bodies[b].old_x_y, bodies[b].old_x_z);\n}\n\nvec4 body_old_orientation(int b)\n{\n    return vec4(bodies[b].old_orientation_r, bodies[b].old_orientation_x, bodies[b].old_orientation_y, bodies[b].old_orientation_z);\n}\n\nfloat body_m(int b)\n{\n    return bodies[b].m;\n}\n\nmat3 body_I(int b)\n{\n    return mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n}\n\nmat3 body_invI(int b)\n{\n    return mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\nvec3 body_boxl(int b)\n{\n    return vec3(bodies[b].boxl_x, bodies[b].boxl_y, bodies[b].boxl_z);\n}\n\nvec3 body_boxu(int b)\n{\n    return vec3(bodies[b].boxu_x, bodies[b].boxu_y, bodies[b].boxu_z);\n}\n\nivec3 body_form_origin(int b)\n{\n    return ivec3(bodies[b].form_origin_x, bodies[b].form_origin_y, bodies[b].form_origin_z);\n}\n\nivec3 body_form_lower(int b)\n{\n    return ivec3(bodies[b].form_lower_x, bodies[b].form_lower_y, bodies[b].form_lower_z);\n}\n\nivec3 body_form_upper(int b)\n{\n    return ivec3(bodies[b].form_upper_x, bodies[b].form_upper_y, bodies[b].form_upper_z);\n}\n\nint body_cell_material_id(int b)\n{\n    return bodies[b].cell_material_id;\n}\n\nint body_is_mutating(int b)\n{\n    return bodies[b].is_mutating;\n}\n\nint body_is_substantial(int b)\n{\n    return bodies[b].substantial;\n}\n\nint body_fragment_id(int b)\n{\n    return bodies[b].fragment_id;\n}\n\nint body_brain_id(int b)\n{\n    return bodies[b].brain_id;\n}\n\n#define BODY_UPDATE_DATA_BINDING 1\n#ifndef BODY_UPDATE_DATA_BINDING\n#define BODY_UPDATE_DATA_BINDING 0\n#endif\n\nstruct body_update\n{\n    float m;\n    float I_xx;\n    float I_xy; float I_yy;\n    float I_xz; float I_yz; float I_zz;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n\n    int fragment_index;\n    int n_fragments;\n};\n\nlayout(std430, binding = BODY_UPDATE_DATA_BINDING) buffer body_update_data\n{\n    body_update body_updates[];\n};\n\n#define PARTICLE_DATA_BINDING 2\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool is_visual;\n    bool die_on_collision;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    int n_alive_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n#define BEAM_DATA_BINDING 3\n#ifndef BEAM_DATA_BINDING\n#define BEAM_DATA_BINDING 0\n#endif\n\nstruct beam\n{\n    float x; float y; float z;\n    float dx; float dy; float dz;\n    float r;\n    float max_length;\n    float strength;\n};\n\nlayout(std430, binding = BEAM_DATA_BINDING) buffer beam_data\n{\n    beam beams[];\n};\n\nvec3 beam_x(int e)\n{\n    return vec3(beams[e].x, beams[e].y, beams[e].z);\n}\n\nvec3 beam_d(int e)\n{\n    return vec3(beams[e].dx, beams[e].dy, beams[e].dz);\n}\n\n#define CONTACT_DATA_BINDING 4\n#ifndef CONTACT_DATA_BINDING\n#define CONTACT_DATA_BINDING 0\n#endif\n\nstruct contact_point\n{\n    int b0;\n    int b1;\n    uint material0;\n    uint material1;\n    uint phase;\n    float depth0;\n    float depth1;\n    float p0_x; float p0_y; float p0_z;\n    float p1_x; float p1_y; float p1_z;\n    float n_x; float n_y; float n_z;\n    float f_x; float f_y; float f_z;\n};\n\nlayout(std430, binding = CONTACT_DATA_BINDING) buffer contact_data\n{\n    int n_contacts;\n    contact_point contacts[];\n};\n\n#define COLLISION_GRID_BINDING 5\n#ifndef COLLISION_GRID_BINDING\n#define COLLISION_GRID_BINDING 0\n#endif\n\nstruct collision_cell\n{\n    int first_index;\n    int n_bodies;\n};\n\n#define collision_cells_per_axis 16\n#define collision_cell_size 32\n\nlayout(std430, binding = COLLISION_GRID_BINDING) buffer collision_grid_data\n{\n    collision_cell collision_grid[collision_cells_per_axis*collision_cells_per_axis*collision_cells_per_axis];\n    int n_collision_indices;\n    int collision_indices[];\n};\n\n#define BODY_CHUNKS_BINDING 6\n\nstruct body_chunk\n{\n    uint body_id;\n    uint origin_x;\n    uint origin_y;\n    uint origin_z;\n};\n\nlayout(std430, binding = BODY_CHUNKS_BINDING) buffer body_chunk_data\n{\n    body_chunk body_chunks[];\n};\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nvoid add_contact(int bi0, int bi1, uvec4 voxel0, uvec4 voxel1, vec3 body0_coord, vec3 body1_coord, vec3 normal, uint phase)\n{\n    int collision_index = atomicAdd(n_contacts, 1);\n\n    contact_point new_contact;\n\n    new_contact.b0 = bi0;\n    new_contact.b1 = bi1;\n\n    new_contact.material0 = mat(voxel0);\n    new_contact.material1 = mat(voxel1);\n\n    new_contact.phase = phase;\n\n    new_contact.p0_x = body0_coord.x;\n    new_contact.p0_y = body0_coord.y;\n    new_contact.p0_z = body0_coord.z;\n\n    new_contact.p1_x = body1_coord.x;\n    new_contact.p1_y = body1_coord.y;\n    new_contact.p1_z = body1_coord.z;\n\n    new_contact.n_x = normal.x;\n    new_contact.n_y = normal.y;\n    new_contact.n_z = normal.z;\n    new_contact.depth0 = signed_depth(voxel0);\n    new_contact.depth1 = signed_depth(voxel1);\n\n    new_contact.f_x = 0;\n    new_contact.f_y = 0;\n    new_contact.f_z = 0;\n\n    contacts[collision_index++] = new_contact;\n}\n\nvoid main()\n{\n    uint body_chunk_id = gl_WorkGroupID.x;\n    int bi = int(body_chunks[body_chunk_id].body_id);\n    uvec3 origin = uvec3(body_chunks[body_chunk_id].origin_x, body_chunks[body_chunk_id].origin_y, body_chunks[body_chunk_id].origin_z);\n\n    int pad = 1;\n    ivec3 pos = ivec3(origin+gl_LocalInvocationID);\n    // if(any(greaterThan(pos, body_texture_lower(bi)+body_upper(bi)))) return;\n    if(any(greaterThanEqual(pos, body_texture_upper(bi)))) return;\n\n    // if(bi == 0 && layer == 0 && gl_VertexID == 0)\n    // {\n    //     int dead_index = atomicAdd(n_dead_particles, -1)-1;\n    //     //this assumes particle creation and destruction never happen simutaneously\n    //     uint p = dead_particles[dead_index];\n    //     particles[p].voxel_data = 3|(2<<(6+8))|(8<<(2+16))|(15<<24);\n    //     particles[p].x = bodies[bi].x_x;\n    //     particles[p].y = bodies[bi].x_y;\n    //     particles[p].z = bodies[bi].x_z;\n    //     particles[p].x_dot = bodies[bi].x_dot_x;\n    //     particles[p].y_dot = bodies[bi].x_dot_y;\n    //     particles[p].z_dot = bodies[bi].x_dot_z+5;\n    //     particles[p].alive = true;\n    // }\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    // uint rot = (2*(pos.x+pos.y+pos.z))%4;\n    uint rot = 0;\n    int i = 0;\n    ivec2 dir = ivec2(((rot&1)*(2-rot)), (1-(rot&1))*(1-rot));\n\n    ivec3 pu = ivec3(pos.x, pos.y, pos.z+1);\n    ivec3 pd = ivec3(pos.x, pos.y, pos.z-1);\n    ivec3 pr = ivec3(pos.x+dir.x, pos.y+dir.y, pos.z);\n    ivec3 pl = ivec3(pos.x-dir.x, pos.y-dir.y, pos.z);\n    ivec3 pf = ivec3(pos.x-dir.y, pos.y+dir.x, pos.z);\n    ivec3 pb = ivec3(pos.x+dir.y, pos.y-dir.x, pos.z);\n\n    uvec4 c  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z), 0);\n    uvec4 u  = texelFetch(body_materials, pu, 0);\n    uvec4 d  = texelFetch(body_materials, pd, 0);\n    uvec4 r  = texelFetch(body_materials, pr, 0);\n    uvec4 l  = texelFetch(body_materials, pl, 0);\n    uvec4 f  = texelFetch(body_materials, pf, 0);\n    uvec4 b  = texelFetch(body_materials, pb, 0);\n\n    if(body_fragment_id(bi) > 0)\n    {\n        if(floodfill(c) != body_fragment_id(bi)) c = uvec4(0);\n        if(floodfill(u) != body_fragment_id(bi)\n           || any(lessThan(pu, body_texture_lower(bi)))\n           || any(greaterThanEqual(pu, body_texture_upper(bi)))) u = uvec4(0);\n        if(floodfill(d) != body_fragment_id(bi)\n           || any(lessThan(pd, body_texture_lower(bi)))\n           || any(greaterThanEqual(pd, body_texture_upper(bi)))) d = uvec4(0);\n        if(floodfill(r) != body_fragment_id(bi)\n           || any(lessThan(pr, body_texture_lower(bi)))\n           || any(greaterThanEqual(pr, body_texture_upper(bi)))) r = uvec4(0);\n        if(floodfill(l) != body_fragment_id(bi)\n           || any(lessThan(pl, body_texture_lower(bi)))\n           || any(greaterThanEqual(pl, body_texture_upper(bi)))) l = uvec4(0);\n        if(floodfill(f) != body_fragment_id(bi)\n           || any(lessThan(pf, body_texture_lower(bi)))\n           || any(greaterThanEqual(pf, body_texture_upper(bi)))) f = uvec4(0);\n        if(floodfill(b) != body_fragment_id(bi)\n           || any(lessThan(pb, body_texture_lower(bi)))\n           || any(greaterThanEqual(pb, body_texture_upper(bi)))) b = uvec4(0);\n    }\n\n    ivec3 form_pos = pos+body_form_origin(bi);\n    uint form_voxel = 0;\n    if(all(greaterThanEqual(form_pos, body_form_lower(bi))) && all(lessThan(form_pos, body_form_upper(bi))))\n        form_voxel = texelFetch(form_materials, form_pos, 0).r;\n\n    int spawned_cell = 0;\n\n    uint temp = temp(c);\n    uint volt = 0;\n    uint trig = 0;\n\n    uint mid = mat(c); //material id\n    bool is_cell = mid >= BASE_CELL_MAT;\n    if(is_cell) mid += body_cell_material_id(bi);\n\n    for(int i = 0; i < n_triggers(mid); i++)\n    {\n        uint trigger_data = trigger_info(mid, i);\n        uint condition_type = trigger_data&0xFF;\n        uint action_type = (trigger_data>>8)&0xFF;\n        uint trigger_material = trigger_data>>16;\n        bool condition = false;\n        switch(condition_type)\n        {\n            case trig_always:\n                condition = true;\n                break;\n            case trig_hot:\n                condition = temp > 12;\n                break;\n            case trig_cold:\n                condition = temp <= 4;\n                break;\n            case trig_electric:\n                condition = volt > 0;\n                break;\n            case trig_contact:\n                condition = trig(c) == i;\n                break;\n            default:\n                condition = false;\n        }\n\n        if(condition)\n        {\n            switch(action_type)\n            {\n                case act_grow: {\n                    trig = i+1;\n                    break;\n                }\n                case act_die: {\n                    c = uvec4(0);\n                    break;\n                }\n                case act_heat: {\n                    temp++;\n                    break;\n                }\n                case act_chill: {\n                    temp--;\n                    break;\n                }\n                case act_electrify: {\n                    volt = 3;\n                    break;\n                }\n                case act_explode: {\n                    //TODO: EXPLOSIONS!\n                    break;\n                }\n                case act_spray: {\n                    //create particle of type child_material_id, with velocity in the normal direction\n                    break;\n                }\n                default:\n            }\n            break;\n        }\n    }\n\n    //check if this cell is empty, on the surface, and is filled in the body map\n    //then check for neighbors that are trying to grow\n    if(body_is_mutating(bi)==1 && mid != form_voxel)\n    {\n        c = uvec4(0);\n    }\n\n    vec3 voxel_pos = pos-body_texture_lower(bi)-body_x_cm(bi)+0.5;\n\n    //TODO: seed this in a way that is independent of internal engine variables, use displacement from nucleus or something\n    // int grow_phase = int(length(voxel_pos));\n    uint grow_phase = rand(rand(rand(pos.z)+pos.y)+pos.x);\n\n    if(mid != form_voxel && form_voxel != 0 && depth(c) == 0 && (frame_number+grow_phase)%growth_time(form_voxel) == 0)\n    {\n        c.r = form_voxel;\n    }\n    else if(mid == 0 && all(greaterThan(pos-origin, ivec3(0))) && all(lessThan(pos-origin, ivec3(32-1))))\n    {\n        uvec4 growing_cell = uvec4(0);\n        if(trig(l) != 0)      growing_cell = l;\n        else if(trig(r) != 0) growing_cell = r;\n        else if(trig(u) != 0) growing_cell = u;\n        else if(trig(d) != 0) growing_cell = d;\n        else if(trig(f) != 0) growing_cell = f;\n        else if(trig(b) != 0) growing_cell = b;\n\n        uint growing_mat = mat(growing_cell); //material id\n        if(growing_mat != 0)\n        {\n            bool is_cell = growing_mat >= BASE_CELL_MAT;\n            if(is_cell) growing_mat += body_cell_material_id(bi);\n\n            uint trigger_data = trigger_info(growing_mat, trig(growing_cell)-1);\n            uint condition_type = trigger_data&0xFF;\n            uint action_type = (trigger_data>>8)&0xFF;\n            uint trigger_material = trigger_data>>16;\n\n            if(action_type == act_grow)\n                c.r = mat(growing_cell)+1;\n            else\n                c.r = trigger_material;\n        }\n    }\n\n    vec3 voxel_x = apply_rotation(body_orientation(bi), voxel_pos)+body_x(bi);\n    //TODO: apply pushback force\n    for(int be = 0; be < n_beams; be++)\n    {\n        vec3 delta = voxel_x-beam_x(be);\n        vec3 dhat = normalize(beam_d(be));\n        float d = clamp(dot(dhat, delta), 0.0, length(beam_d(be)));\n        vec3 nearest_x = d*dhat+beam_x(be);\n        vec3 r = voxel_x-nearest_x;\n        if(dot(r, r) <= sq(beams[be].r))\n        {\n            temp = clamp(temp+100, 0u, 255u);\n        }\n    }\n\n    if(float(temp) > melting_point(mat(c))) c.r = 0;\n    if(float(temp) > boiling_point(mat(c))) c.r = 0;\n\n    if(mat(c) == 0) temp = room_temp;\n\n    uvec4 out_voxel = c;\n\n    int depth = MAX_DEPTH-1;\n    bool filledness = mat(c) != 0;\n    if(((mat(u) != 0) != filledness) ||\n       ((mat(d) != 0) != filledness) ||\n       ((mat(r) != 0) != filledness) ||\n       ((mat(l) != 0) != filledness) ||\n       ((mat(f) != 0) != filledness) ||\n       ((mat(b) != 0) != filledness)) depth = 0;\n    else\n    {\n        depth = min(depth, depth(u)+1);\n        depth = min(depth, depth(d)+1);\n        depth = min(depth, depth(r)+1);\n        depth = min(depth, depth(l)+1);\n        depth = min(depth, depth(f)+1);\n        depth = min(depth, depth(b)+1);\n    }\n\n    out_voxel.g = uint(depth);\n\n    out_voxel.b = temp;\n\n    out_voxel.a = volt | (trig << 4);\n\n    //check 2x2x2 to determine if this corner is on the boundary\n    bool inside = false;\n    bool outside = false;\n    uvec4 corner_voxel = uvec4(0);\n    //TODO: better way of deciding the corner voxel when there are multiple\n    for(int z = 0; z < 2; z++)\n        for(int y = 0; y < 2; y++)\n            for(int x = 0; x < 2; x++)\n            {\n                ivec3 p = ivec3(pos.x-x, pos.y-y, pos.z-z);\n                uvec4 vox;\n                if(any(lessThan(p, body_texture_lower(bi)+body_lower(bi))) || any(greaterThanEqual(p, body_texture_lower(bi)+body_upper(bi))))\n                    vox = uvec4(0);\n                else\n                    vox = texelFetch(body_materials, p, 0);\n                if(mat(vox) != 0 && (body_fragment_id(bi) == 0 || floodfill(vox) == body_fragment_id(bi)))\n                {\n                    inside = true;\n                    corner_voxel = vox;\n                }\n                else\n                {\n                    outside = true;\n                }\n            }\n\n    if(inside && outside)\n    {\n        vec3 body_coord = pos-body_texture_lower(bi);\n        vec3 r = body_coord-body_x_cm(bi);\n\n        vec3 world_coord = apply_rotation(body_orientation(bi), r)+body_x(bi);\n\n        ivec3 wvc = ivec3(world_coord); //world_voxel_coord\n        uvec4 world_voxel = texelFetch(materials, wvc, 0);\n\n        // if(mat(world_voxel) != 0 && (phase(world_voxel) == phase_solid || phase(world_voxel) == phase_sand))\n        if(mat(world_voxel) != 0)\n        {\n            vec3 normal = unnormalized_gradient(materials, wvc);\n            normal = normalize(normal);\n            vec3 nsign = sign(normal);\n            vec3 nabs = normal*nsign;\n\n            vec3 main_dir = step(nabs.yzx, nabs.xyz)*step(nabs.zyx, nabs.xyz);\n            vec3 adjusted_world_coord = mix(world_coord, nsign*ceil(nsign*world_coord), main_dir);\n\n            add_contact(bi, -1, corner_voxel, world_voxel, body_coord, adjusted_world_coord, normal, phase(world_voxel));\n        }\n\n        ivec3 cell_coord = ivec3(world_coord/collision_cell_size);\n        cell_coord = clamp(cell_coord, 0, collision_cells_per_axis);\n\n        collision_cell cell = collision_grid[cell_coord.x+collision_cells_per_axis*(cell_coord.y+collision_cells_per_axis*cell_coord.z)];\n\n        for(int ci = cell.first_index; ci < cell.first_index+cell.n_bodies; ci++)\n        {\n            int bi1 = collision_indices[ci];\n        // for(int bi1 = 0; bi1 < n_bodies; bi1++)\n        // {\n            if(bi1 == bi || body_is_substantial(bi) == 0 || body_fragment_id(bi)!=1 || body_fragment_id(bi1)!=1 || (body_brain_id(bi) != 0 && (body_brain_id(bi1) == body_brain_id(bi)))) continue;\n            //working in the frame of body bi1\n            vec4 rel_orientation = qmult(conjugate(body_orientation(bi1)), body_orientation(bi));\n            vec3 rel_x = apply_rotation(conjugate(body_orientation(bi1)), body_x(bi)-body_x(bi1));\n            vec3 body1_coord = apply_rotation(rel_orientation, r)+rel_x+body_x_cm(bi1);\n\n            ivec3 body1_pos = ivec3(body1_coord);\n            if(any(lessThan(body1_pos, body_lower(bi1))) || any(greaterThanEqual(body1_pos, body_upper(bi1)))) continue;\n            ivec3 pos1 = body1_pos+body_texture_lower(bi1);\n            uvec4 body1_voxel = texelFetch(body_materials, pos1, 0);\n\n            if(mat(body1_voxel) != 0)\n            {\n                vec3 normal = unnormalized_gradient(body_materials, pos1);\n                normal = normalize(normal);\n                vec3 nsign = sign(normal);\n                vec3 nabs = normal*nsign;\n                normal = apply_rotation(body_orientation(bi1), normal);\n\n                vec3 main_dir = step(nabs.yzx, nabs.xyz)*step(nabs.zyx, nabs.xyz);\n                vec3 adjusted_body1_coord = mix(body1_coord, nsign*ceil(nsign*body1_coord), main_dir);\n\n                add_contact(bi, bi1, corner_voxel, body1_voxel, body_coord, adjusted_body1_coord, normal, phase_solid);\n                break;\n            }\n        }\n    }\n\n    imageStore(body_materials_out, pos, out_voxel);\n}\n"; glShaderSource(simulate_body_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_body_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_body_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_body_program, simulate_body_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_body_program);glDetachShader(simulate_body_program, simulate_body_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_body_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_body_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_physics_program = glCreateProgram(); assert(simulate_body_physics_program, "could not create simulate_body_physics_program, GL error", glGetError());
 GLuint simulate_body_physics_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_body_physics_program_GL_COMPUTE_SHADER, "could not create simulate_body_physics_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3, rgba8ui) restrict uniform uimage3D body_materials;\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int texture_lower_x; int texture_lower_y; int texture_lower_z;\n    int texture_upper_x; int texture_upper_y; int texture_upper_z;\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n    int form_offset_x; int form_offset_y; int form_offset_z;\n    int form_origin_x; int form_origin_y; int form_origin_z;\n    int form_lower_x; int form_lower_y; int form_lower_z;\n    int form_upper_x; int form_upper_y; int form_upper_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float old_x_x; float old_x_y; float old_x_z;\n    float old_orientation_r; float old_orientation_x; float old_orientation_y; float old_orientation_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    int boxl_x; int boxl_y; int boxl_z;\n    int boxu_x; int boxu_y; int boxu_z;\n\n    int cell_material_id;\n    int is_mutating;\n    int substantial;\n    int fragment_id;\n\n    int brain_id;\n};\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nivec3 body_texture_lower(int b)\n{\n    return ivec3(bodies[b].texture_lower_x, bodies[b].texture_lower_y, bodies[b].texture_lower_z);\n}\n\nivec3 body_texture_upper(int b)\n{\n    return ivec3(bodies[b].texture_upper_x, bodies[b].texture_upper_y, bodies[b].texture_upper_z);\n}\n\nivec3 body_lower(int b)\n{\n    return ivec3(bodies[b].lower_x, bodies[b].lower_y, bodies[b].lower_z);\n}\n\nivec3 body_upper(int b)\n{\n    return ivec3(bodies[b].upper_x, bodies[b].upper_y, bodies[b].upper_z);\n}\n\nivec3 body_form_offset(int b)\n{\n    return ivec3(bodies[b].form_offset_x, bodies[b].form_offset_y, bodies[b].form_offset_z);\n}\nvec3 body_x_cm(int b)\n{\n    return vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n}\n\nvec3 body_x(int b)\n{\n    return vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n}\n\nvec3 body_x_dot(int b)\n{\n    return vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n}\n\nvec4 body_orientation(int b)\n{\n    return vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n}\n\nvec3 body_omega(int b)\n{\n    return vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n}\n\nvec3 body_old_x(int b)\n{\n    return vec3(bodies[b].old_x_x, bodies[b].old_x_y, bodies[b].old_x_z);\n}\n\nvec4 body_old_orientation(int b)\n{\n    return vec4(bodies[b].old_orientation_r, bodies[b].old_orientation_x, bodies[b].old_orientation_y, bodies[b].old_orientation_z);\n}\n\nfloat body_m(int b)\n{\n    return bodies[b].m;\n}\n\nmat3 body_I(int b)\n{\n    return mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n}\n\nmat3 body_invI(int b)\n{\n    return mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\nvec3 body_boxl(int b)\n{\n    return vec3(bodies[b].boxl_x, bodies[b].boxl_y, bodies[b].boxl_z);\n}\n\nvec3 body_boxu(int b)\n{\n    return vec3(bodies[b].boxu_x, bodies[b].boxu_y, bodies[b].boxu_z);\n}\n\nivec3 body_form_origin(int b)\n{\n    return ivec3(bodies[b].form_origin_x, bodies[b].form_origin_y, bodies[b].form_origin_z);\n}\n\nivec3 body_form_lower(int b)\n{\n    return ivec3(bodies[b].form_lower_x, bodies[b].form_lower_y, bodies[b].form_lower_z);\n}\n\nivec3 body_form_upper(int b)\n{\n    return ivec3(bodies[b].form_upper_x, bodies[b].form_upper_y, bodies[b].form_upper_z);\n}\n\nint body_cell_material_id(int b)\n{\n    return bodies[b].cell_material_id;\n}\n\nint body_is_mutating(int b)\n{\n    return bodies[b].is_mutating;\n}\n\nint body_is_substantial(int b)\n{\n    return bodies[b].substantial;\n}\n\nint body_fragment_id(int b)\n{\n    return bodies[b].fragment_id;\n}\n\nint body_brain_id(int b)\n{\n    return bodies[b].brain_id;\n}\n\n#define BODY_UPDATE_DATA_BINDING 1\n#ifndef BODY_UPDATE_DATA_BINDING\n#define BODY_UPDATE_DATA_BINDING 0\n#endif\n\nstruct body_update\n{\n    float m;\n    float I_xx;\n    float I_xy; float I_yy;\n    float I_xz; float I_yz; float I_zz;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n\n    int fragment_index;\n    int n_fragments;\n};\n\nlayout(std430, binding = BODY_UPDATE_DATA_BINDING) buffer body_update_data\n{\n    body_update body_updates[];\n};\n\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n\nivec3 find_unfilled(int b, ivec3 lower, ivec3 upper)\n{\n    for(int z = lower.z; z < upper.z; z+=1)\n        for(int y = lower.y; y < upper.y; y+=1)\n            for(int x = lower.x; x < upper.x; x+=1)\n            {\n                ivec3 body_coord = ivec3(x, y, z);\n                ivec3 pos = body_coord+body_texture_lower(b);\n                uvec4 body_voxel = imageLoad(body_materials, pos);\n                if(floodfill(body_voxel) == 0 && mat(body_voxel) != 0)\n                {\n                    return body_coord;\n                }\n            }\n    return ivec3(-1,-1,-1);\n}\n\n// void find_collision_points(int ai, int bi)\n// {\n//     n_collision_points = 0;\n\n//     vec3 al = body_boxl(ai);\n//     vec3 au = body_boxu(ai);\n//     vec3 bl = body_boxl(bi);\n//     vec3 bu = body_boxu(bi);\n\n//     vec4 aorientation = body_orientation(ai);\n//     vec4 borientation = body_orientation(bi);\n\n//     vec4 rel_orientation = qmult(conjugate(aorientation), borientation);\n\n//     vec3 a_to_borigin = apply_rotation(conjugate(aorientation), body_x(bi)-body_x(ai)+apply_rotation(borientation, -body_x_cm(bi)));\n\n//     //TODO: maybe use space filling curves\n//     for(int test_z = body_lower(bi).z; test_z < body_upper(bi).z; test_z+=1)\n//         for(int test_y = body_lower(bi).y; test_y < body_upper(bi).y; test_y+=1)\n//             for(int test_x = body_lower(bi).x; test_x < body_upper(bi).x; test_x+=1)\n//             {\n//                 vec3 b_coord = vec3(test_x, test_y, test_z);\n//                 vec3 a_coord = a_to_borigin+apply_rotation(rel_orientation, b_coord);\n\n//                 ivec3 ib_coord = ivec3(test_x, text_y, test_z);\n//                 ivec3 ia_coord = ivec3(a_coord);\n\n//                 if(any(lessThan(ia_coord, ivec3(0)) || any greaterThanEqual(ia_coord, body_upper(ai)))) continue;\n\n//                 uvec4 a_voxel = texelFetch(body_materials, body_texture_lower(ai)+a_coord, 0);\n//                 uvec4 b_voxel = texelFetch(body_materials, body_texture_lower(bi)+b_coord, 0);\n\n//                 if(signed_depth(a_voxel) == 0 && signed_depth(b_bvoxel))\n//                 {\n//                     ivec3 wvc = ivec3(world_coord); //world_voxel_coord\n//                     uvec4 world_voxel = texelFetch(materials, wvc, 0);\n//                     vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n//                     // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n//                     if(signed_depth(world_voxel) <= 0)\n//                     {\n//                         world_collision_points[n_collision_points] = world_coord;\n//                         world_collision_coord[n_collision_points] = wvc;\n//                         n_collision_points++;\n//                         if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n//                     }\n\n//                     // for(int wz = 0; wz <= 1; wz++)\n//                     //     for(int wy = 0; wy <= 1; wy++)\n//                     //         for(int wx = 0; wx <= 1; wx++)\n//                     //         {\n//                     //             ivec3 wvc = ivec3(world_coord-0.5)+ivec3(wx,wy,wz); //world_voxel_coord\n//                     //             ivec4 world_voxel = voxelFetch(materials, wvc);\n//                     //             vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n//                     //             // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n//                     //             if(world_voxel.g <= 2)\n//                     //             {\n//                     //                 world_collision_points[n_collision_points] = world_coord;\n//                     //                 world_collision_coord[n_collision_points] = wvc;\n//                     //                 n_collision_points++;\n//                     //                 if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n//                     //             }\n//                     //         }\n//                 }\n\n//                 test_x += max(abs(signed_depth(b_voxel))-1, 0);\n//             }\n// }\n\nvoid main()\n{\n    int b = int(gl_GlobalInvocationID.x);\n\n    float m = 0;\n    float I_xx = 0;\n    float I_xy = 0; float I_yy = 0;\n    float I_xz = 0; float I_yz = 0; float I_zz = 0;\n    vec3 x_cm = vec3(0);\n\n    const int padding = 1;\n\n    ivec3 lower = max(body_lower(b)-padding, 0);\n    ivec3 upper = min(body_upper(b)+padding, body_texture_upper(b)-body_texture_lower(b));\n\n    int total_voxels = 0;\n\n    ivec3 new_body_lower = ivec3(1000);\n    ivec3 new_body_upper = ivec3(0);\n\n    for(int test_z = lower.z; test_z < upper.z; test_z+=1)\n        for(int test_y = lower.y; test_y < upper.y; test_y+=1)\n            for(int test_x = lower.x; test_x < upper.x; test_x+=1)\n            {\n                ivec3 body_coord = ivec3(test_x, test_y, test_z);\n                vec3 r = (vec3(body_coord)+0.5);\n                ivec3 pos = body_coord+body_texture_lower(b);\n\n                uvec4 body_voxel = imageLoad(body_materials, pos);\n                if(mat(body_voxel) != 0)\n                {\n                    total_voxels++;\n\n                    float rho = density(mat(body_voxel));\n                    m += rho;\n                    x_cm += rho*r;\n\n                    float diag = (1.0/6.0)+dot(r, r);\n                    I_xx += rho*(diag-r.x*r.x);\n                    I_yy += rho*(diag-r.y*r.y);\n                    I_zz += rho*(diag-r.z*r.z);\n                    I_xy += -rho*(r.x*r.y);\n                    I_xz += -rho*(r.x*r.z);\n                    I_yz += -rho*(r.y*r.z);\n\n                    new_body_lower = min(new_body_lower, body_coord);\n                    new_body_upper = max(new_body_upper, body_coord+1);\n                }\n            }\n    x_cm /= m;\n    new_body_lower = min(new_body_lower, new_body_upper);\n\n    body_updates[b].m    =    m;\n    body_updates[b].I_xx = I_xx;\n    body_updates[b].I_yy = I_yy;\n    body_updates[b].I_zz = I_zz;\n    body_updates[b].I_xy = I_xy;\n    body_updates[b].I_xz = I_xz;\n    body_updates[b].I_yz = I_yz;\n    body_updates[b].x_cm_x = x_cm.x;\n    body_updates[b].x_cm_y = x_cm.y;\n    body_updates[b].x_cm_z = x_cm.z;\n\n    body_updates[b].lower_x = new_body_lower.x;\n    body_updates[b].lower_y = new_body_lower.y;\n    body_updates[b].lower_z = new_body_lower.z;\n    body_updates[b].upper_x = new_body_upper.x;\n    body_updates[b].upper_y = new_body_upper.y;\n    body_updates[b].upper_z = new_body_upper.z;\n\n    #define max_stack_size 1024\n    ivec3 search_stack[max_stack_size];\n    int stack_size = 0;\n\n    int floodfilled_voxels = 0;\n\n    int current_fragment_id = 0;\n\n    int n_new_fragments = 0;\n\n    #define N_MAX_FRAGMENTS 7\n    //TODO: better handling for going over the max, currently additional fragments just get deleted\n    for(int i = 0; i < N_MAX_FRAGMENTS; i++)\n    {\n        current_fragment_id = n_new_fragments+1;\n\n        ivec3 new_seed = find_unfilled(b, lower, upper);\n        if(new_seed.x < 0) break;\n        search_stack[stack_size++] = new_seed;\n\n        ivec3 fragment_lower = ivec3(1000);\n        ivec3 fragment_upper = ivec3(0);\n\n        while(stack_size > 0)\n        {\n            ivec3 body_coord = search_stack[--stack_size];\n            ivec3 pos = body_coord+body_texture_lower(b);\n            uvec4 body_voxel = imageLoad(body_materials, pos);\n            body_voxel.g |= current_fragment_id<<5;\n            imageStore(body_materials, pos, body_voxel);\n\n            fragment_lower = min(fragment_lower, body_coord);\n            fragment_upper = max(fragment_upper, body_coord+1);\n\n            floodfilled_voxels++;\n\n            ivec3 r_coord = body_coord+ivec3(+1,0,0);\n            ivec3 l_coord = body_coord+ivec3(-1,0,0);\n            ivec3 f_coord = body_coord+ivec3(0,+1,0);\n            ivec3 b_coord = body_coord+ivec3(0,-1,0);\n            ivec3 u_coord = body_coord+ivec3(0,0,+1);\n            ivec3 d_coord = body_coord+ivec3(0,0,-1);\n\n            ivec3 r_pos = pos+ivec3(+1,0,0);\n            ivec3 l_pos = pos+ivec3(-1,0,0);\n            ivec3 f_pos = pos+ivec3(0,+1,0);\n            ivec3 b_pos = pos+ivec3(0,-1,0);\n            ivec3 u_pos = pos+ivec3(0,0,+1);\n            ivec3 d_pos = pos+ivec3(0,0,-1);\n\n            uvec4 r_vox = imageLoad(body_materials, r_pos);\n            uvec4 l_vox = imageLoad(body_materials, l_pos);\n            uvec4 f_vox = imageLoad(body_materials, f_pos);\n            uvec4 b_vox = imageLoad(body_materials, b_pos);\n            uvec4 u_vox = imageLoad(body_materials, u_pos);\n            uvec4 d_vox = imageLoad(body_materials, d_pos);\n\n            if(floodfill(r_vox) == 0 && mat(r_vox) != 0 && stack_size < max_stack_size) search_stack[stack_size++] = r_coord;\n            if(floodfill(l_vox) == 0 && mat(l_vox) != 0 && stack_size < max_stack_size) search_stack[stack_size++] = l_coord;\n            if(floodfill(f_vox) == 0 && mat(f_vox) != 0 && stack_size < max_stack_size) search_stack[stack_size++] = f_coord;\n            if(floodfill(b_vox) == 0 && mat(b_vox) != 0 && stack_size < max_stack_size) search_stack[stack_size++] = b_coord;\n            if(floodfill(u_vox) == 0 && mat(u_vox) != 0 && stack_size < max_stack_size) search_stack[stack_size++] = u_coord;\n            if(floodfill(d_vox) == 0 && mat(d_vox) != 0 && stack_size < max_stack_size) search_stack[stack_size++] = d_coord;\n        }\n\n        if(fragment_lower.x != 1000)\n        {\n            n_new_fragments++;\n        }\n    }\n\n    body_updates[b].n_fragments = n_new_fragments;\n\n    // if(n_new_fragments > 0)\n    // {\n    //     int fragment_index = atomicAdd(n_fragments, n_new_fragments);\n\n    //     body_updates[b].fragment_index = fragment_index;\n\n    //     for(int f = 0; f < n_new_fragments; f++)\n    //     {\n    //         fragments[fragment_index+f] = new_fragments[f];\n    //     }\n    // }\n}\n"; glShaderSource(simulate_body_physics_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_body_physics_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_body_physics_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_physics_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_physics_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_body_physics_program, simulate_body_physics_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_body_physics_program);glDetachShader(simulate_body_physics_program, simulate_body_physics_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_body_physics_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_body_physics_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_physics_program, available_memory, 0, info_log); log_error(info_log); }simulate_chunk_atomic_program = glCreateProgram(); assert(simulate_chunk_atomic_program, "could not create simulate_chunk_atomic_program, GL error", glGetError());
 GLuint simulate_chunk_atomic_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, "could not create simulate_chunk_atomic_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\n#define localgroup_size 8\n#define subgroup_size 2\nlayout(local_size_x = localgroup_size, local_size_y = localgroup_size, local_size_z = localgroup_size) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3, rgba8ui) uniform uimage3D materials_out;\nlayout(location = 4) uniform usampler3D active_regions_in;\nlayout(location = 5) uniform writeonly uimage3D active_regions_out;\nlayout(location = 6) uniform writeonly uimage3D occupied_regions_out;\nlayout(location = 7) uniform int update_cells;\nlayout(location = 8) uniform int n_explosions;\nlayout(location = 9) uniform int n_beams;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool is_visual;\n    bool die_on_collision;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    int n_alive_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n#define EXPLOSION_DATA_BINDING 1\n#ifndef EXPLOSION_DATA_BINDING\n#define EXPLOSION_DATA_BINDING 0\n#endif\n\nstruct explosion\n{\n    float x; float y; float z;\n    float r;\n    float strength;\n};\n\nlayout(std430, binding = EXPLOSION_DATA_BINDING) buffer explosion_data\n{\n    explosion explosions[];\n};\n\nvec3 explosion_x(int e)\n{\n    return vec3(explosions[e].x, explosions[e].y, explosions[e].z);\n}\n\n#define BEAM_DATA_BINDING 2\n#ifndef BEAM_DATA_BINDING\n#define BEAM_DATA_BINDING 0\n#endif\n\nstruct beam\n{\n    float x; float y; float z;\n    float dx; float dy; float dz;\n    float r;\n    float max_length;\n    float strength;\n};\n\nlayout(std430, binding = BEAM_DATA_BINDING) buffer beam_data\n{\n    beam beams[];\n};\n\nvec3 beam_x(int e)\n{\n    return vec3(beams[e].x, beams[e].y, beams[e].z);\n}\n\nvec3 beam_d(int e)\n{\n    return vec3(beams[e].dx, beams[e].dy, beams[e].dz);\n}\n\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nuint conduction_dir(ivec3 pos)\n{\n    return rand(rand(frame_number+rand(rand(rand(pos.z)+pos.y)+pos.x)))%6;\n}\n\nbool c_active = false;\nbool u_active = false;\nbool d_active = false;\nbool r_active = false;\nbool l_active = false;\nbool f_active = false;\nbool b_active = false;\n\nvoid simulate_voxel(ivec3 pos, ivec3 rpos)\n{\n    ivec3 cell_p = pos%16;\n    // ivec3 cell_p = gl_LocalInvocationID.xyz;\n    // ivec3 rpos = gl_WorkGroupID.xyz;\n\n    if(cell_p == ivec3(0,0,0)) imageStore(occupied_regions_out, rpos, uvec4(0,0,0,0));\n\n    uvec4 c  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z),0);\n    uvec4 old_voxel  = c;\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    // uint rot = rand(rand(rand(frame_number)))%4;\n    uint flow = flow(c);\n    int i = 0;\n    ivec2 dir = ivec2(((flow&1)*(2-flow)), (1-(flow&1))*(1-flow)); //(0,1), (1,0), (0,-1), (-1,0)\n\n    ivec3 pu = ivec3(pos.x, pos.y, pos.z+1);\n    ivec3 pd = ivec3(pos.x, pos.y, pos.z-1);\n    ivec3 pr = ivec3(pos.x+dir.x, pos.y+dir.y, pos.z);\n    ivec3 pl = ivec3(pos.x-dir.x, pos.y-dir.y, pos.z);\n    ivec3 pf = ivec3(pos.x-dir.y, pos.y+dir.x, pos.z);\n    ivec3 pb = ivec3(pos.x+dir.y, pos.y-dir.x, pos.z);\n\n    uvec4 u  = texelFetch(materials, pu, 0);\n    uvec4 d  = texelFetch(materials, pd, 0);\n    uvec4 r  = texelFetch(materials, pr, 0);\n    uvec4 l  = texelFetch(materials, pl, 0);\n    uvec4 f  = texelFetch(materials, pf, 0);\n    uvec4 b  = texelFetch(materials, pb, 0);\n\n    uvec4 dr = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z-1),0);\n    uvec4 ur = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z+1),0);\n\n    uvec4 df = texelFetch(materials, ivec3(pos.x-dir.y, pos.y+dir.x, pos.z-1),0);\n    uvec4 db = texelFetch(materials, ivec3(pos.x+dir.y, pos.y-dir.x, pos.z-1),0);\n\n    uvec4 ldf = texelFetch(materials, ivec3(pl.x-dir.y, pl.y+dir.x, pl.z-1),0);\n    uvec4 ldb = texelFetch(materials, ivec3(pl.x+dir.y, pl.y-dir.x, pl.z-1),0);\n\n    uvec4 ul = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z+1),0);\n    uvec4 ll = texelFetch(materials, ivec3(pos.x-2*dir.x, pos.y-2*dir.y, pos.z),0);\n    uvec4 dl = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z-1),0);\n\n    uvec4 uu = texelFetch(materials, ivec3(pos.x, pos.y, pos.z+2),0);\n\n    if(update_cells == 1 && frame_number != 0)\n    {\n        if(mat(c) == 0)\n        { //central cell is empty\n\n            //check if upper cell fell           , liquids and sands\n            //then check if upper left cell fell , liquids and sands\n            //then check if left cell flowed     , liquids\n            if(mat(u) != 0 && phase(u) >= phase_sand && transient(u)==0)\n                c = u;\n            else if(mat(ul) != 0 && mat(l) != 0 && mat(u) == 0 && phase(ul) >= phase_sand && flow(ul) == flow && transient(ul)==0)\n                c = ul;\n            else if(mat(l) != 0 && mat(dl) != 0 && mat(d) != 0 && mat(ldf) != 0 && mat(ldb) != 0 && (phase(d) >= phase_liquid || phase(dl) >= phase_liquid) && phase(l) == phase_liquid && flow(l) == flow && transient(l)==0)\n                c = l;\n            else if(mat(d) != 0 && phase(d) == phase_gas && transient(d)==0)\n                c = d;\n            else if(mat(dl) != 0 && mat(l) != 0 && mat(d) == 0 && phase(dl) == phase_gas && flow(dl) == flow && transient(dl)==0)\n                c = dl;\n            else if(mat(l) != 0 && mat(ul) != 0 && mat(u) != 0 && phase(l) == phase_gas && flow(l) == flow && transient(l)==0)\n                c = l;\n            else\n            {\n                // flow = rand(rand(rand(frame_number+pos.x+pos.y+pos.z)))%4;\n                // flow = (frame_number)%4;\n                flow = rand(871841735+frame_number)%4;\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 l = texelFetch(materials, ivec3(pos.x-test_dir.x, pos.y-test_dir.y, pos.z),0);\n                    if(mat(l) != 0 && flow(l) == fl && phase(l) >= phase_sand)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 ul = texelFetch(materials, ivec3(pos.x-test_dir.x, pos.y-test_dir.y, pos.z-1),0);\n                    if(mat(ul) != 0 && flow(ul) == fl && phase(ul) >= phase_liquid)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n            }\n            //might be better to multiply things by 0 instead of branching\n        }\n        else if(phase(c) != phase_solid && transient(c)==0)\n        { //if the cell is not empty and not solid check if it fell or flew\n            bool fall_allowed = (pos.z > 0 && (mat(d) == 0 || (mat(dr) == 0 && mat(r) == 0 && flow(dr) == flow)) && phase(c) >= phase_sand);\n            bool flow_allowed = (pos.z > 0 && mat(r) == 0\n                                 && (mat(ur) == 0 || phase(ur) < phase_sand || flow(ur) != flow)\n                                 && mat(df) != 0 && mat(db) != 0\n                                 && (mat(u) == 0 || phase(u) < phase_sand)\n                                 && (phase(dr) >= phase_liquid || phase(d) >= phase_liquid) && phase(c) == phase_liquid && flow(r) == flow);\n\n            bool float_allowed = (pos.z < 511 && (mat(u) == 0 || (mat(ur) == 0 && mat(r) == 0 && flow(ur) == flow)) && phase(c) == phase_gas && (mat(uu) == 0 || (phase(uu) <= phase_solid)));\n\n            bool gas_flow_allowed = (pos.z > 0 && mat(r) == 0\n                                     && mat(ur) != 0 && mat(u) != 0\n                                     && (mat(dr) == 0 || phase(dr) < phase_sand || flow(dr) != flow)\n                                     && (mat(d) == 0 || phase(d) < phase_sand)\n                                     && phase(c) == phase_gas && flow(r) == flow);\n\n            if(fall_allowed || flow_allowed || float_allowed || gas_flow_allowed) c = uvec4(0);\n            else\n            {\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 r = texelFetch(materials, ivec3(pos.x+test_dir.x, pos.y+test_dir.y, pos.z),0);\n                    if(mat(r) == 0)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 dr = texelFetch(materials, ivec3(pos.x+test_dir.x, pos.y+test_dir.y, pos.z-1),0);\n                    if(mat(dr) == 0)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    int depth = MAX_DEPTH-1;\n    uint solidity = solidity(c);\n    if((solidity(u) != solidity) ||\n       (solidity(d) != solidity) ||\n       (solidity(r) != solidity) ||\n       (solidity(l) != solidity) ||\n       (solidity(f) != solidity) ||\n       (solidity(b) != solidity)) depth = 0;\n    else\n    {\n        depth = min(depth, depth(u)+1);\n        depth = min(depth, depth(d)+1);\n        depth = min(depth, depth(r)+1);\n        depth = min(depth, depth(l)+1);\n        depth = min(depth, depth(f)+1);\n        depth = min(depth, depth(b)+1);\n    }\n\n    int volt = int(volt(c));\n\n    if(conductivity(mat(c)) > 0)\n    {\n        uint cd = conduction_dir(pos);\n        int dvolt = 0;\n        int nvolt = volt;\n        int neighbors = 0;\n        if(mat(r)!=0 && conductivity(mat(r))>0){if(volt(r)>0)neighbors++; nvolt = max(nvolt, int(volt(r)));}\n        if(mat(l)!=0 && conductivity(mat(l))>0){if(volt(l)>0)neighbors++; nvolt = max(nvolt, int(volt(l)));}\n        if(mat(u)!=0 && conductivity(mat(u))>0){if(volt(u)>0)neighbors++; nvolt = max(nvolt, int(volt(u)));}\n        if(mat(d)!=0 && conductivity(mat(d))>0){if(volt(d)>0)neighbors++; nvolt = max(nvolt, int(volt(d)));}\n        if(mat(f)!=0 && conductivity(mat(f))>0){if(volt(f)>0)neighbors++; nvolt = max(nvolt, int(volt(f)));}\n        if(mat(b)!=0 && conductivity(mat(b))>0){if(volt(b)>0)neighbors++; nvolt = max(nvolt, int(volt(b)));}\n        dvolt = nvolt-volt;\n        if((rand(frame_number+rand(rand(rand(pos.z)+pos.y)+pos.x))%7)!=0) dvolt--;\n        // if(volt <= 8 && neighbors == 0) dvolt--;\n        if(dvolt > 0 && neighbors > 1) dvolt = 0;\n        volt = volt+dvolt;\n        volt = clamp(volt, 0, 15);\n    }\n    else\n    {\n        volt = 0;\n    }\n    if(frame_number == 0) volt = 0;\n\n    uint temp = temp(c);\n    // if(mat(c) == 4) temp = 255; else\n    if(mat(c) != 0)\n    {\n        float C = heat_capacity(mat(c));\n        float Q = 0;\n        //NOTE: this would save some divisions by storing thermal resistivity,\n        //      but it's nicer to define materials in terms of conductivity so 0 has well defined behavior\n        float r_c = 1.0/thermal_conductivity(mat(c));\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(u))); Q += k*(float(temp(u))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(d))); Q += k*(float(temp(d))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(r))); Q += k*(float(temp(r))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(l))); Q += k*(float(temp(l))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(f))); Q += k*(float(temp(f))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(b))); Q += k*(float(temp(b))-float(temp));}\n\n        //NOTE: there might be oscillations due to neighboring temperatures changing past each other,\n        //      but fixing would require each voxel knowing how much heat it's neighbors are getting\n        //      hopefully won't be a problem since everything will eventually converge to room temp\n\n        float dtemp = Q/C;\n        float dtemp_i = round(dtemp);\n        float dtemp_f = 32.0*(dtemp-dtemp_i);\n\n        if(dtemp_f < 0 && dtemp_f > -1.0) dtemp_f = -1.0;\n\n        if((frame_number+rand(rand(rand(rand(pos.z)+pos.y)+pos.x)))%32 < int(abs(dtemp_f))) dtemp_i += sign(dtemp_f);\n        temp = uint(clamp(float(temp)+dtemp_i, 0.0, 255.0));\n\n        // if(avg_temp.x > float(temp)) temp++;\n        // else if(avg_temp.x < float(temp)) temp--;\n    }\n    else temp = room_temp;\n\n    // temp = clamp(temp+abs((volt-int(volt(c)))), 0u, 255u);\n    temp = clamp(temp+volt, 0u, 255u);\n\n    if(mat(c) == 6 && temp < 128) c.r = 0;\n\n    uint phase = phase_solid;\n    if(hardness(mat(c)) == 0.0\n       || (mat(u) == 0 && mat(d) == 0 && mat(r) == 0 && mat(l) == 0 && mat(f) == 0 && mat(b) == 0)) phase = phase_sand;\n    if(float(temp) > melting_point(mat(c))) phase = phase_liquid;\n    if(float(temp) > boiling_point(mat(c))) phase = phase_gas;\n\n    uvec4 out_voxel = c;\n\n    uint transient = transient(out_voxel);\n    if(transient == 1)\n    {\n        out_voxel.r = 0;\n        transient = 0;\n    }\n\n    out_voxel.g = uint(depth) | (phase << 5) | (transient << 7);\n\n    out_voxel.b = temp;\n\n    out_voxel.a = volt | (flow<<4);\n\n    vec3 voxel_x = (vec3(pos)+0.5);\n    for(int e = 0; e < n_explosions; e++)\n    {\n        vec3 r = voxel_x-explosion_x(e);\n        if(dot(r, r) <= sq(explosions[e].r))\n        {\n            if(mat(out_voxel) != 0)\n            {\n                int dead_index = atomicAdd(n_dead_particles, -1)-1;\n                //this assumes particle creation and destruction never happen simutaneously\n                uint p = dead_particles[dead_index];\n                particles[p].voxel_data = out_voxel.r|out_voxel.g<<8|out_voxel.b<<16|out_voxel.a<<24;\n                particles[p].x = voxel_x.x;\n                particles[p].y = voxel_x.y;\n                particles[p].z = voxel_x.z;\n                // vec3 x_dot = normalize(unnormalized_gradient(materials, pos));\n                vec3 x_dot = 2*r/explosions[e].r;\n                particles[p].x_dot = x_dot.x;\n                particles[p].y_dot = x_dot.y;\n                particles[p].z_dot = x_dot.z;\n                particles[p].is_visual = true;\n                particles[p].die_on_collision = true;\n                particles[p].alive = true;\n            }\n\n            out_voxel = uvec4(0);\n        }\n        else if(dot(r, r) <= sq(explosions[e].r+1))\n        {\n            out_voxel.b = clamp(out_voxel.b+100, 0u, 255u);\n        }\n    }\n\n    for(int be = 0; be < n_beams; be++)\n    {\n        vec3 delta = voxel_x-beam_x(be);\n        vec3 dhat = normalize(beam_d(be));\n        float d = clamp(dot(dhat, delta), 0.0, length(beam_d(be)));\n        vec3 nearest_x = d*dhat+beam_x(be);\n        vec3 r = voxel_x-nearest_x;\n        if(dot(r, r) <= sq(beams[be].r))\n        {\n            out_voxel.b = clamp(out_voxel.b+100, 0u, 255u);\n        }\n    }\n\n    bool changed = old_voxel.r != out_voxel.r || old_voxel.g != out_voxel.g || (int(old_voxel.b) != int(out_voxel.b) && out_voxel.b > 128) || out_voxel.b > 130 || volt != volt(old_voxel) || volt > 0;\n    if(changed)\n    {\n        c_active = true;\n        u_active = u_active || cell_p.z>=15;\n        d_active = d_active || cell_p.z<= 0;\n        r_active = r_active || cell_p.y>=15;\n        l_active = l_active || cell_p.y<= 0;\n        f_active = f_active || cell_p.x>=15;\n        b_active = b_active || cell_p.x<= 0;\n    }\n\n    if(out_voxel.r != 0) imageStore(occupied_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n\n    // memoryBarrier();\n    imageStore(materials_out, pos, out_voxel);\n}\n\nvoid main()\n{\n    ivec3 pos = subgroup_size*ivec3(gl_GlobalInvocationID.xyz);\n    ivec3 rpos = pos>>4;\n\n    uint region_active = texelFetch(active_regions_in, rpos, 0).r;\n    if(region_active == 0)\n    {\n        return;\n    }\n\n    for(int x = 0; x < subgroup_size; x++)\n        for(int y = 0; y < subgroup_size; y++)\n            for(int z = 0; z < subgroup_size; z++)\n                simulate_voxel(pos+ivec3(x,y,z), rpos);\n\n    if(c_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y, rpos.z),   uvec4(1,0,0,0));\n    if(u_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y, rpos.z+1), uvec4(1,0,0,0));\n    if(d_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y, rpos.z-1), uvec4(1,0,0,0));\n    if(r_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y+1, rpos.z), uvec4(1,0,0,0));\n    if(l_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y-1, rpos.z), uvec4(1,0,0,0));\n    if(f_active) imageStore(active_regions_out, ivec3(rpos.x+1, rpos.y, rpos.z), uvec4(1,0,0,0));\n    if(b_active) imageStore(active_regions_out, ivec3(rpos.x-1, rpos.y, rpos.z), uvec4(1,0,0,0));\n}\n"; glShaderSource(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_atomic_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_atomic_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_chunk_atomic_program, simulate_chunk_atomic_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_chunk_atomic_program);glDetachShader(simulate_chunk_atomic_program, simulate_chunk_atomic_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_chunk_atomic_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_chunk_atomic_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_chunk_atomic_program, available_memory, 0, info_log); log_error(info_log); }simulate_particles_program = glCreateProgram(); assert(simulate_particles_program, "could not create simulate_particles_program, GL error", glGetError());
 GLuint simulate_particles_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_particles_program_GL_COMPUTE_SHADER, "could not create simulate_particles_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform writeonly uimage3D materials_out;\nlayout(location = 4) uniform writeonly uimage3D active_regions_out;\nlayout(location = 5) uniform writeonly uimage3D occupied_regions_out;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool is_visual;\n    bool die_on_collision;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    int n_alive_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    uint p = gl_GlobalInvocationID.x;\n    if(!particles[p].alive) return;\n    vec3 x = vec3(particles[p].x, particles[p].y, particles[p].z);\n    vec3 x_dot = vec3(particles[p].x_dot, particles[p].y_dot, particles[p].z_dot);\n\n    x += x_dot;\n    x_dot.z -= 0.1;\n    int i = 0;\n    uint transient = 1;\n    uvec4 vox = texelFetch(materials, ivec3(x), 0);\n    if(!particles[p].die_on_collision)\n        while(mat(vox) != 0)\n        {\n            vec3 normal = normalize(unnormalized_gradient(materials, ivec3(x)));\n            if(phase(vox) == phase_liquid) normal = vec3(0,0,1);\n            if(phase(vox) == phase_gas) normal = vec3(0,0,-1);\n            // vec3 normal = vec3(0,0,1);\n            // x += max(0.1f, float(SURF_DEPTH-depth(voxel)))*normal;\n            x += 0.05f*normal;\n            x_dot -= min(dot(x_dot, normal), 0)*normal;\n\n            transient = 0;\n            if(i++ > 50)\n            {\n                break;\n            }\n        }\n\n    particles[p].x = x.x;\n    particles[p].y = x.y;\n    particles[p].z = x.z;\n\n    particles[p].x_dot = x_dot.x;\n    particles[p].y_dot = x_dot.y;\n    particles[p].z_dot = x_dot.z;\n\n    if(!particles[p].is_visual && transient == 0 && mat(texelFetch(materials, ivec3(x), 0)) == 0)\n    {\n        uint v = particles[p].voxel_data;\n        uvec4 particle_voxel_data = uvec4((v&0xF), ((v>>8)&0x7)|(transient<<7), ((v>>16)&0xF), ((v>>24)&0xF)|7);\n        imageStore(materials_out, ivec3(x), particle_voxel_data);\n        imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16), uvec4(1,0,0,0));\n        ivec3 cell_x = ivec3(x)%16;\n        if(cell_x.x==15) imageStore(active_regions_out, ivec3(x.x/16+1, x.y/16, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.x== 0) imageStore(active_regions_out, ivec3(x.x/16-1, x.y/16, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.y==15) imageStore(active_regions_out, ivec3(x.x/16, x.y/16+1, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.y== 0) imageStore(active_regions_out, ivec3(x.x/16, x.y/16-1, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.z==15) imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16+1), uvec4(1,0,0,0));\n        if(cell_x.z== 0) imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16-1), uvec4(1,0,0,0));\n        imageStore(occupied_regions_out, ivec3(x.x/16, x.y/16, x.z/16), uvec4(1,0,0,0));\n\n        particles[p].alive = false;\n        int dead_index = atomicAdd(n_dead_particles, 1);\n        dead_particles[dead_index] = p;\n        return;\n    }\n    if(any(lessThan(x, vec3(0))) || any(greaterThanEqual(x, vec3(512))) || (particles[p].die_on_collision && mat(vox) != 0))\n    {\n        particles[p].alive = false;\n        int dead_index = atomicAdd(n_dead_particles, 1);\n        dead_particles[dead_index] = p;\n        return;\n    }\n}\n"; glShaderSource(simulate_particles_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_particles_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_particles_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_particles_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_particles_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_particles_program, simulate_particles_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_particles_program);glDetachShader(simulate_particles_program, simulate_particles_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_particles_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_particles_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_particles_program, available_memory, 0, info_log); log_error(info_log); }sync_joint_voxels_program = glCreateProgram(); assert(sync_joint_voxels_program, "could not create sync_joint_voxels_program, GL error", glGetError());
 GLuint sync_joint_voxels_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(sync_joint_voxels_program_GL_COMPUTE_SHADER, "could not create sync_joint_voxels_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n\n#define localgroup_size 4\n#define subgroup_size 1\nlayout(local_size_x = localgroup_size, local_size_y = 1, local_size_z = 1) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2, rgba8ui) uniform uimage3D body_materials;\nlayout(location = 3) uniform int n_joints;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int texture_lower_x; int texture_lower_y; int texture_lower_z;\n    int texture_upper_x; int texture_upper_y; int texture_upper_z;\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n    int form_offset_x; int form_offset_y; int form_offset_z;\n    int form_origin_x; int form_origin_y; int form_origin_z;\n    int form_lower_x; int form_lower_y; int form_lower_z;\n    int form_upper_x; int form_upper_y; int form_upper_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float old_x_x; float old_x_y; float old_x_z;\n    float old_orientation_r; float old_orientation_x; float old_orientation_y; float old_orientation_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    int boxl_x; int boxl_y; int boxl_z;\n    int boxu_x; int boxu_y; int boxu_z;\n\n    int cell_material_id;\n    int is_mutating;\n    int substantial;\n    int fragment_id;\n\n    int brain_id;\n};\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nivec3 body_texture_lower(int b)\n{\n    return ivec3(bodies[b].texture_lower_x, bodies[b].texture_lower_y, bodies[b].texture_lower_z);\n}\n\nivec3 body_texture_upper(int b)\n{\n    return ivec3(bodies[b].texture_upper_x, bodies[b].texture_upper_y, bodies[b].texture_upper_z);\n}\n\nivec3 body_lower(int b)\n{\n    return ivec3(bodies[b].lower_x, bodies[b].lower_y, bodies[b].lower_z);\n}\n\nivec3 body_upper(int b)\n{\n    return ivec3(bodies[b].upper_x, bodies[b].upper_y, bodies[b].upper_z);\n}\n\nivec3 body_form_offset(int b)\n{\n    return ivec3(bodies[b].form_offset_x, bodies[b].form_offset_y, bodies[b].form_offset_z);\n}\nvec3 body_x_cm(int b)\n{\n    return vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n}\n\nvec3 body_x(int b)\n{\n    return vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n}\n\nvec3 body_x_dot(int b)\n{\n    return vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n}\n\nvec4 body_orientation(int b)\n{\n    return vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n}\n\nvec3 body_omega(int b)\n{\n    return vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n}\n\nvec3 body_old_x(int b)\n{\n    return vec3(bodies[b].old_x_x, bodies[b].old_x_y, bodies[b].old_x_z);\n}\n\nvec4 body_old_orientation(int b)\n{\n    return vec4(bodies[b].old_orientation_r, bodies[b].old_orientation_x, bodies[b].old_orientation_y, bodies[b].old_orientation_z);\n}\n\nfloat body_m(int b)\n{\n    return bodies[b].m;\n}\n\nmat3 body_I(int b)\n{\n    return mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n}\n\nmat3 body_invI(int b)\n{\n    return mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\nvec3 body_boxl(int b)\n{\n    return vec3(bodies[b].boxl_x, bodies[b].boxl_y, bodies[b].boxl_z);\n}\n\nvec3 body_boxu(int b)\n{\n    return vec3(bodies[b].boxu_x, bodies[b].boxu_y, bodies[b].boxu_z);\n}\n\nivec3 body_form_origin(int b)\n{\n    return ivec3(bodies[b].form_origin_x, bodies[b].form_origin_y, bodies[b].form_origin_z);\n}\n\nivec3 body_form_lower(int b)\n{\n    return ivec3(bodies[b].form_lower_x, bodies[b].form_lower_y, bodies[b].form_lower_z);\n}\n\nivec3 body_form_upper(int b)\n{\n    return ivec3(bodies[b].form_upper_x, bodies[b].form_upper_y, bodies[b].form_upper_z);\n}\n\nint body_cell_material_id(int b)\n{\n    return bodies[b].cell_material_id;\n}\n\nint body_is_mutating(int b)\n{\n    return bodies[b].is_mutating;\n}\n\nint body_is_substantial(int b)\n{\n    return bodies[b].substantial;\n}\n\nint body_fragment_id(int b)\n{\n    return bodies[b].fragment_id;\n}\n\nint body_brain_id(int b)\n{\n    return bodies[b].brain_id;\n}\n\n#define BODY_UPDATE_DATA_BINDING 1\n#ifndef BODY_UPDATE_DATA_BINDING\n#define BODY_UPDATE_DATA_BINDING 0\n#endif\n\nstruct body_update\n{\n    float m;\n    float I_xx;\n    float I_xy; float I_yy;\n    float I_xz; float I_yz; float I_zz;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n\n    int lower_x; int lower_y; int lower_z;\n    int upper_x; int upper_y; int upper_z;\n\n    int fragment_index;\n    int n_fragments;\n};\n\nlayout(std430, binding = BODY_UPDATE_DATA_BINDING) buffer body_update_data\n{\n    body_update body_updates[];\n};\n\n#define BODY_JOINT_DATA_BINDING 2\n#ifndef BODY_JOINT_DATA_BINDING\n#define BODY_JOINT_DATA_BINDING 0\n#endif\n\nstruct body_joint\n{\n    int body_index_0;\n    int body_index_1;\n    int texture_pos_0_x; int texture_pos_0_y; int texture_pos_0_z;\n    int texture_pos_1_x; int texture_pos_1_y; int texture_pos_1_z;\n    int axis_0;\n    int axis_1;\n};\n\nlayout(std430, binding = BODY_JOINT_DATA_BINDING) buffer body_joint_data\n{\n    body_joint joints[];\n};\n\n\nvoid main()\n{\n    uint j = gl_GlobalInvocationID.x;\n    if(j >= n_joints) return;\n\n    ivec3 p0 = ivec3(joints[j].texture_pos_0_x,joints[j].texture_pos_0_y,joints[j].texture_pos_0_z);\n    ivec3 p1 = ivec3(joints[j].texture_pos_1_x,joints[j].texture_pos_1_y,joints[j].texture_pos_1_z);\n    uvec4 v0 = imageLoad(body_materials, p0);\n    uvec4 v1 = imageLoad(body_materials, p1);\n\n    uvec4 v0_out;\n    v0_out.r = max(mat(v0), mat(v1));\n    v0_out.g = (max(phase(v0), phase(v1))<<5);\n    v0_out.b = max(temp(v0), temp(v1));\n    v0_out.a = (max(volt(v0), volt(v1)));\n\n    uvec4 v1_out = v0_out;\n\n    v0_out.g |= depth(v0);\n    v1_out.g |= depth(v1);\n\n    imageStore(body_materials, p0, v0_out);\n    imageStore(body_materials, p1, v1_out);\n\n    if(mat(v0_out) != 0)\n    {\n        int b0 = joints[j].body_index_0;\n        int b1 = joints[j].body_index_1;\n        ivec3 texture_lower0 = ivec3(bodies[b0].texture_lower_x, bodies[b0].texture_lower_y, bodies[b0].texture_lower_z);\n        ivec3 texture_lower1 = ivec3(bodies[b1].texture_lower_x, bodies[b1].texture_lower_y, bodies[b1].texture_lower_z);\n        ivec3 texture_upper0 = ivec3(bodies[b0].texture_upper_x, bodies[b0].texture_upper_y, bodies[b0].texture_upper_z);\n        ivec3 texture_upper1 = ivec3(bodies[b1].texture_upper_x, bodies[b1].texture_upper_y, bodies[b1].texture_upper_z);\n        ivec3 lower0 = ivec3(bodies[b0].lower_x, bodies[b0].lower_y, bodies[b0].lower_z);\n        ivec3 lower1 = ivec3(bodies[b1].lower_x, bodies[b1].lower_y, bodies[b1].lower_z);\n        ivec3 upper0 = ivec3(bodies[b0].upper_x, bodies[b0].upper_y, bodies[b0].upper_z);\n        ivec3 upper1 = ivec3(bodies[b1].upper_x, bodies[b1].upper_y, bodies[b1].upper_z);\n\n        if(all(equal(upper0-lower0, ivec3(0)))) lower0 = p0-texture_lower0;\n        else                                    lower0 = min(lower0, p0-texture_lower0);\n        upper0 = max(upper0, p0-texture_lower0+1);\n\n        if(all(equal(upper1-lower1, ivec3(0)))) lower1 = p1-texture_lower1;\n        else                                    lower1 = min(lower1, p1-texture_lower1);\n        upper1 = max(upper1, p1-texture_lower1+1);\n\n        bodies[b0].lower_x = lower0.x;\n        bodies[b0].lower_y = lower0.y;\n        bodies[b0].lower_z = lower0.z;\n        bodies[b0].upper_x = upper0.x;\n        bodies[b0].upper_y = upper0.y;\n        bodies[b0].upper_z = upper0.z;\n\n        bodies[b1].lower_x = lower1.x;\n        bodies[b1].lower_y = lower1.y;\n        bodies[b1].lower_z = lower1.z;\n        bodies[b1].upper_x = upper1.x;\n        bodies[b1].upper_y = upper1.y;\n        bodies[b1].upper_z = upper1.z;\n    }\n}\n"; glShaderSource(sync_joint_voxels_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(sync_joint_voxels_program_GL_COMPUTE_SHADER); glGetShaderiv(sync_joint_voxels_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(sync_joint_voxels_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile sync_joint_voxels_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(sync_joint_voxels_program, sync_joint_voxels_program_GL_COMPUTE_SHADER); 
glLinkProgram(sync_joint_voxels_program);glDetachShader(sync_joint_voxels_program, sync_joint_voxels_program_GL_COMPUTE_SHADER); glDeleteShader(sync_joint_voxels_program_GL_COMPUTE_SHADER); 
glGetProgramiv(sync_joint_voxels_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(sync_joint_voxels_program, available_memory, 0, info_log); log_error(info_log); }update_beams_program = glCreateProgram(); assert(update_beams_program, "could not create update_beams_program, GL error", glGetError());
 GLuint update_beams_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(update_beams_program_GL_COMPUTE_SHADER, "could not create update_beams_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform usampler3D occupied_regions;\nlayout(location = 4) uniform writeonly uimage3D active_regions_out;\nlayout(location = 5) uniform int n_beams;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef BEAM_DATA_BINDING\n#define BEAM_DATA_BINDING 0\n#endif\n\nstruct beam\n{\n    float x; float y; float z;\n    float dx; float dy; float dz;\n    float r;\n    float max_length;\n    float strength;\n};\n\nlayout(std430, binding = BEAM_DATA_BINDING) buffer beam_data\n{\n    beam beams[];\n};\n\nvec3 beam_x(int e)\n{\n    return vec3(beams[e].x, beams[e].y, beams[e].z);\n}\n\nvec3 beam_d(int e)\n{\n    return vec3(beams[e].dx, beams[e].dy, beams[e].dz);\n}\n\n\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, uint medium, bool use_depth, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < 0 || ipos.y < 0 || ipos.z < 0\n           || ipos.x >= size.x || ipos.y >= size.y || ipos.z >= size.z)\n        {\n            return false;\n        }\n\n        #ifdef occupied_regions\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(pos);\n        }\n        else\n        #endif\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != medium)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                if(hit_dir == vec3(0,0,0))\n                {\n                    hit_dir = abs(pos-ipos+0.5);\n                    hit_dir = step(hit_dir.zxy, hit_dir.xyz)*step(hit_dir.yzx, hit_dir.xyz);\n                }\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            #ifndef RAY_CAST_IGNORE_DEPTH\n            if(use_depth)\n            {\n                int depth = depth(voxel);\n                if(depth >= 3\n                   // #ifdef ACTIVE_REGIONS\n                   // && texelFetch(active_regions, ipos>>4, 0).r == 0\n                   // #endif //ACTIVE_REGIONS\n                    )\n                {\n                    float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                    pos += ray_dir*skip_dist;\n                    hit_dist += skip_dist;\n                    ipos = ivec3(pos);\n                }\n            }\n            #endif\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nvoid main()\n{\n    int b = int(gl_GlobalInvocationID.x);\n    if(b >= n_beams) return;\n    vec3 d = normalize(beam_d(b));\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    uvec4 voxel;\n    ivec3 size = ivec3(512);\n    ivec3 origin = ivec3(0);\n    int medium = 0;\n    int max_steps = int(3*beams[b].max_length);\n    bool hit = cast_ray(materials, d, beam_x(b), size, origin, medium, true, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, max_steps);\n\n    float beam_len = min(hit_dist, beams[b].max_length);\n\n    //wake up regions the beam passes through\n    vec3 pos = beam_x(b);\n    vec3 ray_dir = d;\n    vec3 ray_sign = sign(ray_dir);\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n    vec3 cross_section_radius = beams[b].r*inversesqrt(1.0-sq(d));\n    float epsilon = 0.02;\n    for(int i = 0; i < 3*32; i++)\n    {\n        //wake up regions touched by square that bounds cross section\n        ivec3 lower_region = ivec3((pos-cross_section_radius)/16.0);\n        ivec3 upper_region = ivec3((pos+cross_section_radius)/16.0);\n        for(int z = lower_region.z; z <= upper_region.z; z++)\n            for(int y = lower_region.y; y <= upper_region.y; y++)\n                for(int x = lower_region.x; x <= upper_region.x; x++)\n                {\n                    imageStore(active_regions_out, ivec3(x,y,z), uvec4(1,0,0,0));\n                }\n\n        vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n        vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        float min_dist = dot(dist, min_dir);\n        hit_dir = min_dir;\n\n        float step_dist = min_dist+epsilon;\n        pos += step_dist*ray_dir;\n    }\n\n    d = beam_len*d;\n\n    beams[b].dx = d.x;\n    beams[b].dy = d.y;\n    beams[b].dz = d.z;\n}\n"; glShaderSource(update_beams_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(update_beams_program_GL_COMPUTE_SHADER); glGetShaderiv(update_beams_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_beams_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_beams_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(update_beams_program, update_beams_program_GL_COMPUTE_SHADER); 
glLinkProgram(update_beams_program);glDetachShader(update_beams_program, update_beams_program_GL_COMPUTE_SHADER); glDeleteShader(update_beams_program_GL_COMPUTE_SHADER); 
glGetProgramiv(update_beams_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(update_beams_program, available_memory, 0, info_log); log_error(info_log); }update_joint_fragments_program = glCreateProgram(); assert(update_joint_fragments_program, "could not create update_joint_fragments_program, GL error", glGetError());
 GLuint update_joint_fragments_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(update_joint_fragments_program_GL_COMPUTE_SHADER, "could not create update_joint_fragments_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n\n#define localgroup_size 4\n#define subgroup_size 1\nlayout(local_size_x = localgroup_size, local_size_y = 1, local_size_z = 1) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2, rgba8ui) readonly uniform uimage3D body_materials;\nlayout(location = 3) uniform int n_joints;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3) //in world\n#define   transient(vox) (vox.g>>7) //in world\n#define   floodfill(vox) (vox.g>>5) //in bodies\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        flow(vox) (vox.a>>4) //in world\n#define        trig(vox) (vox.a>>4) //in bodies\n#endif\n\n#define signed_depth(vox) ((mat(vox) == 0) ? (1+depth(vox)) : (-depth(vox)))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 1 ? 1+depth(vox) : -depth(vox))\n\n#define solidity(vox) ((mat(vox)==0?0:1|(phase(vox)==phase_solid||phase(vox)==phase_sand ? 2:0))*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#define room_temp 100\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat friction(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat restitution(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(9,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(11,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(12,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(13+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef BODY_JOINT_DATA_BINDING\n#define BODY_JOINT_DATA_BINDING 0\n#endif\n\nstruct body_joint\n{\n    int body_index_0;\n    int body_index_1;\n    int texture_pos_0_x; int texture_pos_0_y; int texture_pos_0_z;\n    int texture_pos_1_x; int texture_pos_1_y; int texture_pos_1_z;\n    int axis_0;\n    int axis_1;\n};\n\nlayout(std430, binding = BODY_JOINT_DATA_BINDING) buffer body_joint_data\n{\n    body_joint joints[];\n};\n\n#define JOINT_UPDATE_BINDING 1\n#ifndef JOINT_UPDATE_BINDING\n#define JOINT_UPDATE_BINDING 0\n#endif\n\nstruct joint_update\n{\n    int fragment_id0;\n    int fragment_id1;\n};\n\nlayout(std430, binding = JOINT_UPDATE_BINDING) buffer joint_update_data\n{\n    joint_update joint_updates[];\n};\n\n\nvoid main()\n{\n    uint j = gl_GlobalInvocationID.x;\n    if(j >= n_joints) return;\n\n    ivec3 p0 = ivec3(joints[j].texture_pos_0_x,joints[j].texture_pos_0_y,joints[j].texture_pos_0_z);\n    ivec3 p1 = ivec3(joints[j].texture_pos_1_x,joints[j].texture_pos_1_y,joints[j].texture_pos_1_z);\n    uvec4 v0 = imageLoad(body_materials, p0);\n    uvec4 v1 = imageLoad(body_materials, p1);\n\n    joint_updates[j].fragment_id0 = int(floodfill(v0));\n    joint_updates[j].fragment_id1 = int(floodfill(v1));\n}\n"; glShaderSource(update_joint_fragments_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(update_joint_fragments_program_GL_COMPUTE_SHADER); glGetShaderiv(update_joint_fragments_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_joint_fragments_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_joint_fragments_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(update_joint_fragments_program, update_joint_fragments_program_GL_COMPUTE_SHADER); 
glLinkProgram(update_joint_fragments_program);glDetachShader(update_joint_fragments_program, update_joint_fragments_program_GL_COMPUTE_SHADER); glDeleteShader(update_joint_fragments_program_GL_COMPUTE_SHADER); 
glGetProgramiv(update_joint_fragments_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(update_joint_fragments_program, available_memory, 0, info_log); log_error(info_log); }update_lightprobe_color_program = glCreateProgram(); assert(update_lightprobe_color_program, "could not create update_lightprobe_color_program, GL error", glGetError());
 GLuint update_lightprobe_color_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(update_lightprobe_color_program_GL_COMPUTE_SHADER, "could not create update_lightprobe_color_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D lightprobe_color;\nlayout(location = 2) uniform sampler2D lightprobe_depth;\nlayout(location = 3) uniform sampler2D lightprobe_x;\nlayout(location = 4, rgba16f) uniform image2D lightprobe_color_out;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    // pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    ivec3 base_probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing);\n\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = base_probe_pos+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                probe_color.a = 1;\n\n                float normal_bias = 4.0;\n                vec3 dist = pos+(normal)*normal_bias-probe_x; //NOTE: Majercjk adds 3*view dir to the normal here\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 dir_oct = vec_to_oct(dir);\n                vec2 depth_sample_coord = vec2(lightprobe_depth_padded_resolution*probe_coord+1.0)+lightprobe_depth_resolution*clamp(0.5f*dir_oct+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_depth_resolution_x, 1.0f/lightprobe_depth_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                float weight = 1.0;\n\n                vec3 true_dir = normalize(probe_x-pos); //direction without bias\n                weight *= sq(max(0.0001, 0.5*dot(normal, true_dir)+0.5))+0.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                //Chebychev's inequality, upper bound for an arbitrary distribution\n                if(r > probe_depth.r)\n                {\n                    float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                    float cheb_weight = variance/max(variance+sq(r-probe_depth.r), 0.001);\n                    cheb_weight = max(sq(cheb_weight)*cheb_weight, 0);\n                    weight *= cheb_weight;\n                }\n\n                // //This assumes Gaussian distribution\n                // float variance = abs(probe_depth.g-sq(probe_depth.r));\n                // float x = (probe_depth.r-r)*inversesqrt(variance);\n                // weight *= cdf(x);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n#ifndef PROBE_RAY_DATA_BINDING\n#define PROBE_RAY_DATA_BINDING 0\n#endif\n\nstruct probe_ray\n{\n    vec3 rel_hit_pos;\n    vec3 hit_color;\n};\n\nlayout(std430, binding = PROBE_RAY_DATA_BINDING) buffer probe_ray_data\n{\n    probe_ray probe_rays[];\n};\n\n\n#define group_size lightprobe_resolution\nlayout(local_size_x = group_size, local_size_y = group_size, local_size_z = 1) in;\n\nvoid main()\n{\n    ivec2 probe_coord = ivec2(gl_WorkGroupID.xy);\n    ivec2 texel_coord = lightprobe_padded_resolution*probe_coord+1;\n    int probe_i = int(probe_coord.x+lightprobes_w*probe_coord.y);\n\n    ivec2 o = ivec2(gl_LocalInvocationID.xy);\n    vec2 oct = (2.0/lightprobe_resolution)*(vec2(o)+0.5)-1.0;\n\n    vec4 new_color = vec4(0);\n\n    for(int sample_i = 0; sample_i < rays_per_lightprobe; sample_i++)\n    {\n        int ray_i = probe_i*rays_per_lightprobe+sample_i;\n        vec3 ray_dir = normalize(probe_rays[ray_i].rel_hit_pos);\n        vec4 color = vec4(probe_rays[ray_i].hit_color, 1);\n\n        vec3 probe_texel_dir = oct_to_vec(oct);\n        float weight = (1.0/rays_per_lightprobe)*max(0, dot(probe_texel_dir, ray_dir));\n\n        if(weight > 0.001)\n        {\n            new_color += weight*color;\n        }\n    }\n\n    vec3 texel_color = texelFetch(lightprobe_color, texel_coord+o, 0).rgb;\n    if(new_color.a > 0.001)\n    {\n        float decay_fraction = 0.05*dot(mix(texel_color, new_color.rgb/new_color.a, 0.02), vec3(1)); //update more slowly for low light levels\n        texel_color = mix(texel_color, new_color.rgb/new_color.a, decay_fraction*new_color.a);\n    }\n    imageStore(lightprobe_color_out, texel_coord+o, vec4(texel_color, 1));\n\n    ivec2 o1 = ivec2(o.x, lightprobe_resolution-1-o.y);\n    ivec2 o2 = ivec2(lightprobe_resolution-1-o.x, o.y);\n    ivec2 o3 = ivec2(lightprobe_resolution-1-o.x, lightprobe_resolution-1-o.y);\n\n    if(o.x == 0) {o1.x--; o3.x++;}\n    if(o2.x == 0) {o1.x++; o3.x--;}\n    if(o1.x != o.x) imageStore(lightprobe_color_out, texel_coord+o1, vec4(texel_color, 1));\n\n    if(o.y == 0) {o2.y--; o3.y++;}\n    if(o1.y == 0) {o2.y++; o3.y--;}\n    if(o2.y != o.y) imageStore(lightprobe_color_out, texel_coord+o2, vec4(texel_color, 1));\n\n    if(o1.x != o.x && o2.y != o.y) imageStore(lightprobe_color_out, texel_coord+o3, vec4(texel_color, 1));\n}\n\n/////////////////////////////////////////////////////////////////\n"; glShaderSource(update_lightprobe_color_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(update_lightprobe_color_program_GL_COMPUTE_SHADER); glGetShaderiv(update_lightprobe_color_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_lightprobe_color_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_lightprobe_color_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(update_lightprobe_color_program, update_lightprobe_color_program_GL_COMPUTE_SHADER); 
glLinkProgram(update_lightprobe_color_program);glDetachShader(update_lightprobe_color_program, update_lightprobe_color_program_GL_COMPUTE_SHADER); glDeleteShader(update_lightprobe_color_program_GL_COMPUTE_SHADER); 
glGetProgramiv(update_lightprobe_color_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(update_lightprobe_color_program, available_memory, 0, info_log); log_error(info_log); }update_lightprobe_depth_program = glCreateProgram(); assert(update_lightprobe_depth_program, "could not create update_lightprobe_depth_program, GL error", glGetError());
 GLuint update_lightprobe_depth_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(update_lightprobe_depth_program_GL_COMPUTE_SHADER, "could not create update_lightprobe_depth_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D lightprobe_color;\nlayout(location = 2) uniform sampler2D lightprobe_depth;\nlayout(location = 3) uniform sampler2D lightprobe_x;\nlayout(location = 4, rg16f) uniform image2D lightprobe_depth_out;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n#define lightprobe_depth_resolution 16\n#define lightprobe_depth_padded_resolution (lightprobe_depth_resolution+2)\n#define lightprobe_depth_resolution_x (lightprobes_w*lightprobe_depth_padded_resolution)\n#define lightprobe_depth_resolution_y (lightprobes_h*lightprobe_depth_padded_resolution)\n\n#define rays_per_lightprobe 4\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    // pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    ivec3 base_probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing);\n\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = base_probe_pos+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                probe_color.a = 1;\n\n                float normal_bias = 4.0;\n                vec3 dist = pos+(normal)*normal_bias-probe_x; //NOTE: Majercjk adds 3*view dir to the normal here\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 dir_oct = vec_to_oct(dir);\n                vec2 depth_sample_coord = vec2(lightprobe_depth_padded_resolution*probe_coord+1.0)+lightprobe_depth_resolution*clamp(0.5f*dir_oct+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_depth_resolution_x, 1.0f/lightprobe_depth_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                float weight = 1.0;\n\n                vec3 true_dir = normalize(probe_x-pos); //direction without bias\n                weight *= sq(max(0.0001, 0.5*dot(normal, true_dir)+0.5))+0.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                //Chebychev's inequality, upper bound for an arbitrary distribution\n                if(r > probe_depth.r)\n                {\n                    float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                    float cheb_weight = variance/max(variance+sq(r-probe_depth.r), 0.001);\n                    cheb_weight = max(sq(cheb_weight)*cheb_weight, 0);\n                    weight *= cheb_weight;\n                }\n\n                // //This assumes Gaussian distribution\n                // float variance = abs(probe_depth.g-sq(probe_depth.r));\n                // float x = (probe_depth.r-r)*inversesqrt(variance);\n                // weight *= cdf(x);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n#ifndef PROBE_RAY_DATA_BINDING\n#define PROBE_RAY_DATA_BINDING 0\n#endif\n\nstruct probe_ray\n{\n    vec3 rel_hit_pos;\n    vec3 hit_color;\n};\n\nlayout(std430, binding = PROBE_RAY_DATA_BINDING) buffer probe_ray_data\n{\n    probe_ray probe_rays[];\n};\n\n\n#define group_size lightprobe_depth_resolution\nlayout(local_size_x = group_size, local_size_y = group_size, local_size_z = 1) in;\n\nvoid main()\n{\n    ivec2 probe_coord = ivec2(gl_WorkGroupID.xy);\n    ivec2 depth_texel_coord = lightprobe_depth_padded_resolution*probe_coord+1;\n    int probe_i = int(probe_coord.x+lightprobes_w*probe_coord.y);\n\n    ivec2 o = ivec2(gl_LocalInvocationID.xy);\n    vec2 oct = (2.0/lightprobe_depth_resolution)*(vec2(o)+0.5)-1.0;\n\n    vec3 new_depth = vec3(0);\n\n    for(int sample_i = 0; sample_i < rays_per_lightprobe; sample_i++)\n    {\n        int ray_i = probe_i*rays_per_lightprobe+sample_i;\n        vec3 ray_dir = normalize(probe_rays[ray_i].rel_hit_pos);\n        vec3 depth;\n        depth.r = clamp(length(probe_rays[ray_i].rel_hit_pos), 0, 2*lightprobe_spacing);\n        depth.g = sq(depth.r);\n        depth.b = 1;\n\n        vec3 probe_texel_dir = oct_to_vec(oct);\n        float weight = max(dot(probe_texel_dir, ray_dir), 0);\n        weight = pow(weight, 101.0);\n        if(weight > 0.001)\n        {\n            new_depth += weight*depth;\n        }\n    }\n\n    vec2 texel_depth = texelFetch(lightprobe_depth, depth_texel_coord+o, 0).rg;\n    float decay_fraction = 0.05;\n    if(new_depth.z > 0.001) texel_depth = mix(texel_depth, new_depth.xy/new_depth.z, decay_fraction*new_depth.z);\n    imageStore(lightprobe_depth_out, depth_texel_coord+o, vec4(texel_depth, 0, 1));\n\n    ivec2 o1 = ivec2(o.x, lightprobe_depth_resolution-1-o.y);\n    ivec2 o2 = ivec2(lightprobe_depth_resolution-1-o.x, o.y);\n    ivec2 o3 = ivec2(lightprobe_depth_resolution-1-o.x, lightprobe_depth_resolution-1-o.y);\n\n    if(o.x == 0) {o1.x--; o3.x++;}\n    if(o2.x == 0) {o1.x++; o3.x--;}\n    if(o1.x != o.x) imageStore(lightprobe_depth_out, depth_texel_coord+o1, vec4(texel_depth, 0, 1));\n\n    if(o.y == 0) {o2.y--; o3.y++;}\n    if(o1.y == 0) {o2.y++; o3.y--;}\n    if(o2.y != o.y) imageStore(lightprobe_depth_out, depth_texel_coord+o2, vec4(texel_depth, 0, 1));\n\n    if(o1.x != o.x && o2.y != o.y) imageStore(lightprobe_depth_out, depth_texel_coord+o3, vec4(texel_depth, 0, 1));\n}\n\n/////////////////////////////////////////////////////////////////\n"; glShaderSource(update_lightprobe_depth_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(update_lightprobe_depth_program_GL_COMPUTE_SHADER); glGetShaderiv(update_lightprobe_depth_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { GLsizei info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_lightprobe_depth_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_lightprobe_depth_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(update_lightprobe_depth_program, update_lightprobe_depth_program_GL_COMPUTE_SHADER); 
glLinkProgram(update_lightprobe_depth_program);glDetachShader(update_lightprobe_depth_program, update_lightprobe_depth_program_GL_COMPUTE_SHADER); glDeleteShader(update_lightprobe_depth_program_GL_COMPUTE_SHADER); 
glGetProgramiv(update_lightprobe_depth_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(update_lightprobe_depth_program, available_memory, 0, info_log); log_error(info_log); }unreserve_block(manager);}