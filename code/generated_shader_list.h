
GLuint circle_program;
GLuint debug_text_program;
GLuint denoise_program;
GLuint draw_lightprobes_program;
GLuint draw_particles_program;
GLuint draw_text_program;
GLuint fullscreen_texture_program;
GLuint get_voxel_data_program;
GLuint mipmap_chunk_program;
GLuint move_lightprobes_program;
GLuint pad_lightprobes_program;
GLuint render_depth_prepass_program;
GLuint render_editor_voxels_program;
GLuint render_prepass_program;
GLuint render_world_program;
GLuint simulate_body_program;
GLuint simulate_body_physics_program;
GLuint simulate_chunk_program;
GLuint simulate_chunk_atomic_program;
GLuint simulate_particles_program;
GLuint update_lightmap_program;void gl_init_programs(memory_manager* manager){int error; size_t available_memory = current_block_unused(manager); byte* free_memory = reserve_block(manager, available_memory);circle_program = glCreateProgram(); assert(circle_program, "could not create circle_program, GL error", glGetError());
 GLuint circle_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(circle_program_GL_VERTEX_SHADER, "could not create circle_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\nlayout(location = 1) in vec3 X;\nlayout(location = 2) in float r;\nlayout(location = 3) in vec4 c;\n\nsmooth out vec4 color;\nsmooth out vec2 uv;\nsmooth out float radius;\n\nlayout(location = 0) uniform mat4 t;\n\nvoid main()\n{\n    gl_Position.xyz = (x*r+X);\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    uv = x.xy*r;\n    radius = r;\n    color = c;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_VERTEX_SHADER); glGetShaderiv(circle_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_VERTEX_SHADER); 

 GLuint circle_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(circle_program_GL_FRAGMENT_SHADER, "could not create circle_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform float smoothness;\n\nsmooth in vec4 color;\nsmooth in vec2 uv;\nsmooth in float radius;\n\nvoid main()\n{\n    frag_color = color;\n    float alpha = smoothstep(-radius, -radius+smoothness, -length(uv));\n    frag_color.a *= alpha;\n    gl_FragDepth = gl_FragCoord.z*alpha;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_FRAGMENT_SHADER); glGetShaderiv(circle_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); 
glLinkProgram(circle_program);glDetachShader(circle_program, circle_program_GL_VERTEX_SHADER); glDeleteShader(circle_program_GL_VERTEX_SHADER); 
glDetachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); glDeleteShader(circle_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(circle_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(circle_program, available_memory, 0, info_log); log_error(info_log); }debug_text_program = glCreateProgram(); assert(debug_text_program, "could not create debug_text_program, GL error", glGetError());
 GLuint debug_text_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(debug_text_program_GL_VERTEX_SHADER, "could not create debug_text_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\nlayout(location = 1) in vec4 c;\n\nsmooth out vec4 color;\n\nvoid main()\n{\n    gl_Position.xyz = 5*x/vec3(1080, 720, 1);\n    gl_Position.y = -gl_Position.y;\n    gl_Position.w = 1.0;\n    color = vec4(1);\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(debug_text_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(debug_text_program_GL_VERTEX_SHADER); glGetShaderiv(debug_text_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(debug_text_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile debug_text_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(debug_text_program, debug_text_program_GL_VERTEX_SHADER); 

 GLuint debug_text_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(debug_text_program_GL_FRAGMENT_SHADER, "could not create debug_text_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nsmooth in vec4 color;\n\nvoid main()\n{\n    frag_color = color;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(debug_text_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(debug_text_program_GL_FRAGMENT_SHADER); glGetShaderiv(debug_text_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(debug_text_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile debug_text_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(debug_text_program, debug_text_program_GL_FRAGMENT_SHADER); 
glLinkProgram(debug_text_program);glDetachShader(debug_text_program, debug_text_program_GL_VERTEX_SHADER); glDeleteShader(debug_text_program_GL_VERTEX_SHADER); 
glDetachShader(debug_text_program, debug_text_program_GL_FRAGMENT_SHADER); glDeleteShader(debug_text_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(debug_text_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(debug_text_program, available_memory, 0, info_log); log_error(info_log); }denoise_program = glCreateProgram(); assert(denoise_program, "could not create denoise_program, GL error", glGetError());
 GLuint denoise_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(denoise_program_GL_VERTEX_SHADER, "could not create denoise_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(denoise_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(denoise_program_GL_VERTEX_SHADER); glGetShaderiv(denoise_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(denoise_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile denoise_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(denoise_program, denoise_program_GL_VERTEX_SHADER); 

 GLuint denoise_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(denoise_program_GL_FRAGMENT_SHADER, "could not create denoise_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 0) uniform sampler2D color;\nlayout(location = 1) uniform sampler2D depth;\nlayout(location = 2) uniform sampler2D normal;\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n\n    ivec2 d = ivec2(1,0);\n    vec2 p = 0.5f*screen_pos+0.5f;\n    int lod = 0;\n    ivec2 ip = ivec2(pow(0.5f, lod)*gl_FragCoord.xy);\n    // float laplacian =\n    //     texelFetch(depth, ip-d.yx, lod).r+texelFetch(depth, ip+d.yx, lod).r\n    //     +texelFetch(depth, ip-d.xy, lod).r+texelFetch(depth, ip+d.xy, lod).r\n    //     -4.0f*texelFetch(depth, ip, lod).r;\n    // frag_color.rgb = vec3(100*laplacian.r);\n    // frag_color.rgb = textureLod(color, p, clamp(4.0f-1000.0f*laplacian, 0, 8)).rgb;\n\n    float center_depth = texelFetch(depth, ip, 0).r;\n    vec3 center_normal = texelFetch(normal, ip, 0).rgb;\n    float weight = 0.0f;\n    frag_color.rgb = vec3(0);\n    int radius = 3;\n    for(int dx = -radius; dx <= radius; dx++)\n        for(int dy = -radius; dy <= radius; dy++)\n            // if(abs(1.0-texelFetch(depth, ip+ivec2(dx,dy), 0).r/center_depth) < 0.01)\n            if(length(texelFetch(normal, ip+ivec2(dx,dy), 0).rgb-center_normal) < 0.01)\n            {\n                // float w = exp(-0.5*(sq(dx)+sq(dy)));\n                float w = 1.0;\n                frag_color.rgb += w*texelFetch(color, ip+ivec2(dx,dy), 0).rgb;\n                weight += w;\n            }\n\n    frag_color.rgb *= 1.0f/weight;\n    frag_color.a = 1.0f;\n}\n"; glShaderSource(denoise_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(denoise_program_GL_FRAGMENT_SHADER); glGetShaderiv(denoise_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(denoise_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile denoise_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(denoise_program, denoise_program_GL_FRAGMENT_SHADER); 
glLinkProgram(denoise_program);glDetachShader(denoise_program, denoise_program_GL_VERTEX_SHADER); glDeleteShader(denoise_program_GL_VERTEX_SHADER); 
glDetachShader(denoise_program, denoise_program_GL_FRAGMENT_SHADER); glDeleteShader(denoise_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(denoise_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(denoise_program, available_memory, 0, info_log); log_error(info_log); }draw_lightprobes_program = glCreateProgram(); assert(draw_lightprobes_program, "could not create draw_lightprobes_program, GL error", glGetError());
 GLuint draw_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_lightprobes_program_GL_VERTEX_SHADER, "could not create draw_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\nlayout(location = 3) uniform sampler2D lightprobe_x;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nsmooth out vec3 r;\nflat out ivec2 probe_coord;\n\nvoid main()\n{\n    probe_coord = ivec2(gl_InstanceID%lightprobes_w, gl_InstanceID/lightprobes_w);\n    gl_Position.xyz = x+texelFetch(lightprobe_x, probe_coord, 0).xyz;\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    r = x;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(draw_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(draw_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_lightprobes_program, draw_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint draw_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_lightprobes_program_GL_FRAGMENT_SHADER, "could not create draw_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform sampler2D lightprobe_color;\nlayout(location = 2) uniform sampler2D lightprobe_depth;\nlayout(location = 3) uniform sampler2D lightprobe_x;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nsmooth in vec3 r;\nflat in ivec2 probe_coord;\n\nvoid main()\n{\n    vec2 sample_oct = vec_to_oct(normalize(r));\n\n    vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1.5)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n    vec2 t = trunc(sample_coord);\n    vec2 f = fract(sample_coord);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    // f = f*f*(-2*f+3);\n    float l = 1-sq(f.x-0.5)*sq(f.y-0.5);\n    sample_coord = t+f-0.5;\n    sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n    frag_color = textureLod(lightprobe_color, sample_coord, l);\n    // frag_color.rgb = vec3(textureLod(lightprobe_depth, sample_coord, l).r/16.0);\n    frag_color.a = 1.0;\n}\n"; glShaderSource(draw_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_lightprobes_program, draw_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_lightprobes_program);glDetachShader(draw_lightprobes_program, draw_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(draw_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(draw_lightprobes_program, draw_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }draw_particles_program = glCreateProgram(); assert(draw_particles_program, "could not create draw_particles_program, GL error", glGetError());
 GLuint draw_particles_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_particles_program_GL_VERTEX_SHADER, "could not create draw_particles_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\n\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nsmooth out vec3 r;\n\nvoid main()\n{\n    int p = gl_InstanceID;\n    if(!particles[p].alive)\n    {\n        gl_Position = vec4(0.0/0.0);\n        return;\n    }\n    gl_Position.xyz = x+vec3(particles[p].x, particles[p].y, particles[p].z);\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    r = x;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(draw_particles_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_particles_program_GL_VERTEX_SHADER); glGetShaderiv(draw_particles_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_particles_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_particles_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_particles_program, draw_particles_program_GL_VERTEX_SHADER); 

 GLuint draw_particles_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_particles_program_GL_FRAGMENT_SHADER, "could not create draw_particles_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nsmooth in vec3 r;\n\nvoid main()\n{\n    frag_color = vec4(0,1,0,1);\n}\n"; glShaderSource(draw_particles_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_particles_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_particles_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_particles_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_particles_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_particles_program, draw_particles_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_particles_program);glDetachShader(draw_particles_program, draw_particles_program_GL_VERTEX_SHADER); glDeleteShader(draw_particles_program_GL_VERTEX_SHADER); 
glDetachShader(draw_particles_program, draw_particles_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_particles_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_particles_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_particles_program, available_memory, 0, info_log); log_error(info_log); }draw_text_program = glCreateProgram(); assert(draw_text_program, "could not create draw_text_program, GL error", glGetError());
 GLuint draw_text_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_text_program_GL_VERTEX_SHADER, "could not create draw_text_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 xy;\nlayout(location = 1) in vec2 st;\n\nlayout(location = 0) uniform vec2 resolution;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xy = 2*xy/resolution;\n    gl_Position.y = -gl_Position.y;\n    gl_Position.z = 0.0;\n    gl_Position.w = 1.0;\n    uv = st;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(draw_text_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_text_program_GL_VERTEX_SHADER); glGetShaderiv(draw_text_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_text_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_text_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_text_program, draw_text_program_GL_VERTEX_SHADER); 

 GLuint draw_text_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_text_program_GL_FRAGMENT_SHADER, "could not create draw_text_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform vec4 color;\nlayout(location = 2) uniform sampler2D packed_font;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    frag_color = color*texture(packed_font, uv).r;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(draw_text_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_text_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_text_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_text_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_text_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_text_program, draw_text_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_text_program);glDetachShader(draw_text_program, draw_text_program_GL_VERTEX_SHADER); glDeleteShader(draw_text_program_GL_VERTEX_SHADER); 
glDetachShader(draw_text_program, draw_text_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_text_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_text_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_text_program, available_memory, 0, info_log); log_error(info_log); }fullscreen_texture_program = glCreateProgram(); assert(fullscreen_texture_program, "could not create fullscreen_texture_program, GL error", glGetError());
 GLuint fullscreen_texture_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(fullscreen_texture_program_GL_VERTEX_SHADER, "could not create fullscreen_texture_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5f*x.xy+0.5f;\n}\n\n"; glShaderSource(fullscreen_texture_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_VERTEX_SHADER); glGetShaderiv(fullscreen_texture_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); 

 GLuint fullscreen_texture_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(fullscreen_texture_program_GL_FRAGMENT_SHADER, "could not create fullscreen_texture_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n////////////////<2d circle fragment shader>////////////////\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform sampler2D color;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    frag_color = texture(color, uv);\n}\n"; glShaderSource(fullscreen_texture_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); glGetShaderiv(fullscreen_texture_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glLinkProgram(fullscreen_texture_program);glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); glDeleteShader(fullscreen_texture_program_GL_VERTEX_SHADER); 
glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); glDeleteShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(fullscreen_texture_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(fullscreen_texture_program, available_memory, 0, info_log); log_error(info_log); }get_voxel_data_program = glCreateProgram(); assert(get_voxel_data_program, "could not create get_voxel_data_program, GL error", glGetError());
 GLuint get_voxel_data_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(get_voxel_data_program_GL_VERTEX_SHADER, "could not create get_voxel_data_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5*x.xy+0.5;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(get_voxel_data_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(get_voxel_data_program_GL_VERTEX_SHADER); glGetShaderiv(get_voxel_data_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(get_voxel_data_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile get_voxel_data_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(get_voxel_data_program, get_voxel_data_program_GL_VERTEX_SHADER); 

 GLuint get_voxel_data_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(get_voxel_data_program_GL_FRAGMENT_SHADER, "could not create get_voxel_data_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec2 material;\nlayout(location = 1) out vec3 normal;\n\nlayout(location = 0) uniform isampler3D materials;\nlayout(location = 1) uniform ivec3 pos;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    ivec3 x = pos;\n\n    vec3 gradient = vec3(\n        texelFetch(materials, ivec3(x+vec3(1,0,0)), 0).g-texelFetch(materials, ivec3(x+vec3(-1,0,0)), 0).g,\n        texelFetch(materials, ivec3(x+vec3(0,1,0)), 0).g-texelFetch(materials, ivec3(x+vec3(0,-1,0)), 0).g,\n        texelFetch(materials, ivec3(x+vec3(0,0,1)), 0).g-texelFetch(materials, ivec3(x+vec3(0,0,-1)), 0).g+0.001f\n        );\n    gradient = normalize(gradient);\n\n    material = texelFetch(materials, x, 0).rg;\n    normal = gradient;\n}\n"; glShaderSource(get_voxel_data_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(get_voxel_data_program_GL_FRAGMENT_SHADER); glGetShaderiv(get_voxel_data_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(get_voxel_data_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile get_voxel_data_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(get_voxel_data_program, get_voxel_data_program_GL_FRAGMENT_SHADER); 
glLinkProgram(get_voxel_data_program);glDetachShader(get_voxel_data_program, get_voxel_data_program_GL_VERTEX_SHADER); glDeleteShader(get_voxel_data_program_GL_VERTEX_SHADER); 
glDetachShader(get_voxel_data_program, get_voxel_data_program_GL_FRAGMENT_SHADER); glDeleteShader(get_voxel_data_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(get_voxel_data_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(get_voxel_data_program, available_memory, 0, info_log); log_error(info_log); }mipmap_chunk_program = glCreateProgram(); assert(mipmap_chunk_program, "could not create mipmap_chunk_program, GL error", glGetError());
 GLuint mipmap_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(mipmap_chunk_program_GL_VERTEX_SHADER, "could not create mipmap_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 r;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int mip_level;\nlayout(location = 3) uniform usampler3D active_regions_in;\n\nout vec3 p;\n\nvoid main()\n{\n    float mip_scale = pow(0.5, mip_level-1);\n    int z = layer/(16>>mip_level);\n    int y = int(X.y);\n    int x = int(X.x);\n\n    p=vec3(16*mip_scale*x,16*mip_scale*y,layer*pow(2, mip_level));\n\n    gl_Position = vec4(0.0/0.0, 0.0/0.0, 0, 1);\n\n    float scale = 2.0f/32.0f;\n\n    uint region_active = texelFetch(active_regions_in, ivec3(x, y, z), 0).r;\n    if(region_active != 0)\n    {\n        gl_Position.xy = -1.0f+scale*(r+X);\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(mipmap_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(mipmap_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(mipmap_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(mipmap_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile mipmap_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(mipmap_chunk_program, mipmap_chunk_program_GL_VERTEX_SHADER); 

 GLuint mipmap_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(mipmap_chunk_program_GL_FRAGMENT_SHADER, "could not create mipmap_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec4 frag_color;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int mip_level;\nlayout(location = 2) uniform isampler3D materials;\n\nin vec3 p;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    float mip_scale = pow(2.0, mip_level);\n    ivec3 pos = ivec3(p);\n    ivec3 cell_p;\n    cell_p.xy = ivec2(gl_FragCoord.xy*mip_scale)%int(32/mip_scale);\n    pos.xy += cell_p.xy;\n\n    frag_color.rg = ivec2(0, 16);\n    for(int z = 0; z <= 1; z++)\n        for(int y = 0; y <= 1; y++)\n            for(int x = 0; x <= 1; x++)\n            {\n                ivec4 voxel  = texelFetch(materials, ivec3(pos.x+x, pos.y+y, pos.z+z), mip_level-1);\n                frag_color.r = max(frag_color.r, voxel.r);\n                // if(voxel.g > 1)\n                // {\n                //     frag_color.g = voxel.g-1;\n                //     break;\n                // }\n                frag_color.g = min(frag_color.g, voxel.g);\n            }\n    frag_color.r = pos.z;\n    frag_color.a = 1;\n}\n"; glShaderSource(mipmap_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(mipmap_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(mipmap_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(mipmap_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile mipmap_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(mipmap_chunk_program, mipmap_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(mipmap_chunk_program);glDetachShader(mipmap_chunk_program, mipmap_chunk_program_GL_VERTEX_SHADER); glDeleteShader(mipmap_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(mipmap_chunk_program, mipmap_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(mipmap_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(mipmap_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(mipmap_chunk_program, available_memory, 0, info_log); log_error(info_log); }move_lightprobes_program = glCreateProgram(); assert(move_lightprobes_program, "could not create move_lightprobes_program, GL error", glGetError());
 GLuint move_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(move_lightprobes_program_GL_VERTEX_SHADER, "could not create move_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(move_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(move_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(move_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(move_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile move_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(move_lightprobes_program, move_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint move_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(move_lightprobes_program_GL_FRAGMENT_SHADER, "could not create move_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nlayout(location = 0) out vec3 new_x;\n\nlayout(location = 0) uniform isampler3D materials;\nlayout(location = 1) uniform sampler2D old_x;\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\nvoid main()\n{\n    ivec2 probe_coord = ivec2(gl_FragCoord.xy);\n    vec3 x = texelFetch(old_x, probe_coord, 0).rgb;\n\n    ivec3 ix = ivec3(x);\n\n    //the center of the current cell\n    int j = probe_coord.x+lightprobes_w*probe_coord.y;\n    vec3 center_x = vec3((lightprobe_spacing/2)+lightprobe_spacing*(j%lightprobes_per_axis),\n                         (lightprobe_spacing/2)+lightprobe_spacing*((j/lightprobes_per_axis)%lightprobes_per_axis),\n                         (lightprobe_spacing/2)+lightprobe_spacing*(j/sq(lightprobes_per_axis)));\n\n    ivec4 voxel = texelFetch(materials, ix, 0);\n    if(signed_depth(voxel) < 4)\n    {\n        vec3 gradient = unnormalized_gradient(materials, ix);\n        gradient = normalize(gradient);\n\n        x += 0.1*gradient*(5-signed_depth(voxel));\n    }\n    else if(signed_depth(voxel) > 5)\n    {\n        x = mix(x, center_x, 0.1);\n    }\n\n    new_x = x;\n}\n"; glShaderSource(move_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(move_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(move_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(move_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile move_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(move_lightprobes_program, move_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(move_lightprobes_program);glDetachShader(move_lightprobes_program, move_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(move_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(move_lightprobes_program, move_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(move_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(move_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(move_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }pad_lightprobes_program = glCreateProgram(); assert(pad_lightprobes_program, "could not create pad_lightprobes_program, GL error", glGetError());
 GLuint pad_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(pad_lightprobes_program_GL_VERTEX_SHADER, "could not create pad_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 x;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\nsmooth out vec2 sample_oct;\n\nvoid main()\n{\n    gl_Position.xy = x;\n    gl_Position.z = 0.0f;\n    gl_Position.w = 1.0f;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(pad_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(pad_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint pad_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(pad_lightprobes_program_GL_FRAGMENT_SHADER, "could not create pad_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec4 depth;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvoid main()\n{\n    vec2 probe_pos = floor(gl_FragCoord.xy*(1.0f/lightprobe_padded_resolution));\n    vec2 oct = (gl_FragCoord.xy-probe_pos*lightprobe_padded_resolution-1.0f)/lightprobe_resolution-0.5f;\n    if(abs(oct.x) > 0.5)\n        oct.y = -oct.y;\n    if(abs(oct.y) > 0.5)\n        oct.x = -oct.x;\n    ivec2 sample_coord = ivec2(probe_pos*lightprobe_padded_resolution+1.0f\n                               +clamp((oct+0.5f)*lightprobe_resolution, 0, lightprobe_resolution-1));\n    color = texelFetch(lightprobe_color, sample_coord, 0);\n    depth = texelFetch(lightprobe_depth, sample_coord, 0);\n\n    color.a = 1;\n    depth.a = 1;\n}\n"; glShaderSource(pad_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(pad_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(pad_lightprobes_program);glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(pad_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(pad_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(pad_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }render_depth_prepass_program = glCreateProgram(); assert(render_depth_prepass_program, "could not create render_depth_prepass_program, GL error", glGetError());
 GLuint render_depth_prepass_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_depth_prepass_program_GL_VERTEX_SHADER, "could not create render_depth_prepass_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_depth_prepass_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_VERTEX_SHADER); glGetShaderiv(render_depth_prepass_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); 

 GLuint render_depth_prepass_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_depth_prepass_program_GL_FRAGMENT_SHADER, "could not create render_depth_prepass_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 depth;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform vec3 camera_pos;\nlayout(location = 3) uniform isampler3D materials;\nlayout(location = 4) uniform usampler3D occupied_regions;\nlayout(location = 5) uniform ivec3 size;\nlayout(location = 6) uniform ivec3 origin;\nlayout(location = 7) uniform sampler2D blue_noise_texture;\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+PHI*frame_number);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec2 sample_pos = screen_pos.xy;\n    sample_pos += (blue_noise(gl_FragCoord.xy/256.0f+vec2(0.319f, 0.712f)).xy-0.5f)/vec2(360, 180);\n    vec3 ray_dir = (16.0/9.0*sample_pos.x*camera_axes[0]\n                    +        sample_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    vec3 hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int max_iterations = 200;\n    int i = 0;\n    float total_dist = 0;\n\n    if(pos.x < 0 && ray_dir.x > 0)      total_dist = max(total_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) total_dist = max(total_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      total_dist = max(total_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) total_dist = max(total_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      total_dist = max(total_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) total_dist = max(total_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += total_dist*ray_dir;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    int bounces_remaining = 5;\n    bool first_hit = true;\n    vec3 color_multiplier = vec3(1,1,1);\n\n    depth = vec4(0.0);\n\n    // {\n    //     vec3 dist = ((0.5*ray_sign+0.5)*size-ray_sign*pos)*invabs_ray_dir;\n    //     float min_dist = dist.x;\n    //     int min_dir = 0;\n    //     if(dist.y < min_dist) {\n    //         min_dist = dist.y;\n    //         min_dir = 1;\n    //     }\n    //     if(dist.z < min_dist) {\n    //         min_dist = dist.z;\n    //         min_dir = 2;\n    //     }\n    //     ivec3 max_displacement = ivec3(ceil(abs(min_dist*ray_dir)));\n    //     max_iterations = max_displacement.x+max_displacement.y+max_displacement.z;\n    // }\n    // max_iterations = min(max_iterations, 100);\n    // max_iterations = max(max_iterations, 100);\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return;\n        }\n        while(texelFetch(occupied_regions, ipos/16, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos/16.0f)-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            total_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return;\n            }\n        }\n\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            float roughness = 0.0f;\n            vec3 emission = vec3(0.0f);\n            if(voxel.r == 2)\n            {\n                emission = vec3(0.05,0.05,0.1);\n            }\n            if(voxel.r == 4)\n            {\n                emission = vec3(1.0,1.0,1.0);\n            }\n\n            if(voxel.r > 1)\n            {\n                roughness = 0.8;\n            }\n            else\n            {\n                roughness = 0.9;\n            }\n\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            vec3 normal = gradient;\n            normal += roughness*(blue_noise(gl_FragCoord.xy/256.0).rgb-0.5f);\n            normal = normalize(normal);\n            gradient = normalize(gradient);\n\n            depth.rgb += color_multiplier*emission;\n\n            if(voxel.r == 1)\n            {\n                color_multiplier *= vec3(0.54,0.44,0.21);\n                roughness = 0.9;\n            }\n            else if(voxel.r == 3)\n            {\n                color_multiplier *= vec3(0.5,0.5,1.0);\n                roughness = 0.1;\n            }\n            else\n            {\n                color_multiplier *= vec3(0.1,0.1,0.2);\n                roughness = 0.1;\n            }\n\n            color_multiplier *= -dot(ray_dir, normal);\n\n            if(first_hit)\n            {\n                color_multiplier = vec3(1,1,1);\n                depth.rgb = vec3(0,0,0);\n                depth.a = total_dist;\n                first_hit = false;\n            }\n            if(bounces_remaining-- <= 0)\n            {\n                return;\n            }\n            else\n            {\n                ray_dir -= 2*dot(ray_dir, normal)*normal;\n                ray_sign = sign(ray_dir);\n\n                invabs_ray_dir = ray_sign/ray_dir;\n            }\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            total_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        float min_dist = dot(dist, min_dir);\n        pos += min_dist*ray_dir;\n        ipos += ivec3(min_dir*ray_sign);\n        total_dist += min_dist;\n        hit_dir = min_dir;\n\n        // if(first_hit)\n        // {^all that stuff}\n        // else\n        // {\n        //     pos += ray_dir*coarse_step;\n        //     total_dist += coarse_step;\n        //     ipos = ivec3(floor(pos));\n        //     coarse_step += 1.0f*coarse_step*(float_noise(pos.xy+pos.zz));\n        // }\n\n        if(++i >= max_iterations)\n        {\n            return;\n        }\n    }\n}\n"; glShaderSource(render_depth_prepass_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_depth_prepass_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_depth_prepass_program);glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); glDeleteShader(render_depth_prepass_program_GL_VERTEX_SHADER); 
glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); glDeleteShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_depth_prepass_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_depth_prepass_program, available_memory, 0, info_log); log_error(info_log); }render_editor_voxels_program = glCreateProgram(); assert(render_editor_voxels_program, "could not create render_editor_voxels_program, GL error", glGetError());
 GLuint render_editor_voxels_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_editor_voxels_program_GL_VERTEX_SHADER, "could not create render_editor_voxels_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_editor_voxels_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_editor_voxels_program_GL_VERTEX_SHADER); glGetShaderiv(render_editor_voxels_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_editor_voxels_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_editor_voxels_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_editor_voxels_program, render_editor_voxels_program_GL_VERTEX_SHADER); 

 GLuint render_editor_voxels_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_editor_voxels_program_GL_FRAGMENT_SHADER, "could not create render_editor_voxels_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 0) uniform mat3 camera_axes;\nlayout(location = 1) uniform vec3 camera_pos;\nlayout(location = 2) uniform sampler2D material_visual_properties;\nlayout(location = 3) uniform isampler3D form_materials;\nlayout(location = 4) uniform sampler2D blue_noise_texture;\nlayout(location = 5) uniform int frame_number;\nlayout(location = 6) uniform int n_forms;\nlayout(location = 7) uniform int highlight_form;\nlayout(location = 8) uniform ivec3 highlight_cell;\n\n// #define DEBUG_DOTS\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec3 quasinoise_3(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\n#ifndef FORM_DATA_BINDING\n#define FORM_DATA_BINDING 0\n#endif\n\nstruct form\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n\n    int cell_material_id;\n    int is_mutating;\n};\n\nivec3 form_materials_origin;\nivec3 form_size;\nvec3  form_x_cm;\nvec3  form_x;\nvec4  form_orientation;\n\nint form_cell_material_id;\nint form_is_mutating;\n\nlayout(std430, binding = FORM_DATA_BINDING) buffer form_data\n{\n    form forms[];\n};\n\nvoid get_form_data(int f)\n{\n    form_materials_origin = ivec3(forms[f].materials_origin_x,\n                                  forms[f].materials_origin_y,\n                                  forms[f].materials_origin_z);\n    form_size = ivec3(forms[f].size_x,\n                      forms[f].size_y,\n                      forms[f].size_z);\n\n    form_x = vec3(forms[f].x_x, forms[f].x_y, forms[f].x_z);\n    form_orientation = vec4(forms[f].orientation_r, forms[f].orientation_x, forms[f].orientation_y, forms[f].orientation_z);\n\n    form_x_cm = vec3(forms[f].x_cm_x, forms[f].x_cm_y, forms[f].x_cm_z);\n\n    form_cell_material_id = forms[f].cell_material_id;\n    form_is_mutating = forms[f].is_mutating;\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\n#define RAY_CAST_IGNORE_DEPTH\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, uint medium, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(pos);\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n\n        #ifdef occupied_regions\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(pos);\n        }\n        else\n        #endif\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != medium)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            #ifndef RAY_CAST_IGNORE_DEPTH\n            int depth = depth(voxel);\n            if(depth >= 3\n               // #ifdef ACTIVE_REGIONS\n               // && texelFetch(active_regions, ipos>>4, 0).r == 0\n               // #endif //ACTIVE_REGIONS\n                )\n            {\n                float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                pos += ray_dir*skip_dist;\n                hit_dist += skip_dist;\n                ipos = ivec3(pos);\n            }\n            #endif\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    frag_color = vec4(0,0,0,1);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 0;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    uvec4 voxel;\n    int hit_form = -2;\n    bool hit = false;\n\n    for(int f = 0; f < n_forms; f++)\n    {\n        vec3 form_x_cm = vec3(forms[f].x_cm_x, forms[f].x_cm_y, forms[f].x_cm_z);\n        vec3 form_x = vec3(forms[f].x_x, forms[f].x_y, forms[f].x_z);\n        vec4 form_orientation = vec4(forms[f].orientation_r, forms[f].orientation_x, forms[f].orientation_y, forms[f].orientation_z);\n        ivec3 form_size = ivec3(forms[f].size_x,\n                                forms[f].size_y,\n                                forms[f].size_z);\n        ivec3 form_origin = ivec3(forms[f].materials_origin_x,\n                                  forms[f].materials_origin_y,\n                                  forms[f].materials_origin_z);\n\n        //ray info in the forms frame\n        vec3 form_pos = apply_rotation(conjugate(form_orientation), pos-form_x) + form_x_cm;\n        vec3 form_ray_dir = apply_rotation(conjugate(form_orientation), ray_dir);\n\n        float form_jump_dist = 0.0;\n        if(form_pos.x < 0 && form_ray_dir.x > 0)           form_jump_dist = max(form_jump_dist, -epsilon+(-form_pos.x)/(form_ray_dir.x));\n        if(form_pos.x > form_size.x && form_ray_dir.x < 0) form_jump_dist = max(form_jump_dist, -epsilon+(form_size.x-form_pos.x)/(form_ray_dir.x));\n        if(form_pos.y < 0 && form_ray_dir.y > 0)           form_jump_dist = max(form_jump_dist, -epsilon+(-form_pos.y)/(form_ray_dir.y));\n        if(form_pos.y > form_size.y && form_ray_dir.y < 0) form_jump_dist = max(form_jump_dist, -epsilon+(form_size.y-form_pos.y)/(form_ray_dir.y));\n        if(form_pos.z < 0 && form_ray_dir.z > 0)           form_jump_dist = max(form_jump_dist, -epsilon+(-form_pos.z)/(form_ray_dir.z));\n        if(form_pos.z > form_size.z && form_ray_dir.z < 0) form_jump_dist = max(form_jump_dist, -epsilon+(form_size.z-form_pos.z)/(form_ray_dir.z));\n\n        form_pos += form_jump_dist*form_ray_dir;\n\n        vec3 form_hit_pos;\n        float form_hit_dist;\n        ivec3 form_hit_cell;\n        vec3 form_hit_dir;\n        vec3 form_normal;\n        uvec4 form_voxel;\n        bool form_hit = cast_ray(form_materials, form_ray_dir, form_pos, form_size, form_origin, 0, form_hit_pos, form_hit_dist, form_hit_cell, form_hit_dir, form_normal, form_voxel, 100);\n        // if(form_hit && (!hit || form_jump_dist+form_hit_dist < hit_dist) && b != 13 && b != 12)\n        if(form_hit && (!hit || form_jump_dist+form_hit_dist < hit_dist))\n        {\n            hit = true;\n            hit_pos = apply_rotation(form_orientation, form_hit_pos-form_x_cm)+form_x;\n            hit_dist = form_jump_dist+form_hit_dist;\n            hit_cell = form_hit_cell;\n            hit_dir = form_hit_dir;\n            hit_form = f;\n            normal = apply_rotation(form_orientation, form_normal);\n            voxel = form_voxel;\n            if(voxel.r >= BASE_CELL_MAT) voxel.r += forms[f].cell_material_id;\n        }\n    }\n\n    total_dist += hit_dist;\n    if(hit)\n    {\n        gl_FragDepth = 1.0f/total_dist;\n\n        uint material_id = mat(voxel);\n        // float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        frag_color.rgb += emission;\n\n        vec3 spotlight_dir = normalize(vec3(-1.4,-0.8,1));\n\n        vec3 reflection_dir = normal;\n\n        float light_value = 0.5*dot(reflection_dir, spotlight_dir)+0.5+0.2;\n        light_value *= 0.5*dot(camera_pos, camera_pos)/sq(total_dist);\n\n        frag_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)*light_value;\n    }\n    else\n    {\n        discard;\n    }\n\n    if(hit_form == highlight_form && hit_cell == highlight_cell)\n    {\n        frag_color.rgb += vec3(0.5,0.5,0.5);\n    }\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n}\n"; glShaderSource(render_editor_voxels_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_editor_voxels_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_editor_voxels_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_editor_voxels_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_editor_voxels_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_editor_voxels_program, render_editor_voxels_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_editor_voxels_program);glDetachShader(render_editor_voxels_program, render_editor_voxels_program_GL_VERTEX_SHADER); glDeleteShader(render_editor_voxels_program_GL_VERTEX_SHADER); 
glDetachShader(render_editor_voxels_program, render_editor_voxels_program_GL_FRAGMENT_SHADER); glDeleteShader(render_editor_voxels_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_editor_voxels_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_editor_voxels_program, available_memory, 0, info_log); log_error(info_log); }render_prepass_program = glCreateProgram(); assert(render_prepass_program, "could not create render_prepass_program, GL error", glGetError());
 GLuint render_prepass_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_prepass_program_GL_VERTEX_SHADER, "could not create render_prepass_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_prepass_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_prepass_program_GL_VERTEX_SHADER); glGetShaderiv(render_prepass_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_prepass_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_prepass_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_prepass_program, render_prepass_program_GL_VERTEX_SHADER); 

 GLuint render_prepass_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_prepass_program_GL_FRAGMENT_SHADER, "could not create render_prepass_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec3 voxel_x;\nlayout(location = 1) out vec4 voxel_orientation;\nlayout(location = 2) out uvec4 voxel_data;\nlayout(location = 3) out vec4 voxel_color;\n\nlayout(location = 0) uniform mat3 camera_axes;\nlayout(location = 1) uniform vec3 camera_pos;\nlayout(location = 2) uniform sampler2D material_visual_properties;\nlayout(location = 3) uniform usampler3D materials;\nlayout(location = 4) uniform usampler3D active_regions;\nlayout(location = 5) uniform usampler3D occupied_regions;\nlayout(location = 6) uniform isampler3D body_materials;\nlayout(location = 7) uniform ivec3 size;\nlayout(location = 8) uniform ivec3 origin;\nlayout(location = 9) uniform sampler2D lightprobe_color;\nlayout(location = 10) uniform sampler2D lightprobe_depth;\nlayout(location = 11) uniform sampler2D lightprobe_x;\nlayout(location = 12) uniform sampler2D blue_noise_texture;\nlayout(location = 13) uniform int frame_number;\nlayout(location = 14) uniform int n_bodies;\n\n// #define DEBUG_DOTS\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec3 quasinoise_3(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    int cell_material_id;\n    int form_id;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nint body_cell_material_id;\nint body_form_id;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n\n    body_cell_material_id = bodies[b].cell_material_id;\n    body_form_id = bodies[b].form_id;\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, uint medium, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(pos);\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n\n        #ifdef occupied_regions\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(pos);\n        }\n        else\n        #endif\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != medium)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            #ifndef RAY_CAST_IGNORE_DEPTH\n            int depth = depth(voxel);\n            if(depth >= 3\n               // #ifdef ACTIVE_REGIONS\n               // && texelFetch(active_regions, ipos>>4, 0).r == 0\n               // #endif //ACTIVE_REGIONS\n                )\n            {\n                float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                pos += ray_dir*skip_dist;\n                hit_dist += skip_dist;\n                ipos = ivec3(pos);\n            }\n            #endif\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                float weight = sq(0.5*dot(normal, dir)+0.5)+0.2;\n                // float weight = 1.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+sq(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    vec3 pos = camera_pos;\n\n    uint medium = texelFetch(materials, ivec3(pos), 0).r;\n\n    voxel_data = uvec4(0,0,0,0);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 0;\n\n    voxel_orientation = vec4(1,0,0,0);\n\n    float bounding_jump_dist = 0.0;\n    if(pos.x < 0 && ray_dir.x > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += bounding_jump_dist*ray_dir;\n    total_dist += bounding_jump_dist;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    uvec4 voxel;\n    bool hit = cast_ray(materials, ray_dir, pos, size, origin, medium, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 200);\n    // bool hit = coarse_cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n    // voxel = texelFetch(materials, hit_cell, 0);\n\n    if(hit)\n    {\n        // normal = normalize(unnormalized_gradient(materials, hit_cell));\n        voxel_x = vec3(hit_cell)+0.5;\n    }\n\n    for(int b = 0; b < n_bodies; b++)\n    {\n        vec3 body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n        vec3 body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n        vec4 body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n        ivec3 body_size = ivec3(bodies[b].size_x,\n                                bodies[b].size_y,\n                                bodies[b].size_z);\n        ivec3 body_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n\n        //ray info in the bodies frame\n        vec3 body_pos = apply_rotation(conjugate(body_orientation), pos-body_x) + body_x_cm;\n        vec3 body_ray_dir = apply_rotation(conjugate(body_orientation), ray_dir);\n\n        float body_jump_dist = 0.0;\n        if(body_pos.x < 0 && body_ray_dir.x > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.x)/(body_ray_dir.x));\n        if(body_pos.x > body_size.x && body_ray_dir.x < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.x-body_pos.x)/(body_ray_dir.x));\n        if(body_pos.y < 0 && body_ray_dir.y > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.y)/(body_ray_dir.y));\n        if(body_pos.y > body_size.y && body_ray_dir.y < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.y-body_pos.y)/(body_ray_dir.y));\n        if(body_pos.z < 0 && body_ray_dir.z > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.z)/(body_ray_dir.z));\n        if(body_pos.z > body_size.z && body_ray_dir.z < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.z-body_pos.z)/(body_ray_dir.z));\n\n        body_pos += body_jump_dist*body_ray_dir;\n\n        vec3 body_hit_pos;\n        float body_hit_dist;\n        ivec3 body_hit_cell;\n        vec3 body_hit_dir;\n        vec3 body_normal;\n        uvec4 body_voxel;\n        bool body_hit = cast_ray(body_materials, body_ray_dir, body_pos, body_size, body_origin, 0, body_hit_pos, body_hit_dist, body_hit_cell, body_hit_dir, body_normal, body_voxel, 100);\n        // if(body_hit && (!hit || body_jump_dist+body_hit_dist < hit_dist) && b != 13 && b != 12)\n        if(body_hit && (!hit || body_jump_dist+body_hit_dist < hit_dist))\n        {\n            hit = true;\n            hit_pos = apply_rotation(body_orientation, body_hit_pos-body_x_cm)+body_x;\n            hit_dist = body_jump_dist+body_hit_dist;\n            hit_cell = body_hit_cell;\n            hit_dir = body_hit_dir;\n            normal = apply_rotation(body_orientation, body_normal);\n            voxel = body_voxel;\n            if(voxel.r >= BASE_CELL_MAT) voxel.r += bodies[b].cell_material_id;\n            voxel_orientation = body_orientation;\n            voxel_x = apply_rotation(body_orientation, vec3(body_hit_cell)-body_x_cm+0.5)+body_x;\n        }\n    }\n\n    vec4 transmission = vec4(1);\n\n    voxel_color = vec4(0);\n\n    total_dist += hit_dist;\n    if(hit)\n    {\n        float initial_transmission = exp(-opacity(mat(medium))*hit_dist);\n\n        voxel_data = voxel;\n        gl_FragDepth = 1.0f/total_dist;\n\n        for(int i = 0; i < 5; i++)\n        {\n            if(opacity(mat(voxel)) >= 1) break;\n            vec3 ray_pos = hit_pos;\n            if(ivec3(ray_pos) != hit_cell) ray_pos += 0.001*ray_dir;\n            float c = dot(ray_dir, normal);\n            float r = refractive_index(medium)/refractive_index(mat(voxel));\n            float square = 1.0-sq(r)*(1.0-sq(c));\n            if(square > 0) ray_dir = r*ray_dir+(-r*c+sign(c)*sqrt(square))*normal;\n            else ray_dir = ray_dir - 2*c*normal; //total internal reflection\n            // ray_dir = normalize(ray_dir);\n            medium = mat(voxel);\n            bool hit = cast_ray(materials, ray_dir, ray_pos, size, origin, medium, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 200);\n\n            if(hit)\n            {\n                transmission *= exp(-opacity(mat(medium))*hit_dist);\n            }\n            else\n            {\n                break;\n            }\n\n            if(dot(transmission, transmission) < 0.001) break;\n\n            uint material_id = voxel.r;\n            float roughness = get_roughness(material_id);\n            vec3 emission = get_emission(material_id);\n\n            // voxel_color.rgb += -(emission)*dot(normal, ray_dir);\n            voxel_color.rgb += emission;\n\n            //TODO: actual blackbody color\n            voxel_color.rgb += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n            voxel_color.rgb += vec3(0.7,0.3,1.0)*clamp((1.0/15.0)*(float(volt(voxel))), 0.0, 1.0);\n\n            vec3 reflection_dir = normal;\n            vec2 sample_depth;\n            voxel_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)\n                *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n            voxel_color *= transmission;\n        }\n        voxel_color.a = initial_transmission; //pretty hacky, pretty sure I should restructure rendering stuff later\n    }\n}\n"; glShaderSource(render_prepass_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_prepass_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_prepass_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_prepass_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_prepass_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_prepass_program, render_prepass_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_prepass_program);glDetachShader(render_prepass_program, render_prepass_program_GL_VERTEX_SHADER); glDeleteShader(render_prepass_program_GL_VERTEX_SHADER); 
glDetachShader(render_prepass_program, render_prepass_program_GL_FRAGMENT_SHADER); glDeleteShader(render_prepass_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_prepass_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_prepass_program, available_memory, 0, info_log); log_error(info_log); }render_world_program = glCreateProgram(); assert(render_world_program, "could not create render_world_program, GL error", glGetError());
 GLuint render_world_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_world_program_GL_VERTEX_SHADER, "could not create render_world_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_world_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_world_program_GL_VERTEX_SHADER); glGetShaderiv(render_world_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_world_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_world_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_world_program, render_world_program_GL_VERTEX_SHADER); 

 GLuint render_world_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_world_program_GL_FRAGMENT_SHADER, "could not create render_world_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\nlayout(location = 1) out vec3 normal;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform vec3 camera_pos;\nlayout(location = 3) uniform sampler2D material_visual_properties;\nlayout(location = 4) uniform sampler2D prepass_x;\nlayout(location = 5) uniform sampler2D prepass_orientation;\nlayout(location = 6) uniform usampler2D prepass_voxel;\nlayout(location = 7) uniform sampler2D prepass_color;\nlayout(location = 8) uniform vec2 prepass_resolution;\nlayout(location = 9) uniform sampler2D lightprobe_color;\nlayout(location = 10) uniform sampler2D lightprobe_depth;\nlayout(location = 11) uniform sampler2D lightprobe_x;\nlayout(location = 12) uniform sampler2D blue_noise_texture;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec3 quasinoise_3(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                float weight = sq(0.5*dot(normal, dir)+0.5)+0.2;\n                // float weight = 1.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+sq(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    frag_color = vec4(0,0,0,1);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 10000;\n\n    ivec2 prepass_coord = ivec2((0.5*screen_pos+0.5)*prepass_resolution-0.5);\n\n    uvec4 voxel;\n    vec3 hit_pos;\n\n    float transmission = 1;\n\n    ivec2 d = ivec2(0);\n    for(d.y = 0; d.y <= 1; d.y++)\n        for(d.x = 0; d.x <= 1; d.x++)\n        {\n            vec3 x = texelFetch(prepass_x, prepass_coord+d, 0).xyz;\n            vec4 orientation = texelFetch(prepass_orientation, prepass_coord+d, 0);\n            vec4 inv_orientation = conjugate(orientation);\n\n            vec3 cube_ray_dir = apply_rotation(inv_orientation, ray_dir);\n            vec3 cube_ray_pos = apply_rotation(inv_orientation, camera_pos-x);\n\n            vec3 ray_sign = sign_not_zero(cube_ray_dir);\n            cube_ray_dir *= -ray_sign;\n            cube_ray_pos *= -ray_sign;\n            cube_ray_pos -= 0.5; //origin placed at front-most corner\n            vec3 dist = -cube_ray_pos/cube_ray_dir;\n            vec3 max_dir = step(dist.zxy, dist.xyz)*step(dist.yzx, dist.xyz);\n            float face_dist = dot(max_dir, dist);\n            vec3 hit_x = cube_ray_pos+face_dist*cube_ray_dir;\n            vec3 outmost_edge = step(hit_x.zxy, hit_x.xyz)*step(hit_x.yzx, hit_x.xyz);\n\n            if(all(greaterThan(hit_x, vec3(-1.0) +face_dist/((270.0/pi)*dot(cube_ray_dir, max_dir)))) &&\n               face_dist < total_dist && face_dist > 0)\n            // if(all(greaterThan(hit_x, vec3(-1.0))) &&\n            //    face_dist < total_dist && face_dist > 0)\n            {\n                total_dist = face_dist;\n                vec4 transmitted_color = texelFetch(prepass_color, prepass_coord+d, 0);\n                transmission = transmitted_color.a;\n                frag_color.rgb = transmitted_color.rgb;\n                voxel = texelFetch(prepass_voxel, prepass_coord+d, 0);\n                normal = apply_rotation(orientation, -ray_sign*max_dir);\n                hit_pos = camera_pos+face_dist*ray_dir;\n                // frag_color.rgb = max_dir;\n            }\n        }\n\n    // {\n    //     ivec2 prepass_coord = ivec2((0.5*screen_pos+0.5)*prepass_resolution);\n\n    //     vec3 x = texelFetch(prepass_x, prepass_coord, 0).xyz;\n    //     vec4 orientation = texelFetch(prepass_orientation, prepass_coord+d, 0);\n    //     vec4 inv_orientation = conjugate(orientation);\n\n    //     vec3 cube_ray_dir = apply_rotation(inv_orientation, ray_dir);\n    //     vec3 cube_ray_pos = apply_rotation(inv_orientation, camera_pos-x);\n\n    //     vec3 ray_sign = sign_not_zero(cube_ray_dir);\n    //     cube_ray_dir *= -ray_sign;\n    //     cube_ray_pos *= -ray_sign;\n    //     cube_ray_pos -= 0.5; //origin placed at front-most corner\n    //     vec3 dist = -cube_ray_pos/cube_ray_dir;\n    //     vec3 max_dir = step(dist.zxy, dist.xyz)*step(dist.yzx, dist.xyz);\n    //     float face_dist = dot(max_dir, dist);\n    //     vec3 hit_x = cube_ray_pos+face_dist*cube_ray_dir;\n    //     vec3 outmost_edge = step(hit_x.zxy, hit_x.xyz)*step(hit_x.yzx, hit_x.xyz);\n\n    //     total_dist = face_dist;\n    //     vec4 transmitted_color = texelFetch(prepass_color, prepass_coord, 0);\n    //     reflectance = 1-transmitted_color.a;\n    //     frag_color.rgb = transmitted_color.rgb;\n    //     voxel = texelFetch(prepass_voxel, prepass_coord, 0);\n    //     normal = apply_rotation(orientation, -ray_sign*max_dir);\n    //     hit_pos = camera_pos+face_dist*ray_dir;\n    //     // frag_color.rgb = max_dir;\n    // }\n\n    {\n        uint material_id = voxel.r;\n        float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        // frag_color.rgb += -(emission)*dot(normal, ray_dir);\n        frag_color.rgb += emission;\n\n        //TODO: actual blackbody color\n        frag_color.rgb += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n        frag_color.rgb += vec3(0.7,0.3,1.0)*clamp((1.0/15.0)*(float(volt(voxel))), 0.0, 1.0);\n\n        vec3 reflection_dir = normal;\n        vec2 sample_depth;\n        frag_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)\n            *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n    }\n    frag_color.rgb *= transmission;\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n    // frag_color.rgb = normal;\n    gl_FragDepth = 1.0f/total_dist;\n}\n"; glShaderSource(render_world_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_world_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_world_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_world_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_world_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_world_program, render_world_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_world_program);glDetachShader(render_world_program, render_world_program_GL_VERTEX_SHADER); glDeleteShader(render_world_program_GL_VERTEX_SHADER); 
glDetachShader(render_world_program, render_world_program_GL_FRAGMENT_SHADER); glDeleteShader(render_world_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_world_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_world_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_program = glCreateProgram(); assert(simulate_body_program, "could not create simulate_body_program, GL error", glGetError());
 GLuint simulate_body_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_body_program_GL_COMPUTE_SHADER, "could not create simulate_body_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\n#define localgroup_size 8\n#define subgroup_size 1\nlayout(local_size_x = localgroup_size, local_size_y = localgroup_size, local_size_z = localgroup_size) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform usampler3D body_materials;\nlayout(location = 4, rgba8ui) uniform uimage3D body_materials_out;\nlayout(location = 5) uniform usampler3D form_materials;\nlayout(location = 6) uniform int n_bodies;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    int cell_material_id;\n    int form_id;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nint body_cell_material_id;\nint body_form_id;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n\n    body_cell_material_id = bodies[b].cell_material_id;\n    body_form_id = bodies[b].form_id;\n}\n\n#define FORM_DATA_BINDING 1\n#ifndef FORM_DATA_BINDING\n#define FORM_DATA_BINDING 0\n#endif\n\nstruct form\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n\n    int cell_material_id;\n    int is_mutating;\n};\n\nivec3 form_materials_origin;\nivec3 form_size;\nvec3  form_x_cm;\nvec3  form_x;\nvec4  form_orientation;\n\nint form_cell_material_id;\nint form_is_mutating;\n\nlayout(std430, binding = FORM_DATA_BINDING) buffer form_data\n{\n    form forms[];\n};\n\nvoid get_form_data(int f)\n{\n    form_materials_origin = ivec3(forms[f].materials_origin_x,\n                                  forms[f].materials_origin_y,\n                                  forms[f].materials_origin_z);\n    form_size = ivec3(forms[f].size_x,\n                      forms[f].size_y,\n                      forms[f].size_z);\n\n    form_x = vec3(forms[f].x_x, forms[f].x_y, forms[f].x_z);\n    form_orientation = vec4(forms[f].orientation_r, forms[f].orientation_x, forms[f].orientation_y, forms[f].orientation_z);\n\n    form_x_cm = vec3(forms[f].x_cm_x, forms[f].x_cm_y, forms[f].x_cm_z);\n\n    form_cell_material_id = forms[f].cell_material_id;\n    form_is_mutating = forms[f].is_mutating;\n}\n\n#define PARTICLE_DATA_BINDING 2\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nstruct body_chunk\n{\n    uint body_id;\n    uint origin_x;\n    uint origin_y;\n    uint origin_z;\n};\n\nlayout(std430, binding = 3) buffer body_chunk_data\n{\n    uint n_body_chunks;\n    body_chunk body_chunks[];\n};\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\nvoid main()\n{\n    uint body_chunk_id = gl_WorkGroupID.x;\n    int bi = int(body_chunks[body_chunk_id].body_id);\n    uvec3 origin = uvec3(body_chunks[body_chunk_id].origin_x, body_chunks[body_chunk_id].origin_y, body_chunks[body_chunk_id].origin_z);\n\n    get_body_data(bi);\n\n    ivec3 pos = ivec3(origin+gl_LocalInvocationID);\n    if(any(greaterThan(pos, body_materials_origin+body_size))) return;\n\n    const int padding = 1;\n\n    // if(bi == 0 && layer == 0 && gl_VertexID == 0)\n    // {\n    //     int dead_index = atomicAdd(n_dead_particles, -1)-1;\n    //     //this assumes particle creation and destruction never happen simutaneously\n    //     uint p = dead_particles[dead_index];\n    //     particles[p].voxel_data = 3|(2<<(6+8))|(8<<(2+16))|(15<<24);\n    //     particles[p].x = bodies[bi].x_x;\n    //     particles[p].y = bodies[bi].x_y;\n    //     particles[p].z = bodies[bi].x_z;\n    //     particles[p].x_dot = bodies[bi].x_dot_x;\n    //     particles[p].y_dot = bodies[bi].x_dot_y;\n    //     particles[p].z_dot = bodies[bi].x_dot_z+5;\n    //     particles[p].alive = true;\n    // }\n\n    if(body_form_id != 0) get_form_data(body_form_id-1);\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    uint rot = rand(rand(rand(frame_number)))%4;\n    int i = 0;\n    ivec2 dir = ivec2(((rot&1)*(2-rot)), (1-(rot&1))*(1-rot));\n\n    uvec4 c  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z), 0);\n    uvec4 u  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z+1), 0);\n    uvec4 d  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z-1), 0);\n    uvec4 r  = texelFetch(body_materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z), 0);\n    uvec4 l  = texelFetch(body_materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z), 0);\n    uvec4 f  = texelFetch(body_materials, ivec3(pos.x-dir.y, pos.y+dir.x, pos.z), 0);\n    uvec4 b  = texelFetch(body_materials, ivec3(pos.x+dir.y, pos.y-dir.x, pos.z), 0);\n\n    ivec3 form_pos = pos-body_materials_origin+form_materials_origin;\n    uint form_voxel = texelFetch(form_materials, form_pos, 0).r;\n\n    int spawned_cell = 0;\n\n    uint temp = temp(c);\n    uint volt = 0;\n    uint trig = 0;\n\n    uint mid = mat(c); //material id\n    bool is_cell = mid >= BASE_CELL_MAT;\n    if(is_cell) mid += body_cell_material_id;\n\n    for(int i = 0; i < n_triggers(mid); i++)\n    {\n        uint trigger_data = trigger_info(mid, i);\n        uint condition_type = trigger_data&0xFF;\n        uint action_type = (trigger_data>>8)&0xFF;\n        uint trigger_material = trigger_data>>16;\n        bool condition = false;\n        switch(condition_type)\n        {\n            case trig_always:\n                condition = true;\n                break;\n            case trig_hot:\n                condition = temp > 12;\n                break;\n            case trig_cold:\n                condition = temp <= 4;\n                break;\n            case trig_electric:\n                condition = volt > 0;\n                break;\n            case trig_contact:\n                condition = trig(c) == i;\n                break;\n            default:\n                condition = false;\n        }\n\n        if(condition)\n        {\n            switch(action_type)\n            {\n                case act_grow: {\n                    trig = i+1;\n                    break;\n                }\n                case act_die: {\n                    c = uvec4(0);\n                    break;\n                }\n                case act_heat: {\n                    temp++;\n                    break;\n                }\n                case act_chill: {\n                    temp--;\n                    break;\n                }\n                case act_electrify: {\n                    volt = 3;\n                    break;\n                }\n                case act_explode: {\n                    //TODO: EXPLOSIONS!\n                    break;\n                }\n                case act_spray: {\n                    //create particle of type child_material_id, with velocity in the normal direction\n                    break;\n                }\n                default:\n            }\n            break;\n        }\n    }\n\n    //check if this cell is empty, on the surface, and is filled in the body map\n    //then check for neighbors that are trying to grow\n    if(form_is_mutating==1 && mid != form_voxel)\n    {\n        c = uvec4(0);\n    }\n\n    if(mid != form_voxel && form_voxel != 0 && depth(c) == 0 && frame_number%growth_time(form_voxel) == 0)\n    {\n        c.r = form_voxel;\n    }\n    else if(mid == 0 && all(greaterThan(pos-origin, ivec3(0))) && all(lessThan(pos-origin, ivec3(32-1))))\n    {\n        uvec4 growing_cell = uvec4(0);\n        if(trig(l) != 0)      growing_cell = l;\n        else if(trig(r) != 0) growing_cell = r;\n        else if(trig(u) != 0) growing_cell = u;\n        else if(trig(d) != 0) growing_cell = d;\n        else if(trig(f) != 0) growing_cell = f;\n        else if(trig(b) != 0) growing_cell = b;\n\n        uint growing_mat = mat(growing_cell); //material id\n        if(growing_mat != 0)\n        {\n            bool is_cell = growing_mat >= BASE_CELL_MAT;\n            if(is_cell) growing_mat += body_cell_material_id;\n\n            uint trigger_data = trigger_info(growing_mat, trig(growing_cell)-1);\n            uint condition_type = trigger_data&0xFF;\n            uint action_type = (trigger_data>>8)&0xFF;\n            uint trigger_material = trigger_data>>16;\n\n            if(action_type == act_grow)\n                c.r = mat(growing_cell)+1;\n            else\n                c.r = trigger_material;\n        }\n    }\n\n    // c.r = 1;\n    uvec4 out_voxel = c;\n\n    int depth = MAX_DEPTH-1;\n    bool filledness = mat(c) != 0 && transient(c)==0;\n    if(((mat(u) != 0 && transient(u) == 0) != filledness) ||\n       ((mat(d) != 0 && transient(d) == 0) != filledness) ||\n       ((mat(r) != 0 && transient(r) == 0) != filledness) ||\n       ((mat(l) != 0 && transient(l) == 0) != filledness) ||\n       ((mat(f) != 0 && transient(f) == 0) != filledness) ||\n       ((mat(b) != 0 && transient(b) == 0) != filledness)) depth = 0;\n    else\n    {\n        depth = min(depth, depth(u)+1);\n        depth = min(depth, depth(d)+1);\n        depth = min(depth, depth(r)+1);\n        depth = min(depth, depth(l)+1);\n        depth = min(depth, depth(f)+1);\n        depth = min(depth, depth(b)+1);\n    }\n\n    out_voxel.g = uint(depth);\n    // out_voxel.g = uint(depth) | (phase << 6) | (transient << 7);\n\n    out_voxel.b = temp;\n\n    out_voxel.a = volt | (trig << 4);\n\n    imageStore(body_materials_out, pos, out_voxel);\n}\n"; glShaderSource(simulate_body_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_body_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_body_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_body_program, simulate_body_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_body_program);glDetachShader(simulate_body_program, simulate_body_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_body_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_body_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_physics_program = glCreateProgram(); assert(simulate_body_physics_program, "could not create simulate_body_physics_program, GL error", glGetError());
 GLuint simulate_body_physics_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_body_physics_program_GL_VERTEX_SHADER, "could not create simulate_body_physics_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5*x.xy+0.5;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_body_physics_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_body_physics_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_body_physics_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_physics_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_physics_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_body_physics_program, simulate_body_physics_program_GL_VERTEX_SHADER); 

 GLuint simulate_body_physics_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_body_physics_program_GL_FRAGMENT_SHADER, "could not create simulate_body_physics_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec3 p1;\nlayout(location = 1) out vec3 p2;\nlayout(location = 2) out vec3 p3;\nlayout(location = 3) out vec3 n1;\nlayout(location = 4) out vec3 n2;\nlayout(location = 5) out vec3 n3;\nlayout(location = 6) out uvec3 contact_materials;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform usampler3D materials;\nlayout(location = 2) uniform usampler3D body_materials;\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    int cell_material_id;\n    int form_id;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nint body_cell_material_id;\nint body_form_id;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n\n    body_cell_material_id = bodies[b].cell_material_id;\n    body_form_id = bodies[b].form_id;\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n\nsmooth in vec2 uv;\n\nconst int chunk_size = 256;\n\nconst int padding = 0;\n\n#define N_MAX_COLLISION_POINTS 256\nvoid find_collision_points(out vec3 world_collision_points[N_MAX_COLLISION_POINTS], out ivec3 world_collision_coord[N_MAX_COLLISION_POINTS], out int n_collision_points)\n{\n    n_collision_points = 0;\n\n    //TODO: maybe use space filling curves\n    for(int test_z = -padding; test_z < body_size.z+padding; test_z+=1)\n        for(int test_y = -padding; test_y < body_size.y+padding; test_y+=1)\n            for(int test_x = -padding; test_x < body_size.x+padding; test_x+=1)\n            {\n\n                ivec3 body_coord = ivec3(test_x, test_y, test_z);\n                vec3 world_coord = apply_rotation(body_orientation, vec3(body_coord)+0.5-body_x_cm)+body_x;\n\n                uvec4 body_voxel = texelFetch(body_materials, body_materials_origin+body_coord, 0);\n\n                // if(body_voxel.g == 0 && body_voxel.r > 0)\n                if(signed_depth(body_voxel) == 0)\n                {\n                    ivec3 wvc = ivec3(world_coord); //world_voxel_coord\n                    uvec4 world_voxel = texelFetch(materials, wvc, 0);\n                    vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n                    // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n                    if(signed_depth(world_voxel) <= 0)\n                    {\n                        world_collision_points[n_collision_points] = world_coord;\n                        world_collision_coord[n_collision_points] = wvc;\n                        n_collision_points++;\n                        if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                    }\n\n                    // for(int wz = 0; wz <= 1; wz++)\n                    //     for(int wy = 0; wy <= 1; wy++)\n                    //         for(int wx = 0; wx <= 1; wx++)\n                    //         {\n                    //             ivec3 wvc = ivec3(world_coord-0.5)+ivec3(wx,wy,wz); //world_voxel_coord\n                    //             ivec4 world_voxel = voxelFetch(materials, wvc);\n                    //             vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n                    //             // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n                    //             if(world_voxel.g <= 2)\n                    //             {\n                    //                 world_collision_points[n_collision_points] = world_coord;\n                    //                 world_collision_coord[n_collision_points] = wvc;\n                    //                 n_collision_points++;\n                    //                 if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                    //             }\n                    //         }\n                }\n\n                test_x += max(abs(signed_depth(body_voxel))-1, 0);\n            }\n}\n\n//TODO: have better method of choosing points\nvoid find_surface_points(out vec3 world_collision_points[N_MAX_COLLISION_POINTS], out ivec3 world_collision_coord[N_MAX_COLLISION_POINTS], out int n_collision_points)\n{\n    n_collision_points = 0;\n\n    //TODO: maybe use space filling curves\n    for(int test_z = -padding; test_z < body_size.z+padding; test_z+=1)\n        for(int test_y = -padding; test_y < body_size.y+padding; test_y+=1)\n            for(int test_x = -padding; test_x < body_size.x+padding; test_x+=1)\n            {\n\n                ivec3 body_coord = ivec3(test_x, test_y, test_z);\n                vec3 world_coord = apply_rotation(body_orientation, vec3(body_coord)+0.5-body_x_cm)+body_x;\n\n                uvec4 body_voxel = texelFetch(body_materials, body_materials_origin+body_coord, 0);\n\n                // if(body_voxel.g == 0 && body_voxel.r > 0)\n                if(depth(body_voxel) == 0)\n                {\n                    ivec3 wvc = ivec3(world_coord); //world_voxel_coord\n\n                    world_collision_points[n_collision_points] = world_coord;\n                    world_collision_coord[n_collision_points] = wvc;\n                    n_collision_points++;\n                    if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                }\n\n                test_x += depth(body_voxel);\n            }\n}\n\nvoid main()\n{\n    int b = int(gl_FragCoord.y);\n    // int b = 0;\n\n    get_body_data(b);\n\n    p1 = vec3(0);\n    p2 = vec3(0);\n    p3 = vec3(0);\n    n1 = vec3(0,0,1);\n    n2 = vec3(0,0,1);\n    n3 = vec3(0,0,1);\n    contact_materials = uvec3(0);\n\n    vec3 world_collision_points[N_MAX_COLLISION_POINTS];\n    ivec3 world_collision_coord[N_MAX_COLLISION_POINTS];\n    int n_collision_points = 0;\n\n    find_collision_points(world_collision_points, world_collision_coord, n_collision_points);\n\n    if(n_collision_points == 0)\n        find_surface_points(world_collision_points, world_collision_coord, n_collision_points);\n\n    vec3 impulses[N_MAX_COLLISION_POINTS] = vec3[N_MAX_COLLISION_POINTS](0);\n\n    float d1 = 16;\n    float d2 = 16;\n    float d3 = 16;\n\n    uint best_depth = MAX_DEPTH;\n    float best_rsq = 16;\n    for(int cp = 0; cp < n_collision_points; cp++)\n    {\n        vec3 world_coord = world_collision_points[cp];\n        ivec3 wvc = world_collision_coord[cp]; //world_voxel_coord\n        uvec4 world_voxel = texelFetch(materials, wvc, 0);\n        vec3 r = world_coord-body_x;\n        float rsq = dot(r, r);\n        if(signed_depth(world_voxel) < best_depth || (signed_depth(world_voxel) == best_depth && rsq < best_rsq))\n        {\n            best_depth = signed_depth(world_voxel);\n            best_rsq = rsq;\n            p1 = world_coord;\n            d1 = signed_depth(world_voxel);\n            contact_materials.r = world_voxel.r;\n        }\n    }\n\n    float best_asq = 0;\n    for(int cp = 0; cp < n_collision_points; cp++)\n    {\n        vec3 world_coord = world_collision_points[cp];\n        ivec3 wvc = world_collision_coord[cp]; //world_voxel_coord\n        uvec4 world_voxel = texelFetch(materials, wvc, 0);\n        float asq = dot(world_coord-p1, world_coord-p1);\n        if(asq > best_asq)\n        {\n            best_asq = asq;\n            p2 = world_coord;\n            d2 = signed_depth(world_voxel);\n            contact_materials.g = world_voxel.r;\n        }\n    }\n\n    float best_bsq = -1;\n    for(int cp = 0; cp < n_collision_points; cp++)\n    {\n        vec3 world_coord = world_collision_points[cp];\n        ivec3 wvc = world_collision_coord[cp]; //world_voxel_coord\n        uvec4 world_voxel = texelFetch(materials, wvc, 0);\n        vec3 ab = normalize(p2-p1);\n        vec3 ac = world_coord-p1;\n        float bsq = dot(ac, ac) - sq(dot(ac, ab));\n        if(bsq > best_bsq)\n        {\n            best_bsq = bsq;\n            p3 = world_coord;\n            d3 = signed_depth(world_voxel);\n            contact_materials.b = world_voxel.r;\n        }\n    }\n\n    d1 += MAX_DEPTH;\n    d2 += MAX_DEPTH;\n    d3 += MAX_DEPTH;\n\n    ivec3 ip1 = ivec3(p1);\n    n1 = unnormalized_gradient(materials, ip1);\n    n1 = d1*normalize(n1);\n\n    ivec3 ip2 = ivec3(p2);\n    n2 = unnormalized_gradient(materials, ip2);\n    n2 = d2*normalize(n1);\n\n    ivec3 ip3 = ivec3(p3);\n    n3 = unnormalized_gradient(materials, ip3);\n    n3 = d3*normalize(n1);\n}\n"; glShaderSource(simulate_body_physics_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_body_physics_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_body_physics_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_physics_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_physics_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_body_physics_program, simulate_body_physics_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_body_physics_program);glDetachShader(simulate_body_physics_program, simulate_body_physics_program_GL_VERTEX_SHADER); glDeleteShader(simulate_body_physics_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_body_physics_program, simulate_body_physics_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_body_physics_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_body_physics_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_physics_program, available_memory, 0, info_log); log_error(info_log); }simulate_chunk_program = glCreateProgram(); assert(simulate_chunk_program, "could not create simulate_chunk_program, GL error", glGetError());
 GLuint simulate_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_chunk_program_GL_VERTEX_SHADER, "could not create simulate_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 r;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 4) uniform usampler3D active_regions_in;\nlayout(location = 6) uniform writeonly uimage3D occupied_regions_out;\n\nout vec3 p;\n\nvoid main()\n{\n    int z = layer>>4;\n    int y = int(X.y);\n    int x = int(X.x);\n\n    p=vec3(16*x,16*y,layer);\n\n    gl_Position = vec4(0.0/0.0,0.0/0.0,0,1);\n\n    float scale = 2.0f/32.0f;\n\n    uint region_active = texelFetch(active_regions_in, ivec3(x, y, z), 0).r;\n    if(region_active != 0)\n    {\n        if(gl_VertexID == 0 && layer%16 == 0) imageStore(occupied_regions_out, ivec3(x,y,z), uvec4(0,0,0,0));\n        gl_Position.xy = -1.0f+scale*(r+X);\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_chunk_program, simulate_chunk_program_GL_VERTEX_SHADER); 

 GLuint simulate_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_chunk_program_GL_FRAGMENT_SHADER, "could not create simulate_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out uvec4 out_voxel;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int frame_number;\nlayout(location = 2) uniform sampler2D material_physical_properties;\nlayout(location = 3) uniform usampler3D materials;\nlayout(location = 5) uniform writeonly uimage3D active_regions_out;\nlayout(location = 6) uniform writeonly uimage3D occupied_regions_out;\nlayout(location = 7) uniform int update_cells;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\nin vec3 p;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nconst int chunk_size = 256;\n\nuint conduction_dir(ivec3 pos)\n{\n    return rand(rand(frame_number+rand(rand(rand(pos.z)+pos.y)+pos.x)))%6;\n}\n\nvoid main()\n{\n    float scale = 1.0/chunk_size;\n    // ivec2 pos = ivec2(chunk_size*uv);\n    // ivec2 pos = ivec2(gl_FragCoord.xy);\n    ivec3 pos = ivec3(p);\n    ivec3 cell_p;\n    cell_p.xy = ivec2(gl_FragCoord.xy)%16;\n    cell_p.z = pos.z%16;\n    pos.xy += cell_p.xy;\n\n    uvec4 c  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z),0);\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    // uint rot = rand(rand(rand(frame_number)))%4;\n    uint flow = flow(c);\n    int i = 0;\n    ivec2 dir = ivec2(((flow&1)*(2-flow)), (1-(flow&1))*(1-flow)); //(0,1), (1,0), (0,-1), (-1,0)\n\n    ivec3 pu = ivec3(pos.x, pos.y, pos.z+1);\n    ivec3 pd = ivec3(pos.x, pos.y, pos.z-1);\n    ivec3 pr = ivec3(pos.x+dir.x, pos.y+dir.y, pos.z);\n    ivec3 pl = ivec3(pos.x-dir.x, pos.y-dir.y, pos.z);\n    ivec3 pf = ivec3(pos.x-dir.y, pos.y+dir.x, pos.z);\n    ivec3 pb = ivec3(pos.x+dir.y, pos.y-dir.x, pos.z);\n\n    uvec4 u  = texelFetch(materials, pu, 0);\n    uvec4 d  = texelFetch(materials, pd, 0);\n    uvec4 r  = texelFetch(materials, pr, 0);\n    uvec4 l  = texelFetch(materials, pl, 0);\n    uvec4 f  = texelFetch(materials, pf, 0);\n    uvec4 b  = texelFetch(materials, pb, 0);\n\n    uvec4 dr = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z-1),0);\n    uvec4 ur = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z+1),0);\n\n    uvec4 ul = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z+1),0);\n    uvec4 ll = texelFetch(materials, ivec3(pos.x-2*dir.x, pos.y-2*dir.y, pos.z),0);\n    uvec4 dl = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z-1),0);\n\n    uvec4 uu = texelFetch(materials, ivec3(pos.x, pos.y, pos.z+2),0);\n\n    if(update_cells == 1 && frame_number != 0)\n    {\n        if(mat(c) == 0)\n        { //central cell is empty\n\n            //check if upper cell fell           , liquids and sands\n            //then check if upper left cell fell , liquids and sands\n            //then check if left cell flowed     , liquids\n            if(mat(u) != 0 && phase(u) >= phase_sand && transient(u)==0)\n                c = u;\n            else if(mat(ul) != 0 && mat(l) != 0 && mat(u) == 0 && phase(ul) >= phase_sand && flow(ul) == flow && transient(ul)==0)\n                c = ul;\n            else if(mat(l) != 0 && mat(dl) != 0 && mat(d) != 0 && phase(l) == phase_liquid && flow(l) == flow && transient(l)==0)\n                c = l;\n            else if(mat(d) != 0 && phase(d) == phase_gas && transient(d)==0)\n                c = d;\n            else if(mat(dl) != 0 && mat(l) != 0 && mat(d) == 0 && phase(dl) == phase_gas && flow(dl) == flow && transient(dl)==0)\n                c = dl;\n            else if(mat(l) != 0 && mat(ul) != 0 && mat(u) != 0 && phase(l) == phase_gas && flow(l) == flow && transient(l)==0)\n                c = l;\n            else\n            {\n                // flow = rand(rand(rand(frame_number+pos.x+pos.y+pos.z)))%4;\n                flow = (frame_number)%4;\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 l = texelFetch(materials, ivec3(pos.x-test_dir.x, pos.y-test_dir.y, pos.z),0);\n                    if(mat(l) != 0 && flow(l) == fl && phase(l) >= phase_sand)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 ul = texelFetch(materials, ivec3(pos.x-test_dir.x, pos.y-test_dir.y, pos.z-1),0);\n                    if(mat(ul) != 0 && flow(ul) == fl && phase(ul) >= phase_liquid)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n            }\n            //might be better to multiply things by 0 instead of branching\n        }\n        else if(phase(c) != phase_solid && transient(c)==0)\n        { //if the cell is not empty and not solid check if it fell or flew\n            bool fall_allowed = (pos.z > 0 && (mat(d) == 0 || (mat(dr) == 0 && mat(r) == 0 && flow(dr) == flow)) && phase(c) >= phase_sand);\n            bool flow_allowed = (pos.z > 0 && mat(r) == 0\n                                 && mat(dr) != 0 && mat(d) != 0\n                                 && (mat(ur) == 0 || phase(ur) < phase_sand || flow(ur) != flow)\n                                 && (mat(u) == 0 || phase(u) < phase_sand)\n                                 && phase(c) == phase_liquid && flow(r) == flow);\n\n            //TODO: check for other higher priority motions, in addition to uu falling\n            bool float_allowed = (pos.z < 511 && (mat(u) == 0 || (mat(ur) == 0 && mat(r) == 0 && flow(ur) == flow)) && phase(c) == phase_gas && (mat(uu) == 0 || (phase(uu) <= phase_solid)));\n\n            bool gas_flow_allowed = (pos.z > 0 && mat(r) == 0\n                                     && mat(ur) != 0 && mat(u) != 0\n                                     && (mat(dr) == 0 || phase(dr) < phase_sand || flow(dr) != flow)\n                                     && (mat(d) == 0 || phase(d) < phase_sand)\n                                     && phase(c) == phase_gas && flow(r) == flow);\n\n            if(fall_allowed || flow_allowed || float_allowed || gas_flow_allowed) c = uvec4(0);\n            else\n            {\n                flow = rand(rand(rand(frame_number)))%4;\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 r = texelFetch(materials, ivec3(pos.x+test_dir.x, pos.y+test_dir.y, pos.z),0);\n                    if(mat(r) == 0)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 dr = texelFetch(materials, ivec3(pos.x+test_dir.x, pos.y+test_dir.y, pos.z-1),0);\n                    if(mat(dr) == 0)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    int depth = MAX_DEPTH-1;\n    uint permaterial = permaterial(c);\n    if((permaterial(u) != permaterial) ||\n       (permaterial(d) != permaterial) ||\n       (permaterial(r) != permaterial) ||\n       (permaterial(l) != permaterial) ||\n       (permaterial(f) != permaterial) ||\n       (permaterial(b) != permaterial)) depth = 0;\n    else\n    {\n        depth = min(depth, depth(u)+1);\n        depth = min(depth, depth(d)+1);\n        depth = min(depth, depth(r)+1);\n        depth = min(depth, depth(l)+1);\n        depth = min(depth, depth(f)+1);\n        depth = min(depth, depth(b)+1);\n    }\n\n    int volt = int(volt(c));\n\n    if(conductivity(mat(c)) > 0)\n    {\n        uint cd = conduction_dir(pos);\n        int dvolt = 0;\n        int nvolt = volt;\n        int neighbors = 0;\n        if(mat(r)!=0 && conductivity(mat(r))>0){if(volt(r)>0)neighbors++; nvolt = max(nvolt, int(volt(r)));}\n        if(mat(l)!=0 && conductivity(mat(l))>0){if(volt(l)>0)neighbors++; nvolt = max(nvolt, int(volt(l)));}\n        if(mat(u)!=0 && conductivity(mat(u))>0){if(volt(u)>0)neighbors++; nvolt = max(nvolt, int(volt(u)));}\n        if(mat(d)!=0 && conductivity(mat(d))>0){if(volt(d)>0)neighbors++; nvolt = max(nvolt, int(volt(d)));}\n        if(mat(f)!=0 && conductivity(mat(f))>0){if(volt(f)>0)neighbors++; nvolt = max(nvolt, int(volt(f)));}\n        if(mat(b)!=0 && conductivity(mat(b))>0){if(volt(b)>0)neighbors++; nvolt = max(nvolt, int(volt(b)));}\n        dvolt = nvolt-volt;\n        if((rand(frame_number+rand(rand(rand(pos.z)+pos.y)+pos.x))%7)!=0) dvolt--;\n        // if(volt <= 8 && neighbors == 0) dvolt--;\n        if(dvolt > 0 && neighbors > 1) dvolt = 0;\n        volt = volt+dvolt;\n        volt = clamp(volt, 0, 15);\n    }\n    else\n    {\n        volt = 0;\n    }\n    if(frame_number == 0) volt = 0;\n\n    uint temp = temp(c);\n    // if(mat(c) == 4) temp = 255; else\n    if(mat(c) != 0)\n    {\n        float C = heat_capacity(mat(c));\n        float Q = 0;\n        //NOTE: this would save some divisions by storing thermal resistivity,\n        //      but it's nicer to define materials in terms of conductivity so 0 has well defined behavior\n        float r_c = 1.0/thermal_conductivity(mat(c));\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(u))); Q += k*(float(temp(u))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(d))); Q += k*(float(temp(d))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(r))); Q += k*(float(temp(r))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(l))); Q += k*(float(temp(l))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(f))); Q += k*(float(temp(f))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(b))); Q += k*(float(temp(b))-float(temp));}\n\n        //NOTE: there might be oscillations due to neighboring temperatures changing past each other,\n        //      but fixing would require each voxel knowing how much heat it's neighbors are getting\n        //      hopefully won't be a problem since everything will eventually converge to room temp\n\n        float dtemp = Q/C;\n        float dtemp_i = round(dtemp);\n        float dtemp_f = 32.0*(dtemp-dtemp_i);\n\n        if(dtemp_f < 0 && dtemp_f > -1.0) dtemp_f = -1.0;\n\n        if((frame_number+rand(rand(rand(rand(pos.z)+pos.y)+pos.x)))%32 < int(abs(dtemp_f))) dtemp_i += sign(dtemp_f);\n        temp = uint(clamp(float(temp)+dtemp_i, 0.0, 255.0));\n\n        // if(avg_temp.x > float(temp)) temp++;\n        // else if(avg_temp.x < float(temp)) temp--;\n    }\n    else temp = 100;\n\n    // temp = clamp(temp+abs((volt-int(volt(c)))), 0u, 255u);\n    temp = clamp(temp+volt, 0u, 255u);\n\n    if(mat(c) == 6 && temp < 128) c.r = 0;\n\n    uint phase = phase_solid;\n    if(hardness(mat(c)) == 0.0\n       || (mat(u) == 0 && mat(d) == 0 && mat(r) == 0 && mat(l) == 0 && mat(f) == 0 && mat(b) == 0)) phase = phase_sand;\n    if(float(temp) > melting_point(mat(c))) phase = phase_liquid;\n    if(float(temp) > boiling_point(mat(c))) phase = phase_gas;\n\n    out_voxel = c;\n\n    uint transient = transient(out_voxel);\n    if(transient == 1)\n    {\n        out_voxel.r = 0;\n        transient = 0;\n    }\n\n    out_voxel.g = uint(depth) | (phase << 5) | (transient << 7);\n\n    out_voxel.b = temp;\n\n    out_voxel.a = volt | (flow<<4);\n\n    // bool changed = c.r != out_voxel.r || c.g != out_voxel.g || c.b != out_voxel.b;\n    // bool changed = c.r != out_voxel.r || c.g != out_voxel.g;\n    bool changed = c.r != out_voxel.r || c.g != out_voxel.g || (int(c.b) != int(out_voxel.b) && out_voxel.b > 128) || volt != volt(c) || volt > 0;\n    if(changed)\n    {\n        imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.x==15) imageStore(active_regions_out, ivec3(pos.x/16+1, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.x== 0) imageStore(active_regions_out, ivec3(pos.x/16-1, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.y==15) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16+1, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.y== 0) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16-1, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.z==15) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16+1), uvec4(1,0,0,0));\n        if(cell_p.z== 0) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16-1), uvec4(1,0,0,0));\n    }\n\n    if(c.r > 0) imageStore(occupied_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n}\n"; glShaderSource(simulate_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_chunk_program, simulate_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_chunk_program);glDetachShader(simulate_chunk_program, simulate_chunk_program_GL_VERTEX_SHADER); glDeleteShader(simulate_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_chunk_program, simulate_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_chunk_program, available_memory, 0, info_log); log_error(info_log); }simulate_chunk_atomic_program = glCreateProgram(); assert(simulate_chunk_atomic_program, "could not create simulate_chunk_atomic_program, GL error", glGetError());
 GLuint simulate_chunk_atomic_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, "could not create simulate_chunk_atomic_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\n#define localgroup_size 8\n#define subgroup_size 2\nlayout(local_size_x = localgroup_size, local_size_y = localgroup_size, local_size_z = localgroup_size) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3, rgba8ui) uniform uimage3D materials_out;\nlayout(location = 4) uniform usampler3D active_regions_in;\nlayout(location = 5) uniform writeonly uimage3D active_regions_out;\nlayout(location = 6) uniform writeonly uimage3D occupied_regions_out;\nlayout(location = 7) uniform int update_cells;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nuint conduction_dir(ivec3 pos)\n{\n    return rand(rand(frame_number+rand(rand(rand(pos.z)+pos.y)+pos.x)))%6;\n}\n\nbool c_active = false;\nbool u_active = false;\nbool d_active = false;\nbool r_active = false;\nbool l_active = false;\nbool f_active = false;\nbool b_active = false;\n\nvoid simulate_voxel(ivec3 pos, ivec3 rpos)\n{\n    ivec3 cell_p = pos%16;\n    // ivec3 cell_p = gl_LocalInvocationID.xyz;\n    // ivec3 rpos = gl_WorkGroupID.xyz;\n\n    if(cell_p == ivec3(0,0,0)) imageStore(occupied_regions_out, rpos, uvec4(0,0,0,0));\n\n    uvec4 c  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z),0);\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    // uint rot = rand(rand(rand(frame_number)))%4;\n    uint flow = flow(c);\n    int i = 0;\n    ivec2 dir = ivec2(((flow&1)*(2-flow)), (1-(flow&1))*(1-flow)); //(0,1), (1,0), (0,-1), (-1,0)\n\n    ivec3 pu = ivec3(pos.x, pos.y, pos.z+1);\n    ivec3 pd = ivec3(pos.x, pos.y, pos.z-1);\n    ivec3 pr = ivec3(pos.x+dir.x, pos.y+dir.y, pos.z);\n    ivec3 pl = ivec3(pos.x-dir.x, pos.y-dir.y, pos.z);\n    ivec3 pf = ivec3(pos.x-dir.y, pos.y+dir.x, pos.z);\n    ivec3 pb = ivec3(pos.x+dir.y, pos.y-dir.x, pos.z);\n\n    uvec4 u  = texelFetch(materials, pu, 0);\n    uvec4 d  = texelFetch(materials, pd, 0);\n    uvec4 r  = texelFetch(materials, pr, 0);\n    uvec4 l  = texelFetch(materials, pl, 0);\n    uvec4 f  = texelFetch(materials, pf, 0);\n    uvec4 b  = texelFetch(materials, pb, 0);\n\n    uvec4 dr = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z-1),0);\n    uvec4 ur = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z+1),0);\n\n    uvec4 ul = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z+1),0);\n    uvec4 ll = texelFetch(materials, ivec3(pos.x-2*dir.x, pos.y-2*dir.y, pos.z),0);\n    uvec4 dl = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z-1),0);\n\n    uvec4 uu = texelFetch(materials, ivec3(pos.x, pos.y, pos.z+2),0);\n\n    if(update_cells == 1 && frame_number != 0)\n    {\n        if(mat(c) == 0)\n        { //central cell is empty\n\n            //check if upper cell fell           , liquids and sands\n            //then check if upper left cell fell , liquids and sands\n            //then check if left cell flowed     , liquids\n            if(mat(u) != 0 && phase(u) >= phase_sand && transient(u)==0)\n                c = u;\n            else if(mat(ul) != 0 && mat(l) != 0 && mat(u) == 0 && phase(ul) >= phase_sand && flow(ul) == flow && transient(ul)==0)\n                c = ul;\n            else if(mat(l) != 0 && mat(dl) != 0 && mat(d) != 0 && (phase(d) >= phase_liquid || phase(dl) >= phase_liquid) && phase(l) == phase_liquid && flow(l) == flow && transient(l)==0)\n                c = l;\n            else if(mat(d) != 0 && phase(d) == phase_gas && transient(d)==0)\n                c = d;\n            else if(mat(dl) != 0 && mat(l) != 0 && mat(d) == 0 && phase(dl) == phase_gas && flow(dl) == flow && transient(dl)==0)\n                c = dl;\n            else if(mat(l) != 0 && mat(ul) != 0 && mat(u) != 0 && phase(l) == phase_gas && flow(l) == flow && transient(l)==0)\n                c = l;\n            else\n            {\n                // flow = rand(rand(rand(frame_number+pos.x+pos.y+pos.z)))%4;\n                flow = (frame_number)%4;\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 l = texelFetch(materials, ivec3(pos.x-test_dir.x, pos.y-test_dir.y, pos.z),0);\n                    if(mat(l) != 0 && flow(l) == fl && phase(l) >= phase_sand)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 ul = texelFetch(materials, ivec3(pos.x-test_dir.x, pos.y-test_dir.y, pos.z-1),0);\n                    if(mat(ul) != 0 && flow(ul) == fl && phase(ul) >= phase_liquid)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n            }\n            //might be better to multiply things by 0 instead of branching\n        }\n        else if(phase(c) != phase_solid && transient(c)==0)\n        { //if the cell is not empty and not solid check if it fell or flew\n            bool fall_allowed = (pos.z > 0 && (mat(d) == 0 || (mat(dr) == 0 && mat(r) == 0 && flow(dr) == flow)) && phase(c) >= phase_sand);\n            bool flow_allowed = (pos.z > 0 && mat(r) == 0\n                                 && (mat(ur) == 0 || phase(ur) < phase_sand || flow(ur) != flow)\n                                 && (mat(u) == 0 || phase(u) < phase_sand)\n                                 && (phase(dr) >= phase_liquid || phase(d) >= phase_liquid) && phase(c) == phase_liquid && flow(r) == flow);\n\n            //TODO: check for other higher priority motions, in addition to uu falling\n            bool float_allowed = (pos.z < 511 && (mat(u) == 0 || (mat(ur) == 0 && mat(r) == 0 && flow(ur) == flow)) && phase(c) == phase_gas && (mat(uu) == 0 || (phase(uu) <= phase_solid)));\n\n            bool gas_flow_allowed = (pos.z > 0 && mat(r) == 0\n                                     && mat(ur) != 0 && mat(u) != 0\n                                     && (mat(dr) == 0 || phase(dr) < phase_sand || flow(dr) != flow)\n                                     && (mat(d) == 0 || phase(d) < phase_sand)\n                                     && phase(c) == phase_gas && flow(r) == flow);\n\n            if(fall_allowed || flow_allowed || float_allowed || gas_flow_allowed) c = uvec4(0);\n            else\n            {\n                // flow = rand(rand(rand(frame_number)))%4;\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 r = texelFetch(materials, ivec3(pos.x+test_dir.x, pos.y+test_dir.y, pos.z),0);\n                    if(mat(r) == 0)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n\n                for(int f = 0; f < 4; f++)\n                {\n                    uint fl = (f+flow)%4;\n                    ivec2 test_dir = ivec2(((fl&1)*(2-fl)), (1-(fl&1))*(1-fl));\n                    uvec4 dr = texelFetch(materials, ivec3(pos.x+test_dir.x, pos.y+test_dir.y, pos.z-1),0);\n                    if(mat(dr) == 0)\n                    {\n                        flow = fl;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    int depth = MAX_DEPTH-1;\n    uint permaterial = permaterial(c);\n    if((permaterial(u) != permaterial) ||\n       (permaterial(d) != permaterial) ||\n       (permaterial(r) != permaterial) ||\n       (permaterial(l) != permaterial) ||\n       (permaterial(f) != permaterial) ||\n       (permaterial(b) != permaterial)) depth = 0;\n    else\n    {\n        depth = min(depth, depth(u)+1);\n        depth = min(depth, depth(d)+1);\n        depth = min(depth, depth(r)+1);\n        depth = min(depth, depth(l)+1);\n        depth = min(depth, depth(f)+1);\n        depth = min(depth, depth(b)+1);\n    }\n\n    int volt = int(volt(c));\n\n    if(conductivity(mat(c)) > 0)\n    {\n        uint cd = conduction_dir(pos);\n        int dvolt = 0;\n        int nvolt = volt;\n        int neighbors = 0;\n        if(mat(r)!=0 && conductivity(mat(r))>0){if(volt(r)>0)neighbors++; nvolt = max(nvolt, int(volt(r)));}\n        if(mat(l)!=0 && conductivity(mat(l))>0){if(volt(l)>0)neighbors++; nvolt = max(nvolt, int(volt(l)));}\n        if(mat(u)!=0 && conductivity(mat(u))>0){if(volt(u)>0)neighbors++; nvolt = max(nvolt, int(volt(u)));}\n        if(mat(d)!=0 && conductivity(mat(d))>0){if(volt(d)>0)neighbors++; nvolt = max(nvolt, int(volt(d)));}\n        if(mat(f)!=0 && conductivity(mat(f))>0){if(volt(f)>0)neighbors++; nvolt = max(nvolt, int(volt(f)));}\n        if(mat(b)!=0 && conductivity(mat(b))>0){if(volt(b)>0)neighbors++; nvolt = max(nvolt, int(volt(b)));}\n        dvolt = nvolt-volt;\n        if((rand(frame_number+rand(rand(rand(pos.z)+pos.y)+pos.x))%7)!=0) dvolt--;\n        // if(volt <= 8 && neighbors == 0) dvolt--;\n        if(dvolt > 0 && neighbors > 1) dvolt = 0;\n        volt = volt+dvolt;\n        volt = clamp(volt, 0, 15);\n    }\n    else\n    {\n        volt = 0;\n    }\n    if(frame_number == 0) volt = 0;\n\n    uint temp = temp(c);\n    // if(mat(c) == 4) temp = 255; else\n    if(mat(c) != 0)\n    {\n        float C = heat_capacity(mat(c));\n        float Q = 0;\n        //NOTE: this would save some divisions by storing thermal resistivity,\n        //      but it's nicer to define materials in terms of conductivity so 0 has well defined behavior\n        float r_c = 1.0/thermal_conductivity(mat(c));\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(u))); Q += k*(float(temp(u))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(d))); Q += k*(float(temp(d))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(r))); Q += k*(float(temp(r))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(l))); Q += k*(float(temp(l))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(f))); Q += k*(float(temp(f))-float(temp));}\n        {float k = 1.0/(r_c+1.0/thermal_conductivity(mat(b))); Q += k*(float(temp(b))-float(temp));}\n\n        //NOTE: there might be oscillations due to neighboring temperatures changing past each other,\n        //      but fixing would require each voxel knowing how much heat it's neighbors are getting\n        //      hopefully won't be a problem since everything will eventually converge to room temp\n\n        float dtemp = Q/C;\n        float dtemp_i = round(dtemp);\n        float dtemp_f = 32.0*(dtemp-dtemp_i);\n\n        if(dtemp_f < 0 && dtemp_f > -1.0) dtemp_f = -1.0;\n\n        if((frame_number+rand(rand(rand(rand(pos.z)+pos.y)+pos.x)))%32 < int(abs(dtemp_f))) dtemp_i += sign(dtemp_f);\n        temp = uint(clamp(float(temp)+dtemp_i, 0.0, 255.0));\n\n        // if(avg_temp.x > float(temp)) temp++;\n        // else if(avg_temp.x < float(temp)) temp--;\n    }\n    else temp = 100;\n\n    // temp = clamp(temp+abs((volt-int(volt(c)))), 0u, 255u);\n    temp = clamp(temp+volt, 0u, 255u);\n\n    if(mat(c) == 6 && temp < 128) c.r = 0;\n\n    uint phase = phase_solid;\n    if(hardness(mat(c)) == 0.0\n       || (mat(u) == 0 && mat(d) == 0 && mat(r) == 0 && mat(l) == 0 && mat(f) == 0 && mat(b) == 0)) phase = phase_sand;\n    if(float(temp) > melting_point(mat(c))) phase = phase_liquid;\n    if(float(temp) > boiling_point(mat(c))) phase = phase_gas;\n\n    uvec4 out_voxel = c;\n\n    uint transient = transient(out_voxel);\n    if(transient == 1)\n    {\n        out_voxel.r = 0;\n        transient = 0;\n    }\n\n    out_voxel.g = uint(depth) | (phase << 5) | (transient << 7);\n\n    out_voxel.b = temp;\n\n    out_voxel.a = volt | (flow<<4);\n\n    // bool changed = c.r != (out_voxel&0xFF) || c.g != ((out_voxel>>8)&0xFF) || (int(c.b) != int((out_voxel>>16)&0xFF) && ((out_voxel>>16)>128)) || volt != volt(c) || volt > 0;\n    bool changed = c.r != out_voxel.r || c.g != out_voxel.g || (int(c.b) != int(out_voxel.b) && out_voxel.b > 128) || volt != volt(c) || volt > 0;\n    if(changed)\n    {\n        c_active = true;\n        u_active = u_active || cell_p.z==15;\n        d_active = d_active || cell_p.z== 0;\n        r_active = r_active || cell_p.y==15;\n        l_active = l_active || cell_p.y== 0;\n        f_active = f_active || cell_p.x==15;\n        b_active = b_active || cell_p.x== 0;\n    }\n\n    if(c != 0) imageStore(occupied_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n\n    // memoryBarrier();\n    imageStore(materials_out, pos, out_voxel);\n}\n\nvoid main()\n{\n    ivec3 pos = subgroup_size*ivec3(gl_GlobalInvocationID.xyz);\n    ivec3 rpos = pos>>4;\n\n    uint region_active = texelFetch(active_regions_in, rpos, 0).r;\n    if(region_active == 0)\n    {\n        return;\n    }\n\n    for(int x = 0; x < subgroup_size; x++)\n        for(int y = 0; y < subgroup_size; y++)\n            for(int z = 0; z < subgroup_size; z++)\n                simulate_voxel(pos+ivec3(x,y,z), rpos);\n\n    if(c_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y, rpos.z), uvec4(1,0,0,0));\n    if(u_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y, rpos.z+1), uvec4(1,0,0,0));\n    if(d_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y, rpos.z-1), uvec4(1,0,0,0));\n    if(l_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y+1, rpos.z), uvec4(1,0,0,0));\n    if(r_active) imageStore(active_regions_out, ivec3(rpos.x, rpos.y-1, rpos.z), uvec4(1,0,0,0));\n    if(f_active) imageStore(active_regions_out, ivec3(rpos.x+1, rpos.y, rpos.z), uvec4(1,0,0,0));\n    if(b_active) imageStore(active_regions_out, ivec3(rpos.x-1, rpos.y, rpos.z), uvec4(1,0,0,0));\n}\n"; glShaderSource(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_atomic_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_atomic_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_atomic_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_chunk_atomic_program, simulate_chunk_atomic_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_chunk_atomic_program);glDetachShader(simulate_chunk_atomic_program, simulate_chunk_atomic_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_chunk_atomic_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_chunk_atomic_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_chunk_atomic_program, available_memory, 0, info_log); log_error(info_log); }simulate_particles_program = glCreateProgram(); assert(simulate_particles_program, "could not create simulate_particles_program, GL error", glGetError());
 GLuint simulate_particles_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_particles_program_GL_COMPUTE_SHADER, "could not create simulate_particles_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform writeonly uimage3D materials_out;\nlayout(location = 4) uniform writeonly uimage3D active_regions_out;\nlayout(location = 5) uniform writeonly uimage3D occupied_regions_out;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    uint p = gl_GlobalInvocationID.x;\n    if(!particles[p].alive) return;\n    vec3 x = vec3(particles[p].x, particles[p].y, particles[p].z);\n    vec3 x_dot = vec3(particles[p].x_dot, particles[p].y_dot, particles[p].z_dot);\n\n    x += x_dot;\n    x_dot.z -= 0.1;\n    int i = 0;\n    uint transient = 1;\n    while(mat(texelFetch(materials, ivec3(x), 0)) != 0)\n    {\n        vec3 normal = normalize(unnormalized_gradient(materials, ivec3(x)));\n        // x += max(0.1f, float(SURF_DEPTH-depth(voxel)))*normal;\n        x += 0.05f*normal;\n        x_dot -= dot(x_dot, normal)*normal;\n\n        transient = 0;\n        if(i++ > 50)\n        {\n            break;\n        }\n    }\n\n    particles[p].x = x.x;\n    particles[p].y = x.y;\n    particles[p].z = x.z;\n\n    particles[p].x_dot = x_dot.x;\n    particles[p].y_dot = x_dot.y;\n    particles[p].z_dot = x_dot.z;\n\n    if(transient == 0 && mat(texelFetch(materials, ivec3(x), 0)) == 0)\n    {\n        uint v = particles[p].voxel_data;\n        uvec4 particle_voxel_data = uvec4((v&0xF), ((v>>8)&0x7)|(transient<<7), ((v>>16)&0xF), ((v>>24)&0xF)|7);\n        imageStore(materials_out, ivec3(x), particle_voxel_data);\n        imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16), uvec4(1,0,0,0));\n        ivec3 cell_x = ivec3(x)%16;\n        if(cell_x.x==15) imageStore(active_regions_out, ivec3(x.x/16+1, x.y/16, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.x== 0) imageStore(active_regions_out, ivec3(x.x/16-1, x.y/16, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.y==15) imageStore(active_regions_out, ivec3(x.x/16, x.y/16+1, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.y== 0) imageStore(active_regions_out, ivec3(x.x/16, x.y/16-1, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.z==15) imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16+1), uvec4(1,0,0,0));\n        if(cell_x.z== 0) imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16-1), uvec4(1,0,0,0));\n        imageStore(occupied_regions_out, ivec3(x.x/16, x.y/16, x.z/16), uvec4(1,0,0,0));\n\n        particles[p].alive = false;\n        int dead_index = atomicAdd(n_dead_particles, 1);\n        dead_particles[dead_index] = p;\n    }\n}\n"; glShaderSource(simulate_particles_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_particles_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_particles_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_particles_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_particles_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_particles_program, simulate_particles_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_particles_program);glDetachShader(simulate_particles_program, simulate_particles_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_particles_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_particles_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_particles_program, available_memory, 0, info_log); log_error(info_log); }update_lightmap_program = glCreateProgram(); assert(update_lightmap_program, "could not create update_lightmap_program, GL error", glGetError());
 GLuint update_lightmap_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(update_lightmap_program_GL_COMPUTE_SHADER, "could not create update_lightmap_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_visual_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform usampler3D occupied_regions;\nlayout(location = 4) uniform usampler3D active_regions;\nlayout(location = 5) uniform sampler2D lightprobe_color;\nlayout(location = 6) uniform sampler2D lightprobe_depth;\nlayout(location = 7) uniform sampler2D lightprobe_x;\nlayout(location = 8) uniform sampler2D blue_noise_texture;\n\nlayout(location = 9) uniform writeonly image2D lightprobe_color_out;\nlayout(location = 10) uniform writeonly image2D lightprobe_depth_out;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec3 blue_noise_3(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xyz+(frame_number%100)*vec3(1.0/PHI3,1.0/(PHI3*PHI3),1.0/(PHI3*PHI3*PHI3)));\n}\n\nvec2 blue_noise_2(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co).xy+(frame_number%200)*vec2(1.0/PHI2,1.0/(PHI2*PHI2)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec3 quasinoise_3(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec3(g, sq(g), g*sq(g)));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat opacity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).b;\n}\n\nfloat refractive_index(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#ifdef UINT_PACKED_MATERIALS\n#define         mat(vox) (vox&0xFF)\n#define       depth(vox) (int((vox>>8)&0x1F))\n#define       phase(vox) ((vox>>13)&0x3)\n#define   transient(vox) ((vox>>15)&0x1)\n#define        temp(vox) ((vox>>16)&0xFF)\n#define        volt(vox) ((vox>>24)&0xF)\n#define        trig(vox) ((vox>>30))\n#define        flow(vox) ((vox>>30))\n#else\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) ((vox.g>>5)&0x3)\n#define   transient(vox) (vox.g>>7)\n#define        temp(vox) (vox.b)\n#define        volt(vox) (vox.a&0xF)\n#define        trig(vox) (vox.a>>4)\n#define        flow(vox) (vox.a>>4)\n#endif\n\n#define signed_depth(vox) (mat(vox) == 0 ? 1+depth(vox) : -depth(vox))\n#define opaque_signed_depth(vox) (opacity(mat(vox)) == 0 ? 1+depth(vox) : -depth(vox))\n\n#define permaterial(vox) (mat(vox)*(1-transient(vox)))\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_gas    0\n#define phase_solid  1\n#define phase_sand   2\n#define phase_liquid 3\n\n#define trig_none     0\n#define trig_always   1\n#define trig_hot      2\n#define trig_cold     3\n#define trig_electric 4\n#define trig_contact  5\n\n#define act_none      0\n#define act_grow      1\n#define act_die       2\n#define act_heat      3\n#define act_chill     4\n#define act_electrify 5\n#define act_explode   6\n#define act_spray     7\n\n#define BASE_CELL_MAT 128\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(3,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(4,material_id), 0).r;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(5,material_id), 0).r;\n}\n\nfloat thermal_conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(6,material_id), 0).r+0.001;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(7,material_id), 0).r;\n}\n\nfloat work_function(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(8,material_id), 0).r;\n}\n\nint growth_time(uint material_id)\n{\n    return int(texelFetch(material_physical_properties, ivec2(9,material_id), 0).r);\n}\n\nfloat n_triggers(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(10,material_id), 0).r;\n}\n\nuint trigger_info(uint material_id, uint trigger_id)\n{\n    return uint(texelFetch(material_physical_properties, ivec2(11+trigger_id,material_id), 0).r);\n}\n\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        signed_depth(texelFetch(materials, p+ivec3(+1,0,0), 0))-signed_depth(texelFetch(materials, p+ivec3(-1,0,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,+1,0), 0))-signed_depth(texelFetch(materials, p+ivec3(0,-1,0), 0)),\n        signed_depth(texelFetch(materials, p+ivec3(0,0,+1), 0))-signed_depth(texelFetch(materials, p+ivec3(0,0,-1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, uint medium, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(pos);\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n\n        #ifdef occupied_regions\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(pos);\n        }\n        else\n        #endif\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != medium)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            #ifndef RAY_CAST_IGNORE_DEPTH\n            int depth = depth(voxel);\n            if(depth >= 3\n               // #ifdef ACTIVE_REGIONS\n               // && texelFetch(active_regions, ipos>>4, 0).r == 0\n               // #endif //ACTIVE_REGIONS\n                )\n            {\n                float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                pos += ray_dir*skip_dist;\n                hit_dist += skip_dist;\n                ipos = ivec3(pos);\n            }\n            #endif\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    vec4 total_color_no_cheb = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                float weight = sq(0.5*dot(normal, dir)+0.5)+0.2;\n                // float weight = 1.0;\n\n                vec3 base_dist = lightprobe_spacing*(vec3(probe_pos)+0.5)-pos; //distance from base probe position\n                vec3 trilinear_weights = clamp(1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*base_dist, 0, 1);\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z;\n\n                total_color_no_cheb += weight*sqrt(probe_color);\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+sq(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.02;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    // total_color.rgb = mix(sq(total_color_no_cheb.rgb*(1.0f/total_color_no_cheb.a)),\n    //                       sq(total_color.rgb*(1.0f/total_color.a)), min(total_color.a, 1));\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\n#define group_size 4\nlayout(local_size_x = group_size, local_size_y = group_size, local_size_z = 1) in;\n\nvoid main()\n{\n    ivec2 probe_coord = ivec2(gl_GlobalInvocationID.xy);\n    ivec2 texel_coord = lightprobe_padded_resolution*probe_coord+1;\n\n    #define v vec3(0)\n    vec3 new_colors[lightprobe_resolution*lightprobe_resolution]\n        = vec3[lightprobe_resolution*lightprobe_resolution](v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v);\n    #undef v\n    #define v vec2(0)\n    vec2 new_depths[lightprobe_resolution*lightprobe_resolution]\n        = vec2[lightprobe_resolution*lightprobe_resolution](v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v);\n    #undef v\n\n    const float decay_fraction = 0.005;\n\n    const int n_samples = 4;\n    for(int sample_i = 0; sample_i < n_samples; sample_i++)\n    {\n        // int probe_id = int(lightprobes_w*gl_GlobalInvocationID.y+gl_GlobalInvocationID.x);\n        // vec3 ray_dir = quasinoise_3(probe_id+lightprobes_w*lightprobes_h*(frame_number%100))-0.5;\n        // vec3 ray_dir = blue_noise_3(vec2(probe_coord)/256.0)-0.5;\n        vec2 Omega = blue_noise_2(vec2(probe_coord)/256.0+sample_i*vec2(0.86, 0.24));\n        float cosphi = cos((2*pi)*Omega.x);\n        float sinphi = sin((2*pi)*Omega.x);\n        float costheta = 2*Omega.y-1;\n        float sintheta = sqrt(max(0, 1.0-sq(costheta)));\n        vec3 ray_dir = vec3(sintheta*cosphi, sintheta*sinphi, costheta);\n        ray_dir = normalize(ray_dir);\n\n        vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n        vec3 hit_pos;\n        float hit_dist;\n        ivec3 hit_cell;\n        vec3 hit_dir;\n        vec3 normal;\n        ivec3 origin = ivec3(0);\n        ivec3 size = ivec3(512);\n        uvec4 voxel;\n        uint medium = texelFetch(materials, ivec3(probe_x), 0).r;\n        bool hit = cast_ray(materials, ray_dir, probe_x, size, origin, medium, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 24);\n\n        vec3 color = vec3(0);\n        vec2 depth = vec2(0);\n\n        if(hit)\n        {\n            uvec4 voxel = texelFetch(materials, hit_cell, 0);\n            uint material_id = voxel.r;\n\n            vec4 transmission = vec4(1);\n            vec4 transparent_color = vec4(0);\n            for(int i = 0; i < 5; i++)\n            {\n                if(opacity(mat(voxel)) >= 1) break;\n                vec3 ray_pos = hit_pos;\n                if(ivec3(ray_pos) != hit_cell) ray_pos += 0.001*ray_dir;\n                float c = dot(ray_dir, normal);\n                float r = refractive_index(medium)/refractive_index(mat(voxel));\n                float square = 1.0-sq(r)*(1.0-sq(c));\n                if(square > 0) ray_dir = r*ray_dir+(-r*c+sign(c)*sqrt(square))*normal;\n                else ray_dir = ray_dir - 2*c*normal; //total internal reflection\n                // ray_dir = normalize(ray_dir);\n                medium = mat(voxel);\n                bool hit = cast_ray(materials, ray_dir, ray_pos, size, origin, medium, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 24);\n\n                if(hit)\n                {\n                    transmission *= exp(-opacity(mat(medium))*hit_dist);\n                }\n                else\n                {\n                    break;\n                }\n\n                if(dot(transmission, transmission) < 0.001) break;\n\n                uint material_id = voxel.r;\n                float roughness = get_roughness(material_id);\n                vec3 emission = get_emission(material_id);\n\n                // transparent_color.rgb += -(emission)*dot(normal, ray_dir);\n                transparent_color.rgb += emission;\n\n                //TODO: actual blackbody color\n                transparent_color.rgb += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n                transparent_color.rgb += vec3(0.7,0.3,1.0)*clamp((1.0/15.0)*(float(volt(voxel))), 0.0, 1.0);\n\n                vec3 reflection_dir = normal;\n                vec2 sample_depth;\n                transparent_color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)\n                    *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n                transparent_color *= transmission;\n            }\n\n            color += transparent_color.rgb;\n\n            float roughness = get_roughness(material_id);\n            vec3 emission = get_emission(material_id);\n\n            emission += vec3(1,0.05,0.1)*clamp((1.0/127.0)*(float(temp(voxel))-128), 0.0, 1.0);\n\n            // color += -(emission)*dot(normal, ray_dir);\n            color += emission;\n\n            // float total_weight = 0.0;\n\n            // vec3 reflection_normal = normal+0.5*roughness*(blue_noise(gl_FragCoord.xy/256.0+vec2(0.82,0.34)).xyz-0.5f);\n            vec3 reflection_normal = normal;\n            reflection_normal = normalize(reflection_normal);\n            // vec3 reflection_dir = ray_dir-(2*dot(ray_dir, reflection_normal))*reflection_normal;\n            vec3 reflection_dir = normal;\n            // reflection_dir += roughness*blue_noise(gl_FragCoord.xy/256.0f+vec2(0.4f,0.6f)).xyz;\n\n            vec2 sample_depth;\n            color += fr(material_id, reflection_dir, -ray_dir, normal)*sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        }\n        else\n        {\n            vec2 sample_depth;\n            vec3 sample_color = sample_lightprobe_color(hit_pos, ray_dir, vec_to_oct(ray_dir), sample_depth);\n            // hit_dist += sample_depth.r;\n            color.rgb = sample_color;\n        }\n\n        // color = clamp(color, 0, 1);\n        color = max(color, 0);\n\n        depth.r = clamp(hit_dist, 0, 16*lightprobe_spacing);\n        // depth.r = hit_dist;\n        depth.g = sq(depth.r);\n\n        ivec2 o;\n        for(o.y = 0; o.y < lightprobe_resolution; o.y++)\n            for(o.x = 0; o.x < lightprobe_resolution; o.x++)\n            {\n                vec2 oct = (2.0/lightprobe_resolution)*(vec2(o)+0.5)-1.0;\n                vec3 probe_texel_dir = oct_to_vec(oct);\n                float weight = (5.0/n_samples)*max(0, dot(probe_texel_dir, ray_dir));\n\n                if(weight > 0.001)\n                {\n                    new_colors[o.x+o.y*lightprobe_resolution] += weight*color;\n                    // new_depths[o.x+o.y*lightprobe_resolution] += pow(weight, 20.0)*depth;\n                }\n            }\n        ivec2 depth_oct = clamp(ivec2(lightprobe_resolution*(0.5*vec_to_oct(ray_dir)+0.5)), 0, lightprobe_resolution);\n        // new_depths[depth_oct.x+depth_oct.y*lightprobe_resolution] += depth;\n\n        vec2 texel_depth = texelFetch(lightprobe_depth, texel_coord+depth_oct, 0).rg;\n        texel_depth = mix(texel_depth, 0.8*depth, decay_fraction);\n        imageStore(lightprobe_depth_out, texel_coord+depth_oct, vec4(texel_depth, 0, 1));\n    }\n\n    ivec2 o;\n    for(o.y = 0; o.y < lightprobe_resolution; o.y++)\n        for(o.x = 0; o.x < lightprobe_resolution; o.x++)\n        {\n                vec3 texel_color = texelFetch(lightprobe_color, texel_coord+o, 0).rgb;\n                texel_color = mix(texel_color, new_colors[o.x+o.y*lightprobe_resolution],\n                                  decay_fraction);\n                imageStore(lightprobe_color_out, texel_coord+o, vec4(texel_color, 1));\n\n                // vec2 texel_depth = texelFetch(lightprobe_depth, texel_coord+o, 0).rg;\n                // texel_depth = mix(texel_depth, new_depths[o.x+o.y*lightprobe_resolution],\n                //                   decay_fraction);\n                // imageStore(lightprobe_depth_out, texel_coord+o, vec4(texel_depth, 0, 1));\n        }\n}\n\n/////////////////////////////////////////////////////////////////\n"; glShaderSource(update_lightmap_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(update_lightmap_program_GL_COMPUTE_SHADER); glGetShaderiv(update_lightmap_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_lightmap_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_lightmap_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(update_lightmap_program, update_lightmap_program_GL_COMPUTE_SHADER); 
glLinkProgram(update_lightmap_program);glDetachShader(update_lightmap_program, update_lightmap_program_GL_COMPUTE_SHADER); glDeleteShader(update_lightmap_program_GL_COMPUTE_SHADER); 
glGetProgramiv(update_lightmap_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(update_lightmap_program, available_memory, 0, info_log); log_error(info_log); }unreserve_block(manager);}