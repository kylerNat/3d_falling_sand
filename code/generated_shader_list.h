
GLuint circle_program;
GLuint debug_text_program;
GLuint denoise_program;
GLuint draw_lightprobes_program;
GLuint draw_particles_program;
GLuint fullscreen_texture_program;
GLuint get_voxel_data_program;
GLuint mipmap_chunk_program;
GLuint move_lightprobes_program;
GLuint pad_lightprobes_program;
GLuint render_chunk_program;
GLuint render_depth_prepass_program;
GLuint render_prepass_program;
GLuint render_world_program;
GLuint simulate_body_program;
GLuint simulate_body_physics_program;
GLuint simulate_chunk_program;
GLuint simulate_particles_program;
GLuint update_lightmap_program;void gl_init_programs(memory_manager* manager){int error; size_t available_memory = current_block_unused(manager); byte* free_memory = reserve_block(manager, available_memory);circle_program = glCreateProgram(); assert(circle_program, "could not create circle_program, GL error", glGetError());
 GLuint circle_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(circle_program_GL_VERTEX_SHADER, "could not create circle_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\nlayout(location = 1) in vec3 X;\nlayout(location = 2) in float r;\nlayout(location = 3) in vec4 c;\n\nsmooth out vec4 color;\nsmooth out vec2 uv;\nsmooth out float radius;\n\nlayout(location = 0) uniform mat4 t;\n\nvoid main()\n{\n    gl_Position.xyz = (x*r+X);\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    uv = x.xy*r;\n    radius = r;\n    color = c;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_VERTEX_SHADER); glGetShaderiv(circle_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_VERTEX_SHADER); 

 GLuint circle_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(circle_program_GL_FRAGMENT_SHADER, "could not create circle_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform float smoothness;\n\nsmooth in vec4 color;\nsmooth in vec2 uv;\nsmooth in float radius;\n\nvoid main()\n{\n    frag_color = color;\n    float alpha = smoothstep(-radius, -radius+smoothness, -length(uv));\n    frag_color.a *= alpha;\n    gl_FragDepth = gl_FragCoord.z*alpha;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(circle_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(circle_program_GL_FRAGMENT_SHADER); glGetShaderiv(circle_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(circle_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile circle_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); 
glLinkProgram(circle_program);glDetachShader(circle_program, circle_program_GL_VERTEX_SHADER); glDeleteShader(circle_program_GL_VERTEX_SHADER); 
glDetachShader(circle_program, circle_program_GL_FRAGMENT_SHADER); glDeleteShader(circle_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(circle_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(circle_program, available_memory, 0, info_log); log_error(info_log); }debug_text_program = glCreateProgram(); assert(debug_text_program, "could not create debug_text_program, GL error", glGetError());
 GLuint debug_text_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(debug_text_program_GL_VERTEX_SHADER, "could not create debug_text_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\nlayout(location = 1) in vec4 c;\n\nsmooth out vec4 color;\n\nvoid main()\n{\n    gl_Position.xyz = 5*x/vec3(1080, 720, 1);\n    gl_Position.y = -gl_Position.y;\n    gl_Position.w = 1.0;\n    color = vec4(1);\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(debug_text_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(debug_text_program_GL_VERTEX_SHADER); glGetShaderiv(debug_text_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(debug_text_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile debug_text_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(debug_text_program, debug_text_program_GL_VERTEX_SHADER); 

 GLuint debug_text_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(debug_text_program_GL_FRAGMENT_SHADER, "could not create debug_text_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "\n#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nsmooth in vec4 color;\n\nvoid main()\n{\n    frag_color = color;\n}\n\n///////////////////////////////////////////////////\n"; glShaderSource(debug_text_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(debug_text_program_GL_FRAGMENT_SHADER); glGetShaderiv(debug_text_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(debug_text_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile debug_text_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(debug_text_program, debug_text_program_GL_FRAGMENT_SHADER); 
glLinkProgram(debug_text_program);glDetachShader(debug_text_program, debug_text_program_GL_VERTEX_SHADER); glDeleteShader(debug_text_program_GL_VERTEX_SHADER); 
glDetachShader(debug_text_program, debug_text_program_GL_FRAGMENT_SHADER); glDeleteShader(debug_text_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(debug_text_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(debug_text_program, available_memory, 0, info_log); log_error(info_log); }denoise_program = glCreateProgram(); assert(denoise_program, "could not create denoise_program, GL error", glGetError());
 GLuint denoise_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(denoise_program_GL_VERTEX_SHADER, "could not create denoise_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(denoise_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(denoise_program_GL_VERTEX_SHADER); glGetShaderiv(denoise_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(denoise_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile denoise_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(denoise_program, denoise_program_GL_VERTEX_SHADER); 

 GLuint denoise_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(denoise_program_GL_FRAGMENT_SHADER, "could not create denoise_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 0) uniform sampler2D color;\nlayout(location = 1) uniform sampler2D depth;\nlayout(location = 2) uniform sampler2D normal;\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n\n    ivec2 d = ivec2(1,0);\n    vec2 p = 0.5f*screen_pos+0.5f;\n    int lod = 0;\n    ivec2 ip = ivec2(pow(0.5f, lod)*gl_FragCoord.xy);\n    // float laplacian =\n    //     texelFetch(depth, ip-d.yx, lod).r+texelFetch(depth, ip+d.yx, lod).r\n    //     +texelFetch(depth, ip-d.xy, lod).r+texelFetch(depth, ip+d.xy, lod).r\n    //     -4.0f*texelFetch(depth, ip, lod).r;\n    // frag_color.rgb = vec3(100*laplacian.r);\n    // frag_color.rgb = textureLod(color, p, clamp(4.0f-1000.0f*laplacian, 0, 8)).rgb;\n\n    float center_depth = texelFetch(depth, ip, 0).r;\n    vec3 center_normal = texelFetch(normal, ip, 0).rgb;\n    float weight = 0.0f;\n    frag_color.rgb = vec3(0);\n    int radius = 3;\n    for(int dx = -radius; dx <= radius; dx++)\n        for(int dy = -radius; dy <= radius; dy++)\n            // if(abs(1.0-texelFetch(depth, ip+ivec2(dx,dy), 0).r/center_depth) < 0.01)\n            if(length(texelFetch(normal, ip+ivec2(dx,dy), 0).rgb-center_normal) < 0.01)\n            {\n                // float w = exp(-0.5*(sq(dx)+sq(dy)));\n                float w = 1.0;\n                frag_color.rgb += w*texelFetch(color, ip+ivec2(dx,dy), 0).rgb;\n                weight += w;\n            }\n\n    frag_color.rgb *= 1.0f/weight;\n    frag_color.a = 1.0f;\n}\n"; glShaderSource(denoise_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(denoise_program_GL_FRAGMENT_SHADER); glGetShaderiv(denoise_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(denoise_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile denoise_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(denoise_program, denoise_program_GL_FRAGMENT_SHADER); 
glLinkProgram(denoise_program);glDetachShader(denoise_program, denoise_program_GL_VERTEX_SHADER); glDeleteShader(denoise_program_GL_VERTEX_SHADER); 
glDetachShader(denoise_program, denoise_program_GL_FRAGMENT_SHADER); glDeleteShader(denoise_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(denoise_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(denoise_program, available_memory, 0, info_log); log_error(info_log); }draw_lightprobes_program = glCreateProgram(); assert(draw_lightprobes_program, "could not create draw_lightprobes_program, GL error", glGetError());
 GLuint draw_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_lightprobes_program_GL_VERTEX_SHADER, "could not create draw_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\nlayout(location = 2) uniform sampler2D lightprobe_x;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nsmooth out vec3 r;\nflat out ivec2 probe_coord;\n\nvoid main()\n{\n    probe_coord = ivec2(gl_InstanceID%lightprobes_w, gl_InstanceID/lightprobes_w);\n    gl_Position.xyz = x+texelFetch(lightprobe_x, probe_coord, 0).xyz;\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    r = x;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(draw_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(draw_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_lightprobes_program, draw_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint draw_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_lightprobes_program_GL_FRAGMENT_SHADER, "could not create draw_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform sampler2D lightprobe_color;\nlayout(location = 2) uniform sampler2D lightprobe_x;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nsmooth in vec3 r;\nflat in ivec2 probe_coord;\n\nvoid main()\n{\n    vec2 sample_oct = vec_to_oct(normalize(r));\n\n    vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1.5)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n    vec2 t = trunc(sample_coord);\n    vec2 f = fract(sample_coord);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    // f = f*f*(-2*f+3);\n    float l = 1-sq(f.x-0.5)*sq(f.y-0.5);\n    sample_coord = t+f-0.5;\n    sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n    frag_color = textureLod(lightprobe_color, sample_coord, l);\n}\n"; glShaderSource(draw_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_lightprobes_program, draw_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_lightprobes_program);glDetachShader(draw_lightprobes_program, draw_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(draw_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(draw_lightprobes_program, draw_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }draw_particles_program = glCreateProgram(); assert(draw_particles_program, "could not create draw_particles_program, GL error", glGetError());
 GLuint draw_particles_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(draw_particles_program_GL_VERTEX_SHADER, "could not create draw_particles_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\n\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nsmooth out vec3 r;\n\nvoid main()\n{\n    int p = gl_InstanceID;\n    if(!particles[p].alive)\n    {\n        gl_Position = vec4(0.0/0.0);\n        return;\n    }\n    gl_Position.xyz = x+vec3(particles[p].x, particles[p].y, particles[p].z);\n    gl_Position.w = 1.0;\n    gl_Position = t*gl_Position;\n    r = x;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(draw_particles_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(draw_particles_program_GL_VERTEX_SHADER); glGetShaderiv(draw_particles_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_particles_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_particles_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(draw_particles_program, draw_particles_program_GL_VERTEX_SHADER); 

 GLuint draw_particles_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(draw_particles_program_GL_FRAGMENT_SHADER, "could not create draw_particles_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nsmooth in vec3 r;\n\nvoid main()\n{\n    frag_color = vec4(0,1,0,1);\n}\n"; glShaderSource(draw_particles_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(draw_particles_program_GL_FRAGMENT_SHADER); glGetShaderiv(draw_particles_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(draw_particles_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile draw_particles_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(draw_particles_program, draw_particles_program_GL_FRAGMENT_SHADER); 
glLinkProgram(draw_particles_program);glDetachShader(draw_particles_program, draw_particles_program_GL_VERTEX_SHADER); glDeleteShader(draw_particles_program_GL_VERTEX_SHADER); 
glDetachShader(draw_particles_program, draw_particles_program_GL_FRAGMENT_SHADER); glDeleteShader(draw_particles_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(draw_particles_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(draw_particles_program, available_memory, 0, info_log); log_error(info_log); }fullscreen_texture_program = glCreateProgram(); assert(fullscreen_texture_program, "could not create fullscreen_texture_program, GL error", glGetError());
 GLuint fullscreen_texture_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(fullscreen_texture_program_GL_VERTEX_SHADER, "could not create fullscreen_texture_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform mat4 t;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5f*x.xy+0.5f;\n}\n\n"; glShaderSource(fullscreen_texture_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_VERTEX_SHADER); glGetShaderiv(fullscreen_texture_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); 

 GLuint fullscreen_texture_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(fullscreen_texture_program_GL_FRAGMENT_SHADER, "could not create fullscreen_texture_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n////////////////<2d circle fragment shader>////////////////\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 1) uniform sampler2D color;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    frag_color = texture(color, uv);\n}\n"; glShaderSource(fullscreen_texture_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); glGetShaderiv(fullscreen_texture_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(fullscreen_texture_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile fullscreen_texture_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glLinkProgram(fullscreen_texture_program);glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_VERTEX_SHADER); glDeleteShader(fullscreen_texture_program_GL_VERTEX_SHADER); 
glDetachShader(fullscreen_texture_program, fullscreen_texture_program_GL_FRAGMENT_SHADER); glDeleteShader(fullscreen_texture_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(fullscreen_texture_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(fullscreen_texture_program, available_memory, 0, info_log); log_error(info_log); }get_voxel_data_program = glCreateProgram(); assert(get_voxel_data_program, "could not create get_voxel_data_program, GL error", glGetError());
 GLuint get_voxel_data_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(get_voxel_data_program_GL_VERTEX_SHADER, "could not create get_voxel_data_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5*x.xy+0.5;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(get_voxel_data_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(get_voxel_data_program_GL_VERTEX_SHADER); glGetShaderiv(get_voxel_data_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(get_voxel_data_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile get_voxel_data_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(get_voxel_data_program, get_voxel_data_program_GL_VERTEX_SHADER); 

 GLuint get_voxel_data_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(get_voxel_data_program_GL_FRAGMENT_SHADER, "could not create get_voxel_data_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec2 material;\nlayout(location = 1) out vec3 normal;\n\nlayout(location = 0) uniform isampler3D materials;\nlayout(location = 1) uniform ivec3 pos;\n\nsmooth in vec2 uv;\n\nvoid main()\n{\n    ivec3 x = pos;\n\n    vec3 gradient = vec3(\n        texelFetch(materials, ivec3(x+vec3(1,0,0)), 0).g-texelFetch(materials, ivec3(x+vec3(-1,0,0)), 0).g,\n        texelFetch(materials, ivec3(x+vec3(0,1,0)), 0).g-texelFetch(materials, ivec3(x+vec3(0,-1,0)), 0).g,\n        texelFetch(materials, ivec3(x+vec3(0,0,1)), 0).g-texelFetch(materials, ivec3(x+vec3(0,0,-1)), 0).g+0.001f\n        );\n    gradient = normalize(gradient);\n\n    material = texelFetch(materials, x, 0).rg;\n    normal = gradient;\n}\n"; glShaderSource(get_voxel_data_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(get_voxel_data_program_GL_FRAGMENT_SHADER); glGetShaderiv(get_voxel_data_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(get_voxel_data_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile get_voxel_data_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(get_voxel_data_program, get_voxel_data_program_GL_FRAGMENT_SHADER); 
glLinkProgram(get_voxel_data_program);glDetachShader(get_voxel_data_program, get_voxel_data_program_GL_VERTEX_SHADER); glDeleteShader(get_voxel_data_program_GL_VERTEX_SHADER); 
glDetachShader(get_voxel_data_program, get_voxel_data_program_GL_FRAGMENT_SHADER); glDeleteShader(get_voxel_data_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(get_voxel_data_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(get_voxel_data_program, available_memory, 0, info_log); log_error(info_log); }mipmap_chunk_program = glCreateProgram(); assert(mipmap_chunk_program, "could not create mipmap_chunk_program, GL error", glGetError());
 GLuint mipmap_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(mipmap_chunk_program_GL_VERTEX_SHADER, "could not create mipmap_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 r;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int mip_level;\nlayout(location = 3) uniform usampler3D active_regions_in;\n\nout vec3 p;\n\nvoid main()\n{\n    float mip_scale = pow(0.5, mip_level-1);\n    int z = layer/(16>>mip_level);\n    int y = int(X.y);\n    int x = int(X.x);\n\n    p=vec3(16*mip_scale*x,16*mip_scale*y,layer*pow(2, mip_level));\n\n    gl_Position = vec4(0.0/0.0, 0.0/0.0, 0, 1);\n\n    float scale = 2.0f/32.0f;\n\n    uint region_active = texelFetch(active_regions_in, ivec3(x, y, z), 0).r;\n    if(region_active != 0)\n    {\n        gl_Position.xy = -1.0f+scale*(r+X);\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(mipmap_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(mipmap_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(mipmap_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(mipmap_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile mipmap_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(mipmap_chunk_program, mipmap_chunk_program_GL_VERTEX_SHADER); 

 GLuint mipmap_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(mipmap_chunk_program_GL_FRAGMENT_SHADER, "could not create mipmap_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out ivec4 frag_color;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int mip_level;\nlayout(location = 2) uniform isampler3D materials;\n\nin vec3 p;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    float mip_scale = pow(2.0, mip_level);\n    ivec3 pos = ivec3(p);\n    ivec3 cell_p;\n    cell_p.xy = ivec2(gl_FragCoord.xy*mip_scale)%int(32/mip_scale);\n    pos.xy += cell_p.xy;\n\n    frag_color.rg = ivec2(0, 16);\n    for(int z = 0; z <= 1; z++)\n        for(int y = 0; y <= 1; y++)\n            for(int x = 0; x <= 1; x++)\n            {\n                ivec4 voxel  = texelFetch(materials, ivec3(pos.x+x, pos.y+y, pos.z+z), mip_level-1);\n                frag_color.r = max(frag_color.r, voxel.r);\n                // if(voxel.g > 1)\n                // {\n                //     frag_color.g = voxel.g-1;\n                //     break;\n                // }\n                frag_color.g = min(frag_color.g, voxel.g);\n            }\n    frag_color.r = pos.z;\n    frag_color.a = 1;\n}\n"; glShaderSource(mipmap_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(mipmap_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(mipmap_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(mipmap_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile mipmap_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(mipmap_chunk_program, mipmap_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(mipmap_chunk_program);glDetachShader(mipmap_chunk_program, mipmap_chunk_program_GL_VERTEX_SHADER); glDeleteShader(mipmap_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(mipmap_chunk_program, mipmap_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(mipmap_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(mipmap_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(mipmap_chunk_program, available_memory, 0, info_log); log_error(info_log); }move_lightprobes_program = glCreateProgram(); assert(move_lightprobes_program, "could not create move_lightprobes_program, GL error", glGetError());
 GLuint move_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(move_lightprobes_program_GL_VERTEX_SHADER, "could not create move_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(move_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(move_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(move_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(move_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile move_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(move_lightprobes_program, move_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint move_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(move_lightprobes_program_GL_FRAGMENT_SHADER, "could not create move_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nlayout(location = 0) out vec3 new_x;\n\nlayout(location = 0) uniform isampler3D materials;\nlayout(location = 1) uniform sampler2D old_x;\n\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\n\nvoid main()\n{\n    ivec2 probe_coord = ivec2(gl_FragCoord.xy);\n    vec3 x = texelFetch(old_x, probe_coord, 0).rgb;\n\n    ivec3 ix = ivec3(x);\n\n    //the center of the current cell\n    int j = probe_coord.x+lightprobes_w*probe_coord.y;\n    vec3 center_x = vec3((lightprobe_spacing/2)+lightprobe_spacing*(j%lightprobes_per_axis),\n                         (lightprobe_spacing/2)+lightprobe_spacing*((j/lightprobes_per_axis)%lightprobes_per_axis),\n                         (lightprobe_spacing/2)+lightprobe_spacing*(j/sq(lightprobes_per_axis)));\n\n    ivec4 voxel = texelFetch(materials, ix, 0);\n    if(depth(voxel) > SURF_DEPTH-4)\n    {\n        vec3 gradient = vec3(\n            depth(texelFetch(materials, ix+ivec3(-1,0,0), 0))-depth(texelFetch(materials, ix+ivec3(+1,0,0), 0)),\n            depth(texelFetch(materials, ix+ivec3(0,-1,0), 0))-depth(texelFetch(materials, ix+ivec3(0,+1,0), 0)),\n            depth(texelFetch(materials, ix+ivec3(0,0,-1), 0))-depth(texelFetch(materials, ix+ivec3(0,0,+1), 0))+0.001);\n        gradient = normalize(gradient);\n\n        x += 0.1*gradient*(1+depth(voxel)-SURF_DEPTH);\n    }\n    else if(depth(voxel) < SURF_DEPTH-8)\n    {\n        x = mix(x, center_x, 0.1);\n    }\n\n    new_x = x;\n}\n"; glShaderSource(move_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(move_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(move_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(move_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile move_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(move_lightprobes_program, move_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(move_lightprobes_program);glDetachShader(move_lightprobes_program, move_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(move_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(move_lightprobes_program, move_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(move_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(move_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(move_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }pad_lightprobes_program = glCreateProgram(); assert(pad_lightprobes_program, "could not create pad_lightprobes_program, GL error", glGetError());
 GLuint pad_lightprobes_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(pad_lightprobes_program_GL_VERTEX_SHADER, "could not create pad_lightprobes_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 x;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\nsmooth out vec2 sample_oct;\n\nvoid main()\n{\n    gl_Position.xy = x;\n    gl_Position.z = 0.0f;\n    gl_Position.w = 1.0f;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(pad_lightprobes_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_VERTEX_SHADER); glGetShaderiv(pad_lightprobes_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); 

 GLuint pad_lightprobes_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(pad_lightprobes_program_GL_FRAGMENT_SHADER, "could not create pad_lightprobes_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec4 depth;\n\nlayout(location = 0) uniform sampler2D lightprobe_color;\nlayout(location = 1) uniform sampler2D lightprobe_depth;\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvoid main()\n{\n    vec2 probe_pos = floor(gl_FragCoord.xy*(1.0f/lightprobe_padded_resolution));\n    vec2 oct = (gl_FragCoord.xy-probe_pos*lightprobe_padded_resolution-1.0f)/lightprobe_resolution-0.5f;\n    if(abs(oct.x) > 0.5)\n        oct.y = -oct.y;\n    if(abs(oct.y) > 0.5)\n        oct.x = -oct.x;\n    ivec2 sample_coord = ivec2(probe_pos*lightprobe_padded_resolution+1.0f\n                               +clamp((oct+0.5f)*lightprobe_resolution, 0, lightprobe_resolution-1));\n    color = texelFetch(lightprobe_color, sample_coord, 0);\n    depth = texelFetch(lightprobe_depth, sample_coord, 0);\n\n    color.a = 1;\n    depth.a = 1;\n}\n"; glShaderSource(pad_lightprobes_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); glGetShaderiv(pad_lightprobes_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(pad_lightprobes_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile pad_lightprobes_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glLinkProgram(pad_lightprobes_program);glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_VERTEX_SHADER); glDeleteShader(pad_lightprobes_program_GL_VERTEX_SHADER); 
glDetachShader(pad_lightprobes_program, pad_lightprobes_program_GL_FRAGMENT_SHADER); glDeleteShader(pad_lightprobes_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(pad_lightprobes_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(pad_lightprobes_program, available_memory, 0, info_log); log_error(info_log); }render_chunk_program = glCreateProgram(); assert(render_chunk_program, "could not create render_chunk_program, GL error", glGetError());
 GLuint render_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_chunk_program_GL_VERTEX_SHADER, "could not create render_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(render_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_chunk_program, render_chunk_program_GL_VERTEX_SHADER); 

 GLuint render_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_chunk_program_GL_FRAGMENT_SHADER, "could not create render_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\n\nlayout(location = 0) uniform mat3 camera_axes;\nlayout(location = 1) uniform vec3 camera_pos;\nlayout(location = 2) uniform sampler2D material_visual_properties;\nlayout(location = 3) uniform usampler3D materials;\nlayout(location = 4) uniform usampler3D active_regions;\nlayout(location = 5) uniform usampler3D occupied_regions;\nlayout(location = 6) uniform isampler3D body_materials;\nlayout(location = 7) uniform ivec3 size;\nlayout(location = 8) uniform ivec3 origin;\nlayout(location = 9) uniform sampler2D lightprobe_color;\nlayout(location = 10) uniform sampler2D lightprobe_depth;\nlayout(location = 11) uniform sampler2D lightprobe_x;\nlayout(location = 12) uniform sampler2D blue_noise_texture;\nlayout(location = 13) uniform int frame_number;\nlayout(location = 14) uniform int n_bodies;\n\n// #define DEBUG_DOTS\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec4 quasi_noise(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec4(g, sq(g), g*sq(g), sq(sq(g))));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    // ivec3 materials_origin;\n    // ivec3 size;\n    // vec3 x_cm;\n    // vec3 x;\n    // vec3 x_dot;\n    // vec4 orientation;\n    // vec3 omega;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n        }\n        else\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != 0)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            int depth = SURF_DEPTH-depth(voxel);\n            if(depth >= 3\n               // #ifdef ACTIVE_REGIONS\n               // && texelFetch(active_regions, ipos>>4, 0).r == 0\n               // #endif //ACTIVE_REGIONS\n                )\n            {\n                float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                pos += ray_dir*skip_dist;\n                hit_dist += skip_dist;\n                ipos = ivec3(floor(pos));\n            }\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    frag_color = vec4(0,0,0,1);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 0;\n\n    // // float prepass_jump_dist = max(texture(prepass_depth, 0.5f*screen_pos.xy+0.5f, 0).a-2.0f, 0.0f);\n    // float prepass_jump_dist = 10*max_iterations;\n    // for(int x = -1; x < 1; x++)\n    // for(int y = -1; y < 1; y++)\n    // {\n    //     prepass_jump_dist = clamp(\n    //         texture(prepass_depth, 0.5f*screen_pos.xy+0.5f+0.5f*vec2((x)/360.0f,(y)/180.0f), 0).a-4.0f,\n    //         0.0f, prepass_jump_dist);\n    // }\n    // // {\n    // //     frag_color.rgb = vec3(1.0f-prepass_jump_dist/200.0f);\n    // //     return;\n    // // }\n    // pos += prepass_jump_dist*ray_dir;\n    // total_dist += prepass_jump_dist;\n\n    float bounding_jump_dist = 0.0;\n    if(pos.x < 0 && ray_dir.x > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += bounding_jump_dist*ray_dir;\n    total_dist += bounding_jump_dist;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    uvec4 voxel;\n    bool hit = cast_ray(materials, ray_dir, pos, size, origin, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 200);\n    // bool hit = coarse_cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n    // voxel = texelFetch(materials, hit_cell, 0);\n\n    for(int b = 0; b < n_bodies; b++)\n    {\n        vec3 body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n        vec3 body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n        vec4 body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n        ivec3 body_size = ivec3(bodies[b].size_x,\n                                bodies[b].size_y,\n                                bodies[b].size_z);\n        ivec3 body_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n\n        //ray info in the bodies frame\n        vec3 body_pos = apply_rotation(conjugate(body_orientation), pos-body_x) + body_x_cm;\n        vec3 body_ray_dir = apply_rotation(conjugate(body_orientation), ray_dir);\n\n        float body_jump_dist = 0.0;\n        if(body_pos.x < 0 && body_ray_dir.x > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.x)/(body_ray_dir.x));\n        if(body_pos.x > body_size.x && body_ray_dir.x < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.x-body_pos.x)/(body_ray_dir.x));\n        if(body_pos.y < 0 && body_ray_dir.y > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.y)/(body_ray_dir.y));\n        if(body_pos.y > body_size.y && body_ray_dir.y < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.y-body_pos.y)/(body_ray_dir.y));\n        if(body_pos.z < 0 && body_ray_dir.z > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.z)/(body_ray_dir.z));\n        if(body_pos.z > body_size.z && body_ray_dir.z < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.z-body_pos.z)/(body_ray_dir.z));\n\n        body_pos += body_jump_dist*body_ray_dir;\n\n        vec3 body_hit_pos;\n        float body_hit_dist;\n        ivec3 body_hit_cell;\n        vec3 body_hit_dir;\n        vec3 body_normal;\n        uvec4 body_voxel;\n        bool body_hit = cast_ray(body_materials, body_ray_dir, body_pos, body_size, body_origin, body_hit_pos, body_hit_dist, body_hit_cell, body_hit_dir, body_normal, body_voxel, 100);\n        // if(body_hit && (!hit || body_jump_dist+body_hit_dist < hit_dist) && b != 13 && b != 12)\n        if(body_hit && (!hit || body_jump_dist+body_hit_dist < hit_dist))\n        {\n            hit = true;\n            hit_pos = apply_rotation(body_orientation, body_hit_pos-body_x_cm)+body_x;\n            hit_dist = body_jump_dist+body_hit_dist;\n            hit_cell = body_hit_cell;\n            hit_dir = body_hit_dir;\n            normal = apply_rotation(body_orientation, body_normal);\n            voxel = body_voxel;\n        }\n    }\n\n    total_dist += hit_dist;\n    if(hit)\n    {\n        gl_FragDepth = 1.0f/total_dist;\n        uint material_id = voxel.r;\n        float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        frag_color.rgb += -(emission)*dot(normal, ray_dir);\n\n        float n_probe_samples = 1;\n        float n_ray_samples = 0;\n        float n_samples = n_probe_samples+n_ray_samples;\n        for(int samp = 0; samp < n_probe_samples; samp++)\n        {\n            vec3 reflection_normal = normal+0.5*roughness*(blue_noise(gl_FragCoord.xy/256.0+samp*vec2(0.82,0.34)).xyz-0.5f);\n            // vec3 reflection_normal = normal;\n            reflection_normal = normalize(reflection_normal);\n            vec3 reflection_dir = ray_dir - 2*dot(ray_dir, reflection_normal)*reflection_normal;\n            // vec3 reflection_dir = normal;\n            vec2 sample_depth;\n            frag_color.rgb += (1.0f/n_samples)*fr(material_id, reflection_dir, -ray_dir, normal)\n                *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        }\n        // for(int samp = 0; samp < n_ray_samples; samp++)\n        // {\n        //     vec3 reflection_dir = ray_dir - 2*dot(ray_dir, normal)*normal;\n        //     // reflection_dir += roughness*(blue_noise(gl_FragCoord.xy/256.0+(n_probe_samples*samp)*vec2(0.82,0.34)).xyz-0.5f);\n        //     reflection_dir = normalize(reflection_dir);\n        //     vec3 reflect_pos = hit_pos+0.5*reflection_dir;\n        //     // bool hit = coarse_cast_ray(reflection_dir, reflect_pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n        //     bool hit = cast_ray(materials, reflection_dir, reflect_pos, size, origin, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 50);\n        //     vec3 reflectance = fr(material_id, reflection_dir, -ray_dir, normal);\n        //     if(hit)\n        //     {\n        //         // int material_id = texelFetch(materials, hit_cell, 0).r;\n        //         int material_id = voxel.r;\n        //         float roughness = get_roughness(material_id);\n        //         vec3 emission = get_emission(material_id);\n\n        //         frag_color.rgb += (1.0f/n_samples)*reflectance*(emission)*dot(normal, reflection_dir);\n\n        //         vec2 sample_depth;\n\n        //         vec3 reflection2_dir = ray_dir - 2*dot(ray_dir, normal)*normal;\n        //         reflection2_dir += roughness*(blue_noise(gl_FragCoord.xy/256.0+samp*vec2(0.82,0.34)).xyz-0.5f);\n        //         reflection2_dir = normalize(reflection2_dir);\n        //         frag_color.rgb += (1.0f/n_samples)*reflectance\n        //             *fr(material_id, reflection2_dir, -reflection_dir, normal)\n        //             *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        //     }\n        //     else\n        //     {\n        //         vec2 sample_depth;\n        //         frag_color.rgb += (1.0f/n_samples)*fr(material_id, reflection_dir, -ray_dir, normal)\n        //             *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        //     }\n        // }\n    }\n    // else\n    // {\n    //     vec2 sample_depth;\n    //     vec3 sample_color = sample_lightprobe_color(hit_pos, ray_dir, vec_to_oct(ray_dir), sample_depth);\n    //     gl_FragDepth = 1.0f-sample_depth.r/(512.0f*sqrt(3));\n    //     gl_FragDepth = clamp(gl_FragDepth, -1, 1);\n    //     frag_color.rgb = sample_color;\n    //     frag_color.a = 1.0f;\n    // }\n\n    // frag_color.rgb = mix(frag_color.rgb, sample_lightprobe_color(camera_pos, ray_dir, vec_to_oct(ray_dir)), 0.2);\n\n    // frag_color.rgb = mix(vec3(1,0,0), vec3(0,0,1), n_texture_reads*1.0/20);\n    // frag_color.rgb = mix(vec3(1,0,0), vec3(0,0,1), i*1.0/20);\n    // frag_color.rgb *= clamp(1.0-1.0*total_dist/chunk_size, 0, 1);\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n}\n"; glShaderSource(render_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_chunk_program, render_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_chunk_program);glDetachShader(render_chunk_program, render_chunk_program_GL_VERTEX_SHADER); glDeleteShader(render_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(render_chunk_program, render_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(render_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_chunk_program, available_memory, 0, info_log); log_error(info_log); }render_depth_prepass_program = glCreateProgram(); assert(render_depth_prepass_program, "could not create render_depth_prepass_program, GL error", glGetError());
 GLuint render_depth_prepass_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_depth_prepass_program_GL_VERTEX_SHADER, "could not create render_depth_prepass_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_depth_prepass_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_VERTEX_SHADER); glGetShaderiv(render_depth_prepass_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); 

 GLuint render_depth_prepass_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_depth_prepass_program_GL_FRAGMENT_SHADER, "could not create render_depth_prepass_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 depth;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform vec3 camera_pos;\nlayout(location = 3) uniform isampler3D materials;\nlayout(location = 4) uniform usampler3D occupied_regions;\nlayout(location = 5) uniform ivec3 size;\nlayout(location = 6) uniform ivec3 origin;\nlayout(location = 7) uniform sampler2D blue_noise_texture;\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+PHI*frame_number);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec2 sample_pos = screen_pos.xy;\n    sample_pos += (blue_noise(gl_FragCoord.xy/256.0f+vec2(0.319f, 0.712f)).xy-0.5f)/vec2(360, 180);\n    vec3 ray_dir = (16.0/9.0*sample_pos.x*camera_axes[0]\n                    +        sample_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    vec3 hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int max_iterations = 200;\n    int i = 0;\n    float total_dist = 0;\n\n    if(pos.x < 0 && ray_dir.x > 0)      total_dist = max(total_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) total_dist = max(total_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      total_dist = max(total_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) total_dist = max(total_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      total_dist = max(total_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) total_dist = max(total_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += total_dist*ray_dir;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    int bounces_remaining = 5;\n    bool first_hit = true;\n    vec3 color_multiplier = vec3(1,1,1);\n\n    depth = vec4(0.0);\n\n    // {\n    //     vec3 dist = ((0.5*ray_sign+0.5)*size-ray_sign*pos)*invabs_ray_dir;\n    //     float min_dist = dist.x;\n    //     int min_dir = 0;\n    //     if(dist.y < min_dist) {\n    //         min_dist = dist.y;\n    //         min_dir = 1;\n    //     }\n    //     if(dist.z < min_dist) {\n    //         min_dist = dist.z;\n    //         min_dir = 2;\n    //     }\n    //     ivec3 max_displacement = ivec3(ceil(abs(min_dist*ray_dir)));\n    //     max_iterations = max_displacement.x+max_displacement.y+max_displacement.z;\n    // }\n    // max_iterations = min(max_iterations, 100);\n    // max_iterations = max(max_iterations, 100);\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return;\n        }\n        while(texelFetch(occupied_regions, ipos/16, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos/16.0f)-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            total_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n\n            if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n               || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n            {\n                return;\n            }\n\n            if(++i >= max_iterations)\n            {\n                return;\n            }\n        }\n\n        ivec4 voxel = texelFetch(materials, ipos+origin, 0);\n        if(voxel.r != 0)\n        {\n            float roughness = 0.0f;\n            vec3 emission = vec3(0.0f);\n            if(voxel.r == 2)\n            {\n                emission = vec3(0.05,0.05,0.1);\n            }\n            if(voxel.r == 4)\n            {\n                emission = vec3(1.0,1.0,1.0);\n            }\n\n            if(voxel.r > 1)\n            {\n                roughness = 0.8;\n            }\n            else\n            {\n                roughness = 0.9;\n            }\n\n            ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign);\n            vec3 gradient = vec3(\n                texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                );\n            vec3 normal = gradient;\n            normal += roughness*(blue_noise(gl_FragCoord.xy/256.0).rgb-0.5f);\n            normal = normalize(normal);\n            gradient = normalize(gradient);\n\n            depth.rgb += color_multiplier*emission;\n\n            if(voxel.r == 1)\n            {\n                color_multiplier *= vec3(0.54,0.44,0.21);\n                roughness = 0.9;\n            }\n            else if(voxel.r == 3)\n            {\n                color_multiplier *= vec3(0.5,0.5,1.0);\n                roughness = 0.1;\n            }\n            else\n            {\n                color_multiplier *= vec3(0.1,0.1,0.2);\n                roughness = 0.1;\n            }\n\n            color_multiplier *= -dot(ray_dir, normal);\n\n            if(first_hit)\n            {\n                color_multiplier = vec3(1,1,1);\n                depth.rgb = vec3(0,0,0);\n                depth.a = total_dist;\n                first_hit = false;\n            }\n            if(bounces_remaining-- <= 0)\n            {\n                return;\n            }\n            else\n            {\n                ray_dir -= 2*dot(ray_dir, normal)*normal;\n                ray_sign = sign(ray_dir);\n\n                invabs_ray_dir = ray_sign/ray_dir;\n            }\n        }\n\n        if(voxel.g >= 3)\n        {\n            float skip_dist = (voxel.g-2)/dot(ray_dir,ray_sign);\n            pos += ray_dir*skip_dist;\n            total_dist += skip_dist;\n            ipos = ivec3(floor(pos));\n        }\n\n        vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n        vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n        float min_dist = dot(dist, min_dir);\n        pos += min_dist*ray_dir;\n        ipos += ivec3(min_dir*ray_sign);\n        total_dist += min_dist;\n        hit_dir = min_dir;\n\n        // if(first_hit)\n        // {^all that stuff}\n        // else\n        // {\n        //     pos += ray_dir*coarse_step;\n        //     total_dist += coarse_step;\n        //     ipos = ivec3(floor(pos));\n        //     coarse_step += 1.0f*coarse_step*(float_noise(pos.xy+pos.zz));\n        // }\n\n        if(++i >= max_iterations)\n        {\n            return;\n        }\n    }\n}\n"; glShaderSource(render_depth_prepass_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_depth_prepass_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_depth_prepass_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_depth_prepass_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_depth_prepass_program);glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_VERTEX_SHADER); glDeleteShader(render_depth_prepass_program_GL_VERTEX_SHADER); 
glDetachShader(render_depth_prepass_program, render_depth_prepass_program_GL_FRAGMENT_SHADER); glDeleteShader(render_depth_prepass_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_depth_prepass_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_depth_prepass_program, available_memory, 0, info_log); log_error(info_log); }render_prepass_program = glCreateProgram(); assert(render_prepass_program, "could not create render_prepass_program, GL error", glGetError());
 GLuint render_prepass_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_prepass_program_GL_VERTEX_SHADER, "could not create render_prepass_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_prepass_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_prepass_program_GL_VERTEX_SHADER); glGetShaderiv(render_prepass_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_prepass_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_prepass_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_prepass_program, render_prepass_program_GL_VERTEX_SHADER); 

 GLuint render_prepass_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_prepass_program_GL_FRAGMENT_SHADER, "could not create render_prepass_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec3 voxel_x;\nlayout(location = 1) out vec4 voxel_orientation;\nlayout(location = 2) out uvec4 voxel_data;\nlayout(location = 3) out vec3 voxel_color;\n\nlayout(location = 0) uniform mat3 camera_axes;\nlayout(location = 1) uniform vec3 camera_pos;\nlayout(location = 2) uniform sampler2D material_visual_properties;\nlayout(location = 3) uniform usampler3D materials;\nlayout(location = 4) uniform usampler3D active_regions;\nlayout(location = 5) uniform usampler3D occupied_regions;\nlayout(location = 6) uniform isampler3D body_materials;\nlayout(location = 7) uniform ivec3 size;\nlayout(location = 8) uniform ivec3 origin;\nlayout(location = 9) uniform sampler2D lightprobe_color;\nlayout(location = 10) uniform sampler2D lightprobe_depth;\nlayout(location = 11) uniform sampler2D lightprobe_x;\nlayout(location = 12) uniform sampler2D blue_noise_texture;\nlayout(location = 13) uniform int frame_number;\nlayout(location = 14) uniform int n_bodies;\n\n// #define DEBUG_DOTS\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec4 quasi_noise(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec4(g, sq(g), g*sq(g), sq(sq(g))));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    // ivec3 materials_origin;\n    // ivec3 size;\n    // vec3 x_cm;\n    // vec3 x;\n    // vec3 x_dot;\n    // vec4 orientation;\n    // vec3 omega;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\n#define ACTIVE_REGIONS\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n        }\n        else\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != 0)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            int depth = SURF_DEPTH-depth(voxel);\n            if(depth >= 3\n               // #ifdef ACTIVE_REGIONS\n               // && texelFetch(active_regions, ipos>>4, 0).r == 0\n               // #endif //ACTIVE_REGIONS\n                )\n            {\n                float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                pos += ray_dir*skip_dist;\n                hit_dist += skip_dist;\n                ipos = ivec3(floor(pos));\n            }\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\n// float float_noise(uint seed)\n// {\n//     return fract(float(int(seed))/1.0e9);\n// }\n\nfloat float_noise(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    voxel_data = uvec4(0,0,0,0);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 pos = camera_pos;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 0;\n\n    voxel_orientation = vec4(1,0,0,0);\n\n    float bounding_jump_dist = 0.0;\n    if(pos.x < 0 && ray_dir.x > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.x)/(ray_dir.x));\n    if(pos.x > size.x && ray_dir.x < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.x-pos.x)/(ray_dir.x));\n    if(pos.y < 0 && ray_dir.y > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.y)/(ray_dir.y));\n    if(pos.y > size.y && ray_dir.y < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.y-pos.y)/(ray_dir.y));\n    if(pos.z < 0 && ray_dir.z > 0)      bounding_jump_dist = max(bounding_jump_dist, -epsilon+(-pos.z)/(ray_dir.z));\n    if(pos.z > size.z && ray_dir.z < 0) bounding_jump_dist = max(bounding_jump_dist, -epsilon+(size.z-pos.z)/(ray_dir.z));\n\n    pos += bounding_jump_dist*ray_dir;\n    total_dist += bounding_jump_dist;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    uvec4 voxel;\n    bool hit = cast_ray(materials, ray_dir, pos, size, origin, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 200);\n    // bool hit = coarse_cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n    // voxel = texelFetch(materials, hit_cell, 0);\n\n    if(hit)\n    {\n        voxel_x = vec3(hit_cell)+0.5;\n    }\n\n    for(int b = 0; b < n_bodies; b++)\n    {\n        vec3 body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n        vec3 body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n        vec4 body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n        ivec3 body_size = ivec3(bodies[b].size_x,\n                                bodies[b].size_y,\n                                bodies[b].size_z);\n        ivec3 body_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n\n        //ray info in the bodies frame\n        vec3 body_pos = apply_rotation(conjugate(body_orientation), pos-body_x) + body_x_cm;\n        vec3 body_ray_dir = apply_rotation(conjugate(body_orientation), ray_dir);\n\n        float body_jump_dist = 0.0;\n        if(body_pos.x < 0 && body_ray_dir.x > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.x)/(body_ray_dir.x));\n        if(body_pos.x > body_size.x && body_ray_dir.x < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.x-body_pos.x)/(body_ray_dir.x));\n        if(body_pos.y < 0 && body_ray_dir.y > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.y)/(body_ray_dir.y));\n        if(body_pos.y > body_size.y && body_ray_dir.y < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.y-body_pos.y)/(body_ray_dir.y));\n        if(body_pos.z < 0 && body_ray_dir.z > 0)      body_jump_dist = max(body_jump_dist, -epsilon+(-body_pos.z)/(body_ray_dir.z));\n        if(body_pos.z > body_size.z && body_ray_dir.z < 0) body_jump_dist = max(body_jump_dist, -epsilon+(body_size.z-body_pos.z)/(body_ray_dir.z));\n\n        body_pos += body_jump_dist*body_ray_dir;\n\n        vec3 body_hit_pos;\n        float body_hit_dist;\n        ivec3 body_hit_cell;\n        vec3 body_hit_dir;\n        vec3 body_normal;\n        uvec4 body_voxel;\n        bool body_hit = cast_ray(body_materials, body_ray_dir, body_pos, body_size, body_origin, body_hit_pos, body_hit_dist, body_hit_cell, body_hit_dir, body_normal, body_voxel, 100);\n        // if(body_hit && (!hit || body_jump_dist+body_hit_dist < hit_dist) && b != 13 && b != 12)\n        if(body_hit && (!hit || body_jump_dist+body_hit_dist < hit_dist))\n        {\n            hit = true;\n            hit_pos = apply_rotation(body_orientation, body_hit_pos-body_x_cm)+body_x;\n            hit_dist = body_jump_dist+body_hit_dist;\n            hit_cell = body_hit_cell;\n            hit_dir = body_hit_dir;\n            normal = apply_rotation(body_orientation, body_normal);\n            voxel = body_voxel;\n            voxel_orientation = body_orientation;\n            voxel_x = apply_rotation(body_orientation, vec3(body_hit_cell)-body_x_cm+0.5)+body_x;\n        }\n    }\n\n    total_dist += hit_dist;\n    if(hit)\n    {\n        normal = normalize(unnormalized_gradient(materials, hit_cell));\n        voxel_data = voxel;\n        gl_FragDepth = 1.0f/total_dist;\n\n        // uint material_id = voxel.r;\n        // float roughness = get_roughness(material_id);\n        // vec3 emission = get_emission(material_id);\n\n        // voxel_color.rgb += -(emission)*dot(normal, ray_dir);\n\n        // float n_probe_samples = 1;\n        // float n_ray_samples = 0;\n        // float n_samples = n_probe_samples+n_ray_samples;\n        // for(int samp = 0; samp < n_probe_samples; samp++)\n        // {\n        //     vec3 reflection_normal = normal+0.5*roughness*(blue_noise(gl_FragCoord.xy/256.0+samp*vec2(0.82,0.34)).xyz-0.5f);\n        //     // vec3 reflection_normal = normal;\n        //     reflection_normal = normalize(reflection_normal);\n        //     vec3 reflection_dir = ray_dir - 2*dot(ray_dir, reflection_normal)*reflection_normal;\n        //     // vec3 reflection_dir = normal;\n        //     vec2 sample_depth;\n        //     voxel_color.rgb += (1.0f/n_samples)*fr(material_id, reflection_dir, -ray_dir, normal)\n        //         *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        // }\n\n        // for(int samp = 0; samp < n_ray_samples; samp++)\n        // {\n        //     vec3 reflection_dir = ray_dir - 2*dot(ray_dir, normal)*normal;\n        //     // reflection_dir += roughness*(blue_noise(gl_FragCoord.xy/256.0+(n_probe_samples*samp)*vec2(0.82,0.34)).xyz-0.5f);\n        //     reflection_dir = normalize(reflection_dir);\n        //     vec3 reflect_pos = hit_pos+0.5*reflection_dir;\n        //     // bool hit = coarse_cast_ray(reflection_dir, reflect_pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n        //     bool hit = cast_ray(materials, reflection_dir, reflect_pos, size, origin, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 50);\n        //     vec3 reflectance = fr(material_id, reflection_dir, -ray_dir, normal);\n        //     if(hit)\n        //     {\n        //         // int material_id = texelFetch(materials, hit_cell, 0).r;\n        //         int material_id = voxel.r;\n        //         float roughness = get_roughness(material_id);\n        //         vec3 emission = get_emission(material_id);\n\n        //         voxel_color.rgb += (1.0f/n_samples)*reflectance*(emission)*dot(normal, reflection_dir);\n\n        //         vec2 sample_depth;\n\n        //         vec3 reflection2_dir = ray_dir - 2*dot(ray_dir, normal)*normal;\n        //         reflection2_dir += roughness*(blue_noise(gl_FragCoord.xy/256.0+samp*vec2(0.82,0.34)).xyz-0.5f);\n        //         reflection2_dir = normalize(reflection2_dir);\n        //         voxel_color.rgb += (1.0f/n_samples)*reflectance\n        //             *fr(material_id, reflection2_dir, -reflection_dir, normal)\n        //             *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        //     }\n        //     else\n        //     {\n        //         vec2 sample_depth;\n        //         voxel_color.rgb += (1.0f/n_samples)*fr(material_id, reflection_dir, -ray_dir, normal)\n        //             *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        //     }\n        // }\n    }\n    // else\n    // {\n    //     vec2 sample_depth;\n    //     vec3 sample_color = sample_lightprobe_color(hit_pos, ray_dir, vec_to_oct(ray_dir), sample_depth);\n    //     gl_FragDepth = 1.0f-sample_depth.r/(512.0f*sqrt(3));\n    //     gl_FragDepth = clamp(gl_FragDepth, -1, 1);\n    //     voxel_color.rgb = sample_color;\n    //     voxel_color.a = 1.0f;\n    // }\n\n    // voxel_color.rgb = mix(voxel_color.rgb, sample_lightprobe_color(camera_pos, ray_dir, vec_to_oct(ray_dir)), 0.2);\n\n    // voxel_color.rgb = mix(vec3(1,0,0), vec3(0,0,1), n_texture_reads*1.0/20);\n    // voxel_color.rgb = mix(vec3(1,0,0), vec3(0,0,1), i*1.0/20);\n    // voxel_color.rgb *= clamp(1.0-1.0*total_dist/chunk_size, 0, 1);\n\n    // voxel_color.rgb = clamp(voxel_color.rgb, 0, 1);\n}\n"; glShaderSource(render_prepass_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_prepass_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_prepass_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_prepass_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_prepass_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_prepass_program, render_prepass_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_prepass_program);glDetachShader(render_prepass_program, render_prepass_program_GL_VERTEX_SHADER); glDeleteShader(render_prepass_program_GL_VERTEX_SHADER); 
glDetachShader(render_prepass_program, render_prepass_program_GL_FRAGMENT_SHADER); glDeleteShader(render_prepass_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_prepass_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_prepass_program, available_memory, 0, info_log); log_error(info_log); }render_world_program = glCreateProgram(); assert(render_world_program, "could not create render_world_program, GL error", glGetError());
 GLuint render_world_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(render_world_program_GL_VERTEX_SHADER, "could not create render_world_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 screen_pos;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    screen_pos = x.xy;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(render_world_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(render_world_program_GL_VERTEX_SHADER); glGetShaderiv(render_world_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_world_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_world_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(render_world_program, render_world_program_GL_VERTEX_SHADER); 

 GLuint render_world_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(render_world_program_GL_FRAGMENT_SHADER, "could not create render_world_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 frag_color;\nlayout(location = 1) out vec3 normal;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform mat3 camera_axes;\nlayout(location = 2) uniform vec3 camera_pos;\nlayout(location = 3) uniform sampler2D material_visual_properties;\nlayout(location = 4) uniform sampler2D prepass_x;\nlayout(location = 5) uniform sampler2D prepass_orientation;\nlayout(location = 6) uniform usampler2D prepass_voxel;\nlayout(location = 7) uniform sampler2D prepass_color;\nlayout(location = 8) uniform sampler2D lightprobe_color;\nlayout(location = 9) uniform sampler2D lightprobe_depth;\nlayout(location = 10) uniform sampler2D lightprobe_x;\nlayout(location = 11) uniform sampler2D blue_noise_texture;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec4 quasi_noise(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec4(g, sq(g), g*sq(g), sq(sq(g))));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 screen_pos;\n\nvoid main()\n{\n    float fov = pi*120.0/180.0;\n    float screen_dist = 1.0/tan(fov/2);\n    vec3 ray_dir = (16.0/9.0*screen_pos.x*camera_axes[0]\n                    +        screen_pos.y*camera_axes[1]\n                    -        screen_dist *camera_axes[2]);\n    // vec3 ray_dir = (16.0/9.0*sin(screen_pos.x)*camera_axes[0]\n    //                 +        sin(screen_pos.y)*camera_axes[1]\n    //                 -        cos(screen_pos.x)*cos(screen_pos.y)*screen_dist *camera_axes[2]);\n    ray_dir = normalize(ray_dir);\n\n    frag_color = vec4(0,0,0,1);\n    vec3 reflectivity = vec3(1,1,1);\n\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    float epsilon = 0.02;\n    int i = 0;\n    float total_dist = 10000;\n\n\n    vec2 prepass_resolution = vec2(1280/2, 720/2);\n\n    ivec2 prepass_coord = ivec2((0.5*screen_pos+0.5)*prepass_resolution-0.5);\n\n    uvec4 voxel;\n    vec3 hit_pos;\n\n    ivec2 d = ivec2(0);\n    for(d.y = 0; d.y <= 1; d.y++)\n        for(d.x = 0; d.x <= 1; d.x++)\n        {\n            vec3 x = texelFetch(prepass_x, prepass_coord+d, 0).xyz;\n            vec4 orientation = texelFetch(prepass_orientation, prepass_coord+d, 0);\n            vec4 inv_orientation = conjugate(orientation);\n\n            vec3 cube_ray_dir = apply_rotation(inv_orientation, ray_dir);\n            vec3 cube_ray_pos = apply_rotation(inv_orientation, camera_pos-x);\n\n            vec3 ray_sign = sign_not_zero(cube_ray_dir);\n            cube_ray_dir *= -ray_sign;\n            cube_ray_pos *= -ray_sign;\n            cube_ray_pos -= 0.5; //origin placed at front-most corner\n            vec3 dist = -cube_ray_pos/cube_ray_dir;\n            vec3 max_dir = step(dist.zxy, dist.xyz)*step(dist.yzx, dist.xyz);\n            float face_dist = dot(max_dir, dist);\n            vec3 hit_x = cube_ray_pos+face_dist*cube_ray_dir;\n            vec3 outmost_edge = step(hit_x.zxy, hit_x.xyz)*step(hit_x.yzx, hit_x.xyz);\n\n            if(all(greaterThan(hit_x, vec3(-1.0)-face_dist/100)) &&\n               face_dist < total_dist && face_dist > 0)\n            {\n                total_dist = face_dist;\n                frag_color.rgb = texelFetch(prepass_color, prepass_coord+d, 0).rgb;\n                voxel = texelFetch(prepass_voxel, prepass_coord+d, 0);\n                normal = apply_rotation(orientation, -ray_sign*max_dir);\n                hit_pos = camera_pos+face_dist*ray_dir;\n                // frag_color.rgb = max_dir;\n            }\n        }\n\n    //\n    {\n        uint material_id = voxel.r;\n        float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        frag_color.rgb += -(emission)*dot(normal, ray_dir);\n\n        int n_probe_samples = 1;\n        int n_ray_samples = 0;\n        int n_samples = n_probe_samples+n_ray_samples;\n        for(int samp = 0; samp < n_probe_samples; samp++)\n        {\n            int noise_index = ((n_samples*samp+(frame_number%1))*256*256+(int(gl_FragCoord.x)%256)*256+(int(gl_FragCoord.y)%256));\n            // vec3 reflection_normal = normal+0.5*roughness*(quasi_noise(noise_index).xyz-0.5f);\n            // vec3 reflection_normal = normal+0.5*roughness*(static_blue_noise(gl_FragCoord.xy/256.0+samp*vec2(0.82,0.34)).xyz-0.5f);\n            vec3 reflection_normal = normal;\n            reflection_normal = normalize(reflection_normal);\n            // vec3 reflection_dir = ray_dir - 2*dot(ray_dir, reflection_normal)*reflection_normal;\n            vec3 reflection_dir = normal;\n            vec2 sample_depth;\n            frag_color.rgb += (1.0f/n_samples)*fr(material_id, reflection_dir, -ray_dir, normal)\n                *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        }\n        // for(int samp = 0; samp < n_ray_samples; samp++)\n        // {\n        //     vec3 reflection_dir = ray_dir - 2*dot(ray_dir, normal)*normal;\n        //     // reflection_dir += roughness*(blue_noise(gl_FragCoord.xy/256.0+(n_probe_samples*samp)*vec2(0.82,0.34)).xyz-0.5f);\n        //     reflection_dir = normalize(reflection_dir);\n        //     vec3 reflect_pos = hit_pos+0.5*reflection_dir;\n        //     // bool hit = coarse_cast_ray(reflection_dir, reflect_pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n        //     bool hit = cast_ray(materials, reflection_dir, reflect_pos, size, origin, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 50);\n        //     vec3 reflectance = fr(material_id, reflection_dir, -ray_dir, normal);\n        //     if(hit)\n        //     {\n        //         // int material_id = texelFetch(materials, hit_cell, 0).r;\n        //         int material_id = voxel.r;\n        //         float roughness = get_roughness(material_id);\n        //         vec3 emission = get_emission(material_id);\n\n        //         frag_color.rgb += (1.0f/n_samples)*reflectance*(emission)*dot(normal, reflection_dir);\n\n        //         vec2 sample_depth;\n\n        //         vec3 reflection2_dir = ray_dir - 2*dot(ray_dir, normal)*normal;\n        //         reflection2_dir += roughness*(blue_noise(gl_FragCoord.xy/256.0+samp*vec2(0.82,0.34)).xyz-0.5f);\n        //         reflection2_dir = normalize(reflection2_dir);\n        //         frag_color.rgb += (1.0f/n_samples)*reflectance\n        //             *fr(material_id, reflection2_dir, -reflection_dir, normal)\n        //             *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        //     }\n        //     else\n        //     {\n        //         vec2 sample_depth;\n        //         frag_color.rgb += (1.0f/n_samples)*fr(material_id, reflection_dir, -ray_dir, normal)\n        //             *sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n        //     }\n        // }\n    }\n\n    frag_color.rgb = clamp(frag_color.rgb, 0, 1);\n    // frag_color.rgb = normal;\n    gl_FragDepth = 1.0f/total_dist;\n}\n"; glShaderSource(render_world_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(render_world_program_GL_FRAGMENT_SHADER); glGetShaderiv(render_world_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(render_world_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile render_world_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(render_world_program, render_world_program_GL_FRAGMENT_SHADER); 
glLinkProgram(render_world_program);glDetachShader(render_world_program, render_world_program_GL_VERTEX_SHADER); glDeleteShader(render_world_program_GL_VERTEX_SHADER); 
glDetachShader(render_world_program, render_world_program_GL_FRAGMENT_SHADER); glDeleteShader(render_world_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(render_world_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(render_world_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_program = glCreateProgram(); assert(simulate_body_program, "could not create simulate_body_program, GL error", glGetError());
 GLuint simulate_body_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_body_program_GL_VERTEX_SHADER, "could not create simulate_body_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 5) uniform int n_bodies;\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    // ivec3 materials_origin;\n    // ivec3 size;\n    // vec3 x_cm;\n    // vec3 x;\n    // vec3 x_dot;\n    // vec4 orientation;\n    // vec3 omega;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\n#define PARTICLE_DATA_BINDING 1\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nflat out int b;\n\nvoid main()\n{\n    b = gl_InstanceID;\n\n    // get_body_data(b);\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    float scale = 2.0/256.0;\n\n    gl_Position = vec4(0.0/0.0, 0.0/0.0, 0, 1);\n\n    const int padding = 2;\n\n    if(body_materials_origin.z-padding <= layer && layer < body_materials_origin.z+body_size.z+padding)\n    {\n        gl_Position.xy = scale*(body_materials_origin.xy-padding+(body_size.xy+2*padding)*x.xy)-1.0;\n    }\n\n    if(b == 0 && layer == 0 && gl_VertexID == 0)\n    {\n        int dead_index = atomicAdd(n_dead_particles, -1)-1;\n        //this assumes particle creation and destruction never happen simutaneously\n        uint p = dead_particles[dead_index];\n        particles[p].voxel_data = 2|(2<<(6+8))|(8<<(2+16));\n        particles[p].x = bodies[b].x_x;\n        particles[p].y = bodies[b].x_y;\n        particles[p].z = bodies[b].x_z;\n        particles[p].x_dot = bodies[b].x_dot_x;\n        particles[p].y_dot = bodies[b].x_dot_y;\n        particles[p].z_dot = bodies[b].x_dot_z+5;\n        particles[p].alive = true;\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_body_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_body_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_body_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_body_program, simulate_body_program_GL_VERTEX_SHADER); 

 GLuint simulate_body_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_body_program_GL_FRAGMENT_SHADER, "could not create simulate_body_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out uvec4 frag_color;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int frame_number;\nlayout(location = 2) uniform sampler2D material_physical_properties;\nlayout(location = 3) uniform usampler3D materials;\nlayout(location = 4) uniform usampler3D body_materials;\n\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    // ivec3 materials_origin;\n    // ivec3 size;\n    // vec3 x_cm;\n    // vec3 x;\n    // vec3 x_dot;\n    // vec4 orientation;\n    // vec3 omega;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\n\nflat in int b;\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\nvoid main()\n{\n    ivec3 pos;\n    pos.xy = ivec2(gl_FragCoord.xy);\n    pos.z = layer;\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    uint rot = rand(rand(rand(frame_number)))%4;\n    int i = 0;\n    ivec2 dir = ivec2(((rot&1)*(2-rot)), (1-(rot&1))*(1-rot));\n\n    uvec4 c  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z), 0);\n    uvec4 u  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z+1), 0);\n    uvec4 d  = texelFetch(body_materials, ivec3(pos.x, pos.y, pos.z-1), 0);\n    uvec4 r  = texelFetch(body_materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z), 0);\n    uvec4 l  = texelFetch(body_materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z), 0);\n    uvec4 f  = texelFetch(body_materials, ivec3(pos.x-dir.y, pos.y+dir.x, pos.z), 0);\n    uvec4 ba  = texelFetch(body_materials, ivec3(pos.x+dir.y, pos.y-dir.x, pos.z), 0);\n\n    // c.r = 1;\n    frag_color = c;\n\n    int depth = SURF_DEPTH;\n    if(c.r > 0)\n    {\n        if(l.r == 0 ||\n           r.r == 0 ||\n           u.r == 0 ||\n           d.r == 0 ||\n           f.r == 0 ||\n           ba.r == 0) depth = SURF_DEPTH;\n        else\n        {\n            depth = MAX_DEPTH-1;\n            depth = min(depth, depth(l)+1);\n            depth = min(depth, depth(r)+1);\n            depth = min(depth, depth(u)+1);\n            depth = min(depth, depth(d)+1);\n            depth = min(depth, depth(f)+1);\n            depth = min(depth, depth(ba)+1);\n        }\n\n        frag_color.b = c.b/2;\n        if(frag_color.r == 3) frag_color.b = 1000;\n        // frag_color.b = 0;\n    }\n    else\n    {\n        depth = 0;\n        depth = max(depth, depth(l)-1);\n        depth = max(depth, depth(r)-1);\n        depth = max(depth, depth(u)-1);\n        depth = max(depth, depth(d)-1);\n        depth = max(depth, depth(f)-1);\n        depth = max(depth, depth(ba)-1);\n    }\n\n    frag_color.g = uint(depth);\n\n    frag_color.b = 1000;\n}\n"; glShaderSource(simulate_body_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_body_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_body_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_body_program, simulate_body_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_body_program);glDetachShader(simulate_body_program, simulate_body_program_GL_VERTEX_SHADER); glDeleteShader(simulate_body_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_body_program, simulate_body_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_body_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_body_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_program, available_memory, 0, info_log); log_error(info_log); }simulate_body_physics_program = glCreateProgram(); assert(simulate_body_physics_program, "could not create simulate_body_physics_program, GL error", glGetError());
 GLuint simulate_body_physics_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_body_physics_program_GL_VERTEX_SHADER, "could not create simulate_body_physics_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec3 x;\n\nsmooth out vec2 uv;\n\nvoid main()\n{\n    gl_Position.xyz = x;\n    gl_Position.w = 1.0;\n    uv = 0.5*x.xy+0.5;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_body_physics_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_body_physics_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_body_physics_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_physics_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_physics_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_body_physics_program, simulate_body_physics_program_GL_VERTEX_SHADER); 

 GLuint simulate_body_physics_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_body_physics_program_GL_FRAGMENT_SHADER, "could not create simulate_body_physics_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec3 p1;\nlayout(location = 1) out vec3 p2;\nlayout(location = 2) out vec3 p3;\nlayout(location = 3) out vec3 n1;\nlayout(location = 4) out vec3 n2;\nlayout(location = 5) out vec3 n3;\nlayout(location = 6) out uvec3 contact_materials;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform usampler3D materials;\nlayout(location = 2) uniform usampler3D body_materials;\nlayout(location = 3) uniform sampler3D body_forces;\nlayout(location = 4) uniform sampler3D body_shifts;\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    // ivec3 materials_origin;\n    // ivec3 size;\n    // vec3 x_cm;\n    // vec3 x;\n    // vec3 x_dot;\n    // vec4 orientation;\n    // vec3 omega;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\n\nsmooth in vec2 uv;\n\nconst int chunk_size = 256;\n\n#define N_MAX_COLLISION_POINTS 256\nvoid find_collision_points(out vec3 world_collision_points[N_MAX_COLLISION_POINTS], out ivec3 world_collision_coord[N_MAX_COLLISION_POINTS], out int n_collision_points)\n{\n    n_collision_points = 0;\n\n    //TODO: maybe use space filling curves\n    for(int test_z = 0; test_z < body_size.z; test_z+=1)\n        for(int test_y = 0; test_y < body_size.y; test_y+=1)\n            for(int test_x = 0; test_x < body_size.x; test_x+=1)\n            {\n\n                ivec3 body_coord = ivec3(test_x, test_y, test_z);\n                vec3 world_coord = apply_rotation(body_orientation, vec3(body_coord)+0.5-body_x_cm)+body_x;\n\n                uvec4 body_voxel = texelFetch(body_materials, body_materials_origin+body_coord, 0);\n\n                // if(body_voxel.g == 0 && body_voxel.r > 0)\n                if(depth(body_voxel) == SURF_DEPTH)\n                {\n                    ivec3 wvc = ivec3(world_coord); //world_voxel_coord\n                    uvec4 world_voxel = texelFetch(materials, wvc, 0);\n                    vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n                    // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n                    if(depth(world_voxel) >= SURF_DEPTH-1)\n                    {\n                        world_collision_points[n_collision_points] = world_coord;\n                        world_collision_coord[n_collision_points] = wvc;\n                        n_collision_points++;\n                        if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                    }\n\n                    // for(int wz = 0; wz <= 1; wz++)\n                    //     for(int wy = 0; wy <= 1; wy++)\n                    //         for(int wx = 0; wx <= 1; wx++)\n                    //         {\n                    //             ivec3 wvc = ivec3(world_coord-0.5)+ivec3(wx,wy,wz); //world_voxel_coord\n                    //             ivec4 world_voxel = voxelFetch(materials, wvc);\n                    //             vec3 rel_pos = vec3(wvc)+0.5-world_coord;\n                    //             // if(world_voxel.r > 0 && dot(rel_pos, rel_pos) <= 1.0)\n                    //             if(world_voxel.g <= 2)\n                    //             {\n                    //                 world_collision_points[n_collision_points] = world_coord;\n                    //                 world_collision_coord[n_collision_points] = wvc;\n                    //                 n_collision_points++;\n                    //                 if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                    //             }\n                    //         }\n                }\n\n                test_x += int(max(abs(depth(body_voxel)-SURF_DEPTH)-1, 0));\n            }\n}\n\n//TODO: have better method of choosing points\nvoid find_surface_points(out vec3 world_collision_points[N_MAX_COLLISION_POINTS], out ivec3 world_collision_coord[N_MAX_COLLISION_POINTS], out int n_collision_points)\n{\n    n_collision_points = 0;\n\n    //TODO: maybe use space filling curves\n    for(int test_z = 0; test_z < body_size.z; test_z+=1)\n        for(int test_y = 0; test_y < body_size.y; test_y+=1)\n            for(int test_x = 0; test_x < body_size.x; test_x+=1)\n            {\n\n                ivec3 body_coord = ivec3(test_x, test_y, test_z);\n                vec3 world_coord = apply_rotation(body_orientation, vec3(body_coord)+0.5-body_x_cm)+body_x;\n\n                uvec4 body_voxel = texelFetch(body_materials, body_materials_origin+body_coord, 0);\n\n                // if(body_voxel.g == 0 && body_voxel.r > 0)\n                if(depth(body_voxel) == SURF_DEPTH)\n                {\n                    ivec3 wvc = ivec3(world_coord); //world_voxel_coord\n\n                    world_collision_points[n_collision_points] = world_coord;\n                    world_collision_coord[n_collision_points] = wvc;\n                    n_collision_points++;\n                    if(n_collision_points >= N_MAX_COLLISION_POINTS) return;\n                }\n\n                test_x += int(max(abs(depth(body_voxel)-SURF_DEPTH)-1, 0));\n            }\n}\n\nvoid main()\n{\n    int b = int(gl_FragCoord.y);\n    // int b = 0;\n\n    get_body_data(b);\n\n    p1 = vec3(0);\n    p2 = vec3(0);\n    p3 = vec3(0);\n    n1 = vec3(0,0,1);\n    n2 = vec3(0,0,1);\n    n3 = vec3(0,0,1);\n    contact_materials = uvec3(0);\n\n    vec3 world_collision_points[N_MAX_COLLISION_POINTS];\n    ivec3 world_collision_coord[N_MAX_COLLISION_POINTS];\n    int n_collision_points = 0;\n\n    find_collision_points(world_collision_points, world_collision_coord, n_collision_points);\n\n    if(n_collision_points == 0)\n        find_surface_points(world_collision_points, world_collision_coord, n_collision_points);\n\n    vec3 impulses[N_MAX_COLLISION_POINTS] = vec3[N_MAX_COLLISION_POINTS](0);\n\n    float d1 = 16;\n    float d2 = 16;\n    float d3 = 16;\n\n    uint best_depth = MAX_DEPTH;\n    float best_rsq = 16;\n    for(int cp = 0; cp < n_collision_points; cp++)\n    {\n        vec3 world_coord = world_collision_points[cp];\n        ivec3 wvc = world_collision_coord[cp]; //world_voxel_coord\n        uvec4 world_voxel = texelFetch(materials, wvc, 0);\n        vec3 r = world_coord-body_x;\n        float rsq = dot(r, r);\n        if(depth(world_voxel) < best_depth || (depth(world_voxel) == best_depth && rsq < best_rsq))\n        {\n            best_depth = depth(world_voxel);\n            best_rsq = rsq;\n            p1 = world_coord;\n            d1 = depth(world_voxel);\n            contact_materials.r = world_voxel.r;\n        }\n    }\n\n    float best_asq = 0;\n    for(int cp = 0; cp < n_collision_points; cp++)\n    {\n        vec3 world_coord = world_collision_points[cp];\n        ivec3 wvc = world_collision_coord[cp]; //world_voxel_coord\n        uvec4 world_voxel = texelFetch(materials, wvc, 0);\n        float asq = dot(world_coord-p1, world_coord-p1);\n        if(asq > best_asq)\n        {\n            best_asq = asq;\n            p2 = world_coord;\n            d2 = depth(world_voxel);\n            contact_materials.g = world_voxel.r;\n        }\n    }\n\n    float best_bsq = -1;\n    for(int cp = 0; cp < n_collision_points; cp++)\n    {\n        vec3 world_coord = world_collision_points[cp];\n        ivec3 wvc = world_collision_coord[cp]; //world_voxel_coord\n        uvec4 world_voxel = texelFetch(materials, wvc, 0);\n        vec3 ab = normalize(p2-p1);\n        vec3 ac = world_coord-p1;\n        float bsq = dot(ac, ac) - sq(dot(ac, ab));\n        if(bsq > best_bsq)\n        {\n            best_bsq = bsq;\n            p3 = world_coord;\n            d3 = depth(world_voxel);\n            contact_materials.b = world_voxel.r;\n        }\n    }\n\n    d1 += 1;\n    d2 += 1;\n    d3 += 1;\n\n    ivec3 ip1 = ivec3(p1);\n    n1 = vec3(\n        float(depth(texelFetch(materials, ip1+ivec3(-1,0,0), 0)))-float(depth(texelFetch(materials, ip1+ivec3(+1,0,0), 0))),\n        float(depth(texelFetch(materials, ip1+ivec3(0,-1,0), 0)))-float(depth(texelFetch(materials, ip1+ivec3(0,+1,0), 0))),\n        float(depth(texelFetch(materials, ip1+ivec3(0,0,-1), 0)))-float(depth(texelFetch(materials, ip1+ivec3(0,0,+1), 0)))+0.001);\n    n1 = d1*normalize(n1);\n\n    ivec3 ip2 = ivec3(p2);\n    n2 = vec3(\n        float(depth(texelFetch(materials, ip2+ivec3(-1,0,0), 0)))-float(depth(texelFetch(materials, ip2+ivec3(+1,0,0), 0))),\n        float(depth(texelFetch(materials, ip2+ivec3(0,-1,0), 0)))-float(depth(texelFetch(materials, ip2+ivec3(0,+1,0), 0))),\n        float(depth(texelFetch(materials, ip2+ivec3(0,0,-1), 0)))-float(depth(texelFetch(materials, ip2+ivec3(0,0,+1), 0)))+0.001);\n    n2 = d2*normalize(n1);\n\n    ivec3 ip3 = ivec3(p3);\n    n3 = vec3(\n        float(depth(texelFetch(materials, ip3+ivec3(-1,0,0), 0)))-float(depth(texelFetch(materials, ip3+ivec3(+1,0,0), 0))),\n        float(depth(texelFetch(materials, ip3+ivec3(0,-1,0), 0)))-float(depth(texelFetch(materials, ip3+ivec3(0,+1,0), 0))),\n        float(depth(texelFetch(materials, ip3+ivec3(0,0,-1), 0)))-float(depth(texelFetch(materials, ip3+ivec3(0,0,+1), 0)))+0.001);\n    n3 = d3*normalize(n1);\n}\n"; glShaderSource(simulate_body_physics_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_body_physics_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_body_physics_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_body_physics_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_body_physics_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_body_physics_program, simulate_body_physics_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_body_physics_program);glDetachShader(simulate_body_physics_program, simulate_body_physics_program_GL_VERTEX_SHADER); glDeleteShader(simulate_body_physics_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_body_physics_program, simulate_body_physics_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_body_physics_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_body_physics_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_body_physics_program, available_memory, 0, info_log); log_error(info_log); }simulate_chunk_program = glCreateProgram(); assert(simulate_chunk_program, "could not create simulate_chunk_program, GL error", glGetError());
 GLuint simulate_chunk_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(simulate_chunk_program_GL_VERTEX_SHADER, "could not create simulate_chunk_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 r;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 4) uniform usampler3D active_regions_in;\nlayout(location = 6) uniform writeonly uimage3D occupied_regions_out;\n\nout vec3 p;\n\nvoid main()\n{\n    int z = layer/16;\n    int y = int(X.y);\n    int x = int(X.x);\n\n    p=vec3(16*x,16*y,layer);\n\n    gl_Position = vec4(-2,-2,0,1);\n\n    float scale = 2.0f/32.0f;\n\n    uint region_active = texelFetch(active_regions_in, ivec3(x, y, z), 0).r;\n    if(region_active != 0)\n    {\n        if(gl_VertexID == 0 && layer%16 == 0) imageStore(occupied_regions_out, ivec3(x,y,z), uvec4(0,0,0,0));\n        gl_Position.xy = -1.0f+scale*(r+X);\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(simulate_chunk_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_program_GL_VERTEX_SHADER); glGetShaderiv(simulate_chunk_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(simulate_chunk_program, simulate_chunk_program_GL_VERTEX_SHADER); 

 GLuint simulate_chunk_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(simulate_chunk_program_GL_FRAGMENT_SHADER, "could not create simulate_chunk_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out uvec4 out_voxel;\n\nlayout(location = 0) uniform int layer;\nlayout(location = 1) uniform int frame_number;\nlayout(location = 2) uniform sampler2D material_physical_properties;\nlayout(location = 3) uniform usampler3D materials;\nlayout(location = 5) uniform writeonly uimage3D active_regions_out;\nlayout(location = 6) uniform writeonly uimage3D occupied_regions_out;\nlayout(location = 7) uniform int update_cells;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\n\nin vec3 p;\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return fract(float(int(seed))/1.0e10);\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    float scale = 1.0/chunk_size;\n    // ivec2 pos = ivec2(chunk_size*uv);\n    // ivec2 pos = ivec2(gl_FragCoord.xy);\n    ivec3 pos = ivec3(p);\n    ivec3 cell_p;\n    cell_p.xy = ivec2(gl_FragCoord.xy)%16;\n    cell_p.z = pos.z%16;\n    pos.xy += cell_p.xy;\n\n    //+,0,-,0\n    //0,+,0,-\n    // int rot = (frame_number+layer)%4;\n    uint rot = rand(rand(rand(frame_number)))%4;\n    int i = 0;\n    ivec2 dir = ivec2(((rot&1)*(2-rot)), (1-(rot&1))*(1-rot));\n\n    uvec4 c  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z),0);\n    uvec4 u  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z+1),0);\n    uvec4 d  = texelFetch(materials, ivec3(pos.x, pos.y, pos.z-1),0);\n    uvec4 r  = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z),0);\n    uvec4 l  = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z),0);\n    uvec4 dr = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z-1),0);\n    uvec4 ur = texelFetch(materials, ivec3(pos.x+dir.x, pos.y+dir.y, pos.z+1),0);\n\n    uvec4 f  = texelFetch(materials, ivec3(pos.x-dir.y, pos.y+dir.x, pos.z),0);\n    uvec4 b  = texelFetch(materials, ivec3(pos.x+dir.y, pos.y-dir.x, pos.z),0);\n\n    uvec4 ul = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z+1),0);\n    uvec4 ll = texelFetch(materials, ivec3(pos.x-2*dir.x, pos.y-2*dir.y, pos.z),0);\n    uvec4 dl = texelFetch(materials, ivec3(pos.x-dir.x, pos.y-dir.y, pos.z-1),0);\n\n    out_voxel = c;\n    if(update_cells == 1)\n    {\n        if(mat(c) == 0)\n        { //central cell is empty\n\n            //check if upper cell fell           , liquids and sands\n            //then check if upper left cell fell , liquids and sands\n            //then check if left cell flowed     , liquids\n            if(mat(u) != 0 && phase(u) != phase_solid && transient(u)==0)\n                out_voxel = u;\n            else if(mat(l) != 0 && mat(ul) != 0 && phase(u) != phase_solid && phase(ul) != phase_solid && transient(ul)==0)\n                out_voxel = ul;\n            else if(mat(dl) != 0 && mat(d) != 0 && phase(l) == phase_liquid && mat(ll) != 0 && transient(l)==0)\n                out_voxel = l;\n            //might be better to multiply things by 0 instead of branching\n        }\n        else if(phase(c) != phase_solid && transient(c)==0)\n        { //if the cell is not empty and not solid check if it fell or flew\n            bool fall_allowed = (pos.z > 0 && (mat(d) == 0 || (mat(dr) == 0 && mat(r) == 0)));\n            bool flow_allowed = (pos.z > 0 && mat(r) == 0 && mat(ur) == 0 && mat(u) == 0 && mat(l) != 0 && phase(c) > phase_sand);\n            if(fall_allowed || flow_allowed) out_voxel = uvec4(0);\n        }\n    }\n\n    int depth = SURF_DEPTH;\n    if(mat(c) != 0 && transient(c)==0)\n    {\n        if(mat(l) == 0 || transient(l) != 0 ||\n           mat(r) == 0 || transient(r) != 0 ||\n           mat(u) == 0 || transient(u) != 0 ||\n           mat(d) == 0 || transient(d) != 0 ||\n           mat(f) == 0 || transient(f) != 0 ||\n           mat(b) == 0 || transient(b) != 0) depth = SURF_DEPTH;\n        else\n        {\n            depth = MAX_DEPTH-1;\n            depth = min(depth, depth(l)+1);\n            depth = min(depth, depth(r)+1);\n            depth = min(depth, depth(u)+1);\n            depth = min(depth, depth(d)+1);\n            depth = min(depth, depth(f)+1);\n            depth = min(depth, depth(b)+1);\n        }\n    }\n    else\n    {\n        depth = 0;\n        depth = max(depth, depth(l)-1);\n        depth = max(depth, depth(r)-1);\n        depth = max(depth, depth(u)-1);\n        depth = max(depth, depth(d)-1);\n        depth = max(depth, depth(f)-1);\n        depth = max(depth, depth(b)-1);\n    }\n\n    uint phase = phase_solid;\n    if(hardness(mat(out_voxel)) == 0.0)                        phase = phase_sand;\n    if(float(temp(out_voxel)) > melting_point(mat(out_voxel))) phase = phase_liquid;\n    if(float(temp(out_voxel)) > boiling_point(mat(out_voxel))) phase = phase_gas;\n\n    uint transient = transient(out_voxel);\n    if(transient == 1)\n    {\n        out_voxel.r = 0;\n        transient = 0;\n    }\n\n    uint temp = 8;\n\n    out_voxel.g = uint(depth) | (phase << 6);\n\n    out_voxel.b = transient | (temp<<2);\n\n    // bool changed = c.r != out_voxel.r || c.g != out_voxel.g || c.b != out_voxel.b;\n    bool changed = c.r != out_voxel.r || c.g != out_voxel.g;\n    if(changed)\n    {\n        imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.x==15) imageStore(active_regions_out, ivec3(pos.x/16+1, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.x== 0) imageStore(active_regions_out, ivec3(pos.x/16-1, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.y==15) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16+1, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.y== 0) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16-1, pos.z/16), uvec4(1,0,0,0));\n        if(cell_p.z==15) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16+1), uvec4(1,0,0,0));\n        if(cell_p.z== 0) imageStore(active_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16-1), uvec4(1,0,0,0));\n    }\n\n    if(c.r > 0) imageStore(occupied_regions_out, ivec3(pos.x/16, pos.y/16, pos.z/16), uvec4(1,0,0,0));\n}\n"; glShaderSource(simulate_chunk_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(simulate_chunk_program_GL_FRAGMENT_SHADER); glGetShaderiv(simulate_chunk_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_chunk_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_chunk_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(simulate_chunk_program, simulate_chunk_program_GL_FRAGMENT_SHADER); 
glLinkProgram(simulate_chunk_program);glDetachShader(simulate_chunk_program, simulate_chunk_program_GL_VERTEX_SHADER); glDeleteShader(simulate_chunk_program_GL_VERTEX_SHADER); 
glDetachShader(simulate_chunk_program, simulate_chunk_program_GL_FRAGMENT_SHADER); glDeleteShader(simulate_chunk_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(simulate_chunk_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_chunk_program, available_memory, 0, info_log); log_error(info_log); }simulate_particles_program = glCreateProgram(); assert(simulate_particles_program, "could not create simulate_particles_program, GL error", glGetError());
 GLuint simulate_particles_program_GL_COMPUTE_SHADER = glCreateShader(GL_COMPUTE_SHADER); assert(simulate_particles_program_GL_COMPUTE_SHADER, "could not create simulate_particles_program_GL_COMPUTE_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\n// #define N_MAX_PARTICLES 65536\n\nlayout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_physical_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform writeonly uimage3D materials_out;\nlayout(location = 4) uniform writeonly uimage3D active_regions_out;\nlayout(location = 5) uniform writeonly uimage3D occupied_regions_out;\n\n#define MATERIAL_PHYSICAL_PROPERTIES\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\n\n#ifndef PARTICLE_DATA_BINDING\n#define PARTICLE_DATA_BINDING 0\n#endif\n\nstruct particle\n{\n    uint voxel_data;\n    float x;\n    float y;\n    float z;\n    float x_dot;\n    float y_dot;\n    float z_dot;\n\n    bool alive;\n};\n\n#define N_MAX_PARTICLES 4096\n\nlayout(std430, binding = PARTICLE_DATA_BINDING) buffer particle_data\n{\n    int n_dead_particles;\n    particle particles[N_MAX_PARTICLES];\n    uint dead_particles[N_MAX_PARTICLES];\n};\n\n//buffer for particles\n//imageStore to put particles back into materials texture\n//write to particle buffer in chunk simulation, atomically index particle count\n//dead and alive lists\n\n\nuint rand(uint seed)\n{\n    seed ^= seed<<13;\n    seed ^= seed>>17;\n    seed ^= seed<<5;\n    return seed;\n}\n\nfloat float_noise(uint seed)\n{\n    return float(int(seed))/1.0e10;\n}\n\nconst int chunk_size = 256;\n\nvoid main()\n{\n    uint p = gl_GlobalInvocationID.x;\n    if(!particles[p].alive) return;\n    vec3 x = vec3(particles[p].x, particles[p].y, particles[p].z);\n    vec3 x_dot = vec3(particles[p].x_dot, particles[p].y_dot, particles[p].z_dot);\n\n    x += x_dot;\n    x_dot.z -= 0.1;\n    int i = 0;\n    uint transient = 1;\n    while(mat(texelFetch(materials, ivec3(x), 0)) != 0)\n    {\n        vec3 normal = normalize(unnormalized_gradient(materials, ivec3(x)));\n        // x += max(0.1f, float(SURF_DEPTH-depth(voxel)))*normal;\n        x += 0.05f*normal;\n        x_dot -= dot(x_dot, normal)*normal;\n\n        transient = 0;\n        if(i++ > 50)\n        {\n            break;\n        }\n    }\n\n    particles[p].x = x.x;\n    particles[p].y = x.y;\n    particles[p].z = x.z;\n\n    particles[p].x_dot = x_dot.x;\n    particles[p].y_dot = x_dot.y;\n    particles[p].z_dot = x_dot.z;\n\n    if(transient == 0 && mat(texelFetch(materials, ivec3(x), 0)) == 0)\n    {\n        uint v = particles[p].voxel_data;\n        uvec4 particle_voxel_data = uvec4((v&0xF), ((v>>8)&0xF), ((v>>16)&0xF)|transient, ((v>>24)&0xF));\n        imageStore(materials_out, ivec3(x), particle_voxel_data);\n        imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16), uvec4(1,0,0,0));\n        ivec3 cell_x = ivec3(x)%16;\n        if(cell_x.x==15) imageStore(active_regions_out, ivec3(x.x/16+1, x.y/16, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.x== 0) imageStore(active_regions_out, ivec3(x.x/16-1, x.y/16, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.y==15) imageStore(active_regions_out, ivec3(x.x/16, x.y/16+1, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.y== 0) imageStore(active_regions_out, ivec3(x.x/16, x.y/16-1, x.z/16), uvec4(1,0,0,0));\n        if(cell_x.z==15) imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16+1), uvec4(1,0,0,0));\n        if(cell_x.z== 0) imageStore(active_regions_out, ivec3(x.x/16, x.y/16, x.z/16-1), uvec4(1,0,0,0));\n        imageStore(occupied_regions_out, ivec3(x.x/16, x.y/16, x.z/16), uvec4(1,0,0,0));\n\n        particles[p].alive = false;\n        int dead_index = atomicAdd(n_dead_particles, 1);\n        dead_particles[dead_index] = p;\n    }\n}\n"; glShaderSource(simulate_particles_program_GL_COMPUTE_SHADER, 1, &source, 0);}glCompileShader(simulate_particles_program_GL_COMPUTE_SHADER); glGetShaderiv(simulate_particles_program_GL_COMPUTE_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(simulate_particles_program_GL_COMPUTE_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile simulate_particles_program_GL_COMPUTE_SHADER:\n", info_log); } glAttachShader(simulate_particles_program, simulate_particles_program_GL_COMPUTE_SHADER); 
glLinkProgram(simulate_particles_program);glDetachShader(simulate_particles_program, simulate_particles_program_GL_COMPUTE_SHADER); glDeleteShader(simulate_particles_program_GL_COMPUTE_SHADER); 
glGetProgramiv(simulate_particles_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(simulate_particles_program, available_memory, 0, info_log); log_error(info_log); }update_lightmap_program = glCreateProgram(); assert(update_lightmap_program, "could not create update_lightmap_program, GL error", glGetError());
 GLuint update_lightmap_program_GL_VERTEX_SHADER = glCreateShader(GL_VERTEX_SHADER); assert(update_lightmap_program_GL_VERTEX_SHADER, "could not create update_lightmap_program_GL_VERTEX_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) in vec2 x;\nlayout(location = 1) in vec2 X;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 4) uniform sampler2D lightprobe_color;\nlayout(location = 5) uniform sampler2D lightprobe_depth;\nlayout(location = 6) uniform sampler2D lightprobe_x;\nlayout(location = 7) uniform sampler2D blue_noise_texture;\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec4 quasi_noise(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec4(g, sq(g), g*sq(g), sq(sq(g))));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth out vec2 sample_oct;\n\nvoid main()\n{\n    // vec2 sample_coord = blue_noise(vec2(gl_InstanceID*PHI/256.0f, 0)).xy;\n    // gl_Position.xy = 2.0f*sample_coord-1.0f;\n    // gl_Position.z = 0.0f;\n\n    // sample_oct = 2.0f*fract(gl_Position.xy*vec2(256, 128))-1.0f;\n\n    vec2 scale = 2.0f/vec2(lightprobes_w, lightprobes_h);\n    vec2 scale2 = (0.5f*scale*lightprobe_resolution)/lightprobe_padded_resolution;\n\n    gl_Position.xy = scale*(X+0.5)-1+scale2*x;\n    gl_Position.z = 0.0f;\n    gl_Position.w = 1.0f;\n    sample_oct = x;\n}\n\n/////////////////////////////////////////////////////////////////\n\n"; glShaderSource(update_lightmap_program_GL_VERTEX_SHADER, 1, &source, 0);}glCompileShader(update_lightmap_program_GL_VERTEX_SHADER); glGetShaderiv(update_lightmap_program_GL_VERTEX_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_lightmap_program_GL_VERTEX_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_lightmap_program_GL_VERTEX_SHADER:\n", info_log); } glAttachShader(update_lightmap_program, update_lightmap_program_GL_VERTEX_SHADER); 

 GLuint update_lightmap_program_GL_FRAGMENT_SHADER = glCreateShader(GL_FRAGMENT_SHADER); assert(update_lightmap_program_GL_FRAGMENT_SHADER, "could not create update_lightmap_program_GL_FRAGMENT_SHADER, GL error", glGetError());{const char* source = "#version 460\n#define pi 3.14159265358979323846264338327950\n#define PHI 1.618033988749894848204586834365638117720\n#define PHI2 1.324717957244746\n#define PHI3 1.22074408460575947536\n#define PHI4 1.1673039782614187\n\n#define sq(x) ((x)*(x))\n\n\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec4 depth;\n\nlayout(location = 0) uniform int frame_number;\nlayout(location = 1) uniform sampler2D material_visual_properties;\nlayout(location = 2) uniform usampler3D materials;\nlayout(location = 3) uniform usampler3D occupied_regions;\nlayout(location = 4) uniform sampler2D lightprobe_color;\nlayout(location = 5) uniform sampler2D lightprobe_depth;\nlayout(location = 6) uniform sampler2D lightprobe_x;\nlayout(location = 7) uniform sampler2D blue_noise_texture;\n\nivec3 size = ivec3(512);\nivec3 origin = ivec3(0);\n\nvec3 sign_not_zero(vec3 p) {\n    return 2*step(0, p)-1;\n}\n\nvec4 conjugate(vec4 q)\n{\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 axis_to_quaternion(vec3 axis)\n{\n    float half_angle = length(axis)/2;\n    if(half_angle <= 0.0001) return vec4(1,0,0,0);\n    vec3 axis_hat = normalize(axis);\n    float s = sin(half_angle);\n    float c = cos(half_angle);\n    return vec4(c, s*axis_hat.x, s*axis_hat.y, s*axis_hat.z);\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,\n                a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,\n                a.x*b.z+a.z*b.x+a.w*b.y-a.y*b.w,\n                a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y);\n}\n\nvec3 apply_rotation(vec4 q, vec3 p)\n{\n    vec4 p_quat = vec4(0, p.x, p.y, p.z);\n    vec4 q_out = qmult(qmult(q, p_quat), vec4(q.x, -q.y, -q.z, -q.w));\n    return q_out.yzw;\n}\n\nvec4 blue_noise(vec2 co)\n{\n    return fract(texture(blue_noise_texture, co)+(frame_number%100)*vec4(1.0/PHI4,1.0/(PHI4*PHI4),1.0/(PHI4*PHI4*PHI4),1.0/(PHI4*PHI4*PHI4*PHI4)));\n}\n\nvec4 static_blue_noise(vec2 co)\n{\n    return texture(blue_noise_texture, co);\n}\n\nvec4 quasi_noise(int i)\n{\n    float g = 1.0/PHI3;\n    return fract(0.5+i*vec4(g, sq(g), g*sq(g), sq(sq(g))));\n    // return vec4(fract(0.5 + vec2(i*12664745, i*9560333)/exp2(24.)),0,0);\n}\n\n#ifndef BODY_DATA_BINDING\n#define BODY_DATA_BINDING 0\n#endif\n\nstruct body\n{\n    int materials_origin_x; int materials_origin_y; int materials_origin_z;\n    int size_x; int size_y; int size_z;\n    float x_cm_x; float x_cm_y; float x_cm_z;\n    float x_x; float x_y; float x_z;\n    float x_dot_x; float x_dot_y; float x_dot_z;\n    float orientation_r; float orientation_x; float orientation_y; float orientation_z;\n    float omega_x; float omega_y; float omega_z;\n\n    float m;\n\n    float I_xx; float I_yx; float I_zx;\n    float I_xy; float I_yy; float I_zy;\n    float I_xz; float I_yz; float I_zz;\n\n    float invI_xx; float invI_yx; float invI_zx;\n    float invI_xy; float invI_yy; float invI_zy;\n    float invI_xz; float invI_yz; float invI_zz;\n\n    // ivec3 materials_origin;\n    // ivec3 size;\n    // vec3 x_cm;\n    // vec3 x;\n    // vec3 x_dot;\n    // vec4 orientation;\n    // vec3 omega;\n};\n\nivec3 body_materials_origin;\nivec3 body_size;\nvec3  body_x_cm;\nvec3  body_x;\nvec3  body_x_dot;\nvec4  body_orientation;\nvec3  body_omega;\n\nfloat body_m;\nmat3 body_I;\nmat3 body_invI;\n\nlayout(std430, binding = BODY_DATA_BINDING) buffer body_data\n{\n    body bodies[];\n};\n\nvoid get_body_data(int b)\n{\n    body_materials_origin = ivec3(bodies[b].materials_origin_x,\n                                  bodies[b].materials_origin_y,\n                                  bodies[b].materials_origin_z);\n    body_size = ivec3(bodies[b].size_x,\n                      bodies[b].size_y,\n                      bodies[b].size_z);\n\n    body_x_cm = vec3(bodies[b].x_cm_x, bodies[b].x_cm_y, bodies[b].x_cm_z);\n    body_x = vec3(bodies[b].x_x, bodies[b].x_y, bodies[b].x_z);\n    body_x_dot = vec3(bodies[b].x_dot_x, bodies[b].x_dot_y, bodies[b].x_dot_z);\n    body_orientation = vec4(bodies[b].orientation_r, bodies[b].orientation_x, bodies[b].orientation_y, bodies[b].orientation_z);\n    body_omega = vec3(bodies[b].omega_x, bodies[b].omega_y, bodies[b].omega_z);\n\n    body_m = bodies[b].m;\n    body_I = mat3(bodies[b].I_xx, bodies[b].I_yx, bodies[b].I_zx,\n                  bodies[b].I_xy, bodies[b].I_yy, bodies[b].I_zy,\n                  bodies[b].I_xz, bodies[b].I_yz, bodies[b].I_zz);\n    body_invI = mat3(bodies[b].invI_xx, bodies[b].invI_yx, bodies[b].invI_zx,\n                     bodies[b].invI_xy, bodies[b].invI_yy, bodies[b].invI_zy,\n                     bodies[b].invI_xz, bodies[b].invI_yz, bodies[b].invI_zz);\n}\n\nvec3 get_base_color(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(0,material_id), 0).rgb;\n}\n\nvec3 get_emission(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(1,material_id), 0).rgb;\n}\n\nfloat get_roughness(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).r;\n}\n\nfloat get_metalicity(uint material_id)\n{\n    return texelFetch(material_visual_properties, ivec2(2,material_id), 0).g;\n}\n\nfloat D(uint material_id, float nh)\n{\n    //Trowbridge-Reitz\n    float roughness = get_roughness(material_id);\n    float alphasq = pow(roughness, 4); //alpha = roughness^2\n    return alphasq/(pi*sq(sq(nh)*(alphasq-1)+1));\n}\n\nvec3 F(uint material_id, float lh)\n{\n    //Schlick approximation\n    vec3 F0 = mix(vec3(1), get_base_color(material_id), get_metalicity(material_id));\n    return F0-(vec3(1)-F0)*pow(1-lh, 5.0f);\n}\n\n//view factor, specular G/(4*dot(n, l)*dot(n,v))\nfloat V(uint material_id, float nh, float nl, float nv)\n{\n    float roughness = get_roughness(material_id);\n    float k = sq(roughness+1)/8;\n    // return 1.0f/(4*(nv*(1-k)+k)*(nl*(1-k)+k));\n    return 1.0f/4.0f;\n}\n\n//TODO: should also have transmittance\nvec3 fr(uint material_id, vec3 l, vec3 v, vec3 n)\n{\n    vec3 h = normalize(l+v);\n    float lh = dot(l,h);\n    float nh = dot(n,h);\n    float nl = dot(n,l);\n    float nv = dot(n,v);\n    // return (D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    vec3 diffuse = ((1.0f/pi)*nl)*get_base_color(material_id);\n    vec3 specular = (nl*D(material_id, nh)*V(material_id, lh, nl, nv))*F(material_id, lh);\n    float metalicity = get_metalicity(material_id);\n    return diffuse*(1-metalicity) + specular*mix(0.02, 1.0, metalicity);\n}\n\n#define         mat(vox) (vox.r)\n#define       depth(vox) (int(vox.g&0x1F))\n#define       phase(vox) (vox.g>>6)\n#define   transient(vox) (vox.b&0x3)\n#define        temp(vox) ((vox.b>>2)&0xF)\n#define    electric(vox) (vox.b>>6)\n#define    colorvar(vox) (vox.a)\n\n#define MAX_DEPTH 32\n#define SURF_DEPTH 16\n\n#define phase_solid  0\n#define phase_sand   1\n#define phase_liquid 2\n#define phase_gas    3\n\n#ifdef MATERIAL_PHYSICAL_PROPERTIES\n\nfloat density(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).r;\n}\n\nfloat hardness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).g;\n}\n\nfloat sharpness(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(0,material_id), 0).b;\n}\n\nfloat melting_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).r;\n}\n\nfloat boiling_point(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).g;\n}\n\nfloat heat_capacity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(1,material_id), 0).b;\n}\n\nfloat conductivity(uint material_id)\n{\n    return texelFetch(material_physical_properties, ivec2(2,material_id), 0).r;\n}\n#endif\n\nvec3 unnormalized_gradient(usampler3D materials, ivec3 p)\n{\n    // ivec2 d = ivec2(1,0);\n    // vec3 gradient = vec3(\n    //     depth(texelFetch(materials, p-d.xyy, 0))-depth(texelFetch(materials, p+d.xyy, 0)),\n    //     depth(texelFetch(materials, p-d.yxy, 0))-depth(texelFetch(materials, p+d.yxy, 0)),\n    //     depth(texelFetch(materials, p-d.yyx, 0))-depth(texelFetch(materials, p+d.yyx, 0))+0.001f\n    //     );\n\n    vec3 gradient = vec3(\n        depth(texelFetch(materials, p+ivec3(-1,0,0), 0))-depth(texelFetch(materials, p+ivec3(+1,0,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,-1,0), 0))-depth(texelFetch(materials, p+ivec3(0,+1,0), 0)),\n        depth(texelFetch(materials, p+ivec3(0,0,-1), 0))-depth(texelFetch(materials, p+ivec3(0,0,+1), 0))+0.001);\n    return gradient;\n}\n\nint n_texture_reads = 0;\n\nbool cast_ray(isampler3D materials, vec3 ray_dir, vec3 ray_origin, ivec3 size, ivec3 origin, out vec3 pos, out float hit_dist, out ivec3 hit_cell, out vec3 hit_dir, out vec3 normal, out uvec4 hit_voxel, int max_iterations)\n{\n\n    pos = ray_origin;\n    vec3 ray_sign = sign(ray_dir);\n\n    vec3 invabs_ray_dir = ray_sign/ray_dir;\n\n    hit_dir = vec3(0);\n\n    float epsilon = 0.02;\n    int i = 0;\n    hit_dist = 0;\n\n    ivec3 ipos = ivec3(floor(pos));\n\n    for(;;)\n    {\n        if(ipos.x < -1 || ipos.y < -1 || ipos.z < -1\n           || ipos.x > size.x || ipos.y > size.y || ipos.z > size.z)\n        {\n            return false;\n        }\n\n        if(texelFetch(occupied_regions, ipos>>4, 0).r == 0)\n        {\n            vec3 dist = ((0.5f*ray_sign+0.5f)*16.0f+ray_sign*(16.0f*floor(pos*(1.0f/16.0f))-pos))*invabs_ray_dir;\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            hit_dir = min_dir;\n\n            float step_dist = min_dist+epsilon;\n            pos += step_dist*ray_dir;\n            hit_dist += step_dist;\n            // hit_dir = min_dir;\n\n            ipos = ivec3(floor(pos));\n        }\n        else\n        {\n            n_texture_reads++;\n            uvec4 voxel = texelFetch(materials, ipos+origin, 0);\n            if(voxel.r != 0)\n            {\n                ivec3 ioutside = ipos - ivec3(hit_dir*ray_sign)+origin;\n                // vec3 gradient = vec3(\n                //     texelFetch(materials, ioutside+ivec3(1,0,0),0).g-texelFetch(materials, ioutside+ivec3(-1,0,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,1,0),0).g-texelFetch(materials, ioutside+ivec3(0,-1,0),0).g,\n                //     texelFetch(materials, ioutside+ivec3(0,0,1),0).g-texelFetch(materials, ioutside+ivec3(0,0,-1),0).g+0.001f\n                //     );\n                // normal = normalize(gradient);\n                normal = normalize(-hit_dir*ray_sign);\n\n                hit_cell = ipos;\n                hit_voxel = voxel;\n                return true;\n            }\n\n            int depth = SURF_DEPTH-depth(voxel);\n            if(depth >= 3\n               // #ifdef ACTIVE_REGIONS\n               // && texelFetch(active_regions, ipos>>4, 0).r == 0\n               // #endif //ACTIVE_REGIONS\n                )\n            {\n                float skip_dist = (depth-2)/dot(ray_dir,ray_sign);\n                pos += ray_dir*skip_dist;\n                hit_dist += skip_dist;\n                ipos = ivec3(floor(pos));\n            }\n\n            vec3 dist = (0.5f*ray_sign+0.5f+ray_sign*(vec3(ipos)-pos))*invabs_ray_dir;\n\n            vec3 min_dir = step(dist.xyz, dist.zxy)*step(dist.xyz, dist.yzx);\n            float min_dist = dot(dist, min_dir);\n            pos += min_dist*ray_dir;\n            ipos += ivec3(min_dir*ray_sign);\n            hit_dist += min_dist;\n            hit_dir = min_dir;\n        }\n\n        if(++i >= max_iterations)\n        {\n            return false;\n        }\n    }\n}\n\n#define lightprobes_per_axis 16\n#define lightprobe_spacing 32\n#define lightprobes_w 64\n#define lightprobes_h 64\n#define lightprobe_resolution 6\n#define lightprobe_padded_resolution (lightprobe_resolution+2)\n#define lightprobe_resolution_x (lightprobes_w*lightprobe_padded_resolution)\n#define lightprobe_resolution_y (lightprobes_h*lightprobe_padded_resolution)\n\n\nvec2 vec_to_oct(vec3 p)\n{\n    vec3 sign_p = sign_not_zero(p);\n    vec2 oct = p.xy * (1.0f/dot(p, sign_p));\n    return (p.z > 0) ? oct : (1.0f-abs(oct.yx))*sign_p.xy;\n}\n\nvec3 oct_to_vec(vec2 oct)\n{\n    vec2 sign_oct = sign(oct);\n    vec3 p = vec3(oct.xy, 1.0-dot(oct, sign_oct));\n    if(p.z < 0) p.xy = (1.0f-abs(p.yx))*sign_oct.xy;\n    return normalize(p);\n}\n\nfloat cdf(float x)\n{\n    return 0.5f*tanh(0.797884560803f*(x+0.044715f*x*x*x))+0.5f;\n}\n\nvec3 sample_lightprobe_color(vec3 pos, vec3 normal, vec2 sample_oct, out vec2 depth)\n{\n    pos = pos+8*normal; //bias away from surfaces\n    vec4 total_color = vec4(0);\n    depth = vec2(0);\n    for(int pz = 0; pz <= 1; pz++)\n        for(int py = 0; py <= 1; py++)\n            for(int px = 0; px <= 1; px++)\n            {\n                vec3 p = vec3(px, py, pz);\n                ivec3 ip = ivec3(px, py, pz);\n                ivec3 probe_pos = ivec3((pos-lightprobe_spacing/2)/lightprobe_spacing)+ip;\n                if(any(lessThan(probe_pos, vec3(0))) || any(greaterThanEqual(probe_pos, vec3(lightprobes_per_axis)))) continue;\n                int probe_index = int(dot(probe_pos, ivec3(1,lightprobes_per_axis,lightprobes_per_axis*lightprobes_per_axis)));\n                ivec2 probe_coord = ivec2(probe_index%lightprobes_w, probe_index/lightprobes_w);\n\n                // ivec2 sample_coord = lightprobe_resolution*probe_coord+ivec2(lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1));\n                vec2 sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*sample_oct+0.5f,0,1);\n\n                sample_coord += 0.5;\n                vec2 t = trunc(sample_coord);\n                vec2 f = fract(sample_coord);\n                f = f*f*f*(f*(f*6.0-15.0)+10.0);\n                // f = f*f*(-2*f+3);\n                sample_coord = t+f-0.5;\n\n                sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n\n                vec3 probe_x = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n\n                vec4 probe_color = texture(lightprobe_color, sample_coord);\n\n                vec3 dist = probe_x-pos;\n                float r = max(length(dist), 0.0001f);\n                vec3 dir = dist*(1.0f/r);\n\n                vec2 depth_sample_coord = vec2(lightprobe_padded_resolution*probe_coord+1)+lightprobe_resolution*clamp(0.5f*vec_to_oct(-dir)+0.5f,0,1);\n                depth_sample_coord *= vec2(1.0f/lightprobe_resolution_x, 1.0f/lightprobe_resolution_y);\n                vec2 probe_depth = texture(lightprobe_depth, depth_sample_coord).rg;\n\n                #ifdef DEBUG_DOTS\n                if(dot(dir, normal) > 0.999) return vec3(1,0,0);\n                #endif\n\n                // float weight = sq((dot(normal, dir)+1.0f)*0.5f)+0.2f;\n                float weight = 1.0;\n\n                vec3 trilinear_weights = 1.0f+(1-2*p)*(1.0f/lightprobe_spacing)*dist;\n                weight *= trilinear_weights.x*trilinear_weights.y*trilinear_weights.z+0.001;\n\n                // if(r > probe_depth.r)\n                // {\n                //     float variance = abs(probe_depth.g-(probe_depth.r*probe_depth.r));\n                //     weight *= variance/(variance+(r-probe_depth.r)*(r-probe_depth.r));\n                // }\n\n                // I think this makes more sense\n                float variance = abs(probe_depth.g-sq(probe_depth.r));\n                float x = (probe_depth.r-r)*inversesqrt(variance);\n                weight *= cdf(x);\n\n                weight = clamp(weight, 0, 1);\n\n                //this smoothly kills low values\n                const float threshold = 0.05f;\n                if(weight < threshold)\n                    weight *= sq(weight)/sq(threshold);\n\n                total_color += weight*sqrt(probe_color);\n                depth += weight*(probe_depth);\n            }\n    total_color.rgb = sq(total_color.rgb*(1.0f/total_color.a));\n    depth *= (1.0f/total_color.a);\n    return total_color.rgb;\n}\n\n\nsmooth in vec2 sample_oct;\n\nlayout(pixel_center_integer) in vec4 gl_FragCoord;\n\nvoid main()\n{\n    // vec2 sample_oct = 2*fract((gl_FragCoord.xy-1)*(1.0f/lightprobe_padded_resolution)\n    //                           +(blue_noise(gl_FragCoord.xy/256.0).xy)*(1.0f/lightprobe_resolution))-1;\n    // vec2 sample_oct = 2*fract((gl_FragCoord.xy+0.5f)*(1.0f/lightprobe_resolution))-1;\n\n    //really all this ray casting could happen in the vertex shader, not sure if there's an advantage either way\n    ivec2 probe_coord = ivec2(gl_FragCoord.xy/lightprobe_padded_resolution);\n    int probe_index = probe_coord.x+probe_coord.y*lightprobes_w;\n    ivec3 probe_pos = ivec3(probe_index%lightprobes_per_axis, (probe_index/lightprobes_per_axis)%lightprobes_per_axis, probe_index/(lightprobes_per_axis*lightprobes_per_axis));\n\n    vec2 jittered_oct = sample_oct+(blue_noise(gl_FragCoord.xy/256.0).xy-0.5f)*(2.0/lightprobe_resolution);\n    jittered_oct = clamp(jittered_oct, -1, 1);\n    vec3 ray_dir = oct_to_vec(jittered_oct);\n    vec3 pos = texelFetch(lightprobe_x, probe_coord, 0).xyz;\n    // vec3 pos = (vec3(probe_pos)+blue_noise(gl_FragCoord.xy/256.0f+vec2(0.8f,0.2f)).xyz)*lightprobe_spacing;\n\n    vec3 hit_pos;\n    float hit_dist;\n    ivec3 hit_cell;\n    vec3 hit_dir;\n    vec3 normal;\n    // bool hit = coarse_cast_ray(ray_dir, pos, hit_pos, hit_dist, hit_cell, hit_dir, normal);\n\n    ivec3 origin = ivec3(0);\n    ivec3 size = ivec3(512);\n    uvec4 voxel;\n    bool hit = cast_ray(materials, ray_dir, pos, size, origin, hit_pos, hit_dist, hit_cell, hit_dir, normal, voxel, 24);\n\n    const float decay_fraction = 0.01;\n\n    if(hit)\n    {\n        uvec4 voxel = texelFetch(materials, hit_cell, 0);\n\n        uint material_id = voxel.r;\n\n        float roughness = get_roughness(material_id);\n        vec3 emission = get_emission(material_id);\n\n        color.rgb = vec3(0);\n        color.rgb += -(emission)*dot(normal, ray_dir);\n\n        // float total_weight = 0.0;\n\n        // vec3 reflection_normal = normal+0.5*roughness*(blue_noise(gl_FragCoord.xy/256.0+vec2(0.82,0.34)).xyz-0.5f);\n        vec3 reflection_normal = normal;\n        reflection_normal = normalize(reflection_normal);\n        // vec3 reflection_dir = ray_dir-(2*dot(ray_dir, reflection_normal))*reflection_normal;\n        vec3 reflection_dir = normal;\n        // reflection_dir += roughness*blue_noise(gl_FragCoord.xy/256.0f+vec2(0.4f,0.6f)).xyz;\n\n        vec2 sample_depth;\n        color.rgb += fr(material_id, reflection_dir, -ray_dir, normal)*sample_lightprobe_color(hit_pos, normal, vec_to_oct(reflection_dir), sample_depth);\n    }\n    // else\n    // {\n    //     vec2 sample_depth;\n    //     vec3 sample_color = sample_lightprobe_color(hit_pos, ray_dir, vec_to_oct(ray_dir), sample_depth);\n    //     // hit_dist += sample_depth.r;\n    //     color.rgb = sample_color;\n    // }\n\n    depth.r = clamp(hit_dist, 0, 1*lightprobe_spacing);\n    depth.g = sq(depth.r);\n\n    color.a = decay_fraction;\n    depth.a = decay_fraction;\n    //TODO: this arbitrarily gives later samples in the same frame more weight\n\n    // depth.rg = vec2(512.0,sq(512.0));\n    // color.rgb = 0.5+0.5*ray_dir;\n    // color.rgb = clamp(color.rgb, 0.0f, 1.0f);\n    color.rgb = max(color.rgb, 0);\n}\n"; glShaderSource(update_lightmap_program_GL_FRAGMENT_SHADER, 1, &source, 0);}glCompileShader(update_lightmap_program_GL_FRAGMENT_SHADER); glGetShaderiv(update_lightmap_program_GL_FRAGMENT_SHADER, GL_COMPILE_STATUS, &error); if(error == GL_FALSE) { int info_log_len = -1; char* info_log = (char*) free_memory; glGetShaderInfoLog(update_lightmap_program_GL_FRAGMENT_SHADER, available_memory, &info_log_len, info_log); log_output("info log is ", info_log_len, " characters long\n"); log_error("could not compile update_lightmap_program_GL_FRAGMENT_SHADER:\n", info_log); } glAttachShader(update_lightmap_program, update_lightmap_program_GL_FRAGMENT_SHADER); 
glLinkProgram(update_lightmap_program);glDetachShader(update_lightmap_program, update_lightmap_program_GL_VERTEX_SHADER); glDeleteShader(update_lightmap_program_GL_VERTEX_SHADER); 
glDetachShader(update_lightmap_program, update_lightmap_program_GL_FRAGMENT_SHADER); glDeleteShader(update_lightmap_program_GL_FRAGMENT_SHADER); 
glGetProgramiv(update_lightmap_program, GL_LINK_STATUS, &error); if(error == 0) { char* info_log = (char*) free_memory; glGetProgramInfoLog(update_lightmap_program, available_memory, 0, info_log); log_error(info_log); }unreserve_block(manager);}